// 2/Feb/2022 from 192.168.1.3 - beta 3e pre24c

/*
 
  Copyright Kevin Hawkins 2019, 2020, 2021     apps@ukusa.co.uk

  RESTRICTED LICENCE:
  See associated licence file.
  By usage of this application you accept the terms of the licence.
  Currently no part of this code may be copied, redistributed, altered or used in any way without my express written/email permission.
  This code may be installed for the express purpose of testing and reporting issues. You may also
  alter and adapt this code for your own personal useage, but it may not be onwardly distributed to anyone in any form,  or portions used in any other available application.
  My current intention is to relax the terms of this licence upon general release.

  No representation of any form is made to the suitability of this code or it's fitness for any purpose at all. Use entirely at your own discretion and risk . No liability accepted.
  Logging code was adapted from Eric Vitale's ST LIFX application, with thanks.  Copyright 2016 ericvitale@gmail.com

  Many thanks for contributions from Casey, Jeff, Cody, Kirk, Andy and more. Much appreciated.

  Support via Hubitat community beta threads
  https://community.hubitat.com/t/beta-mqtt-app/32750
  You can contact me via PM on that forum  @kevin

  Bug reports to this GitHub repository please (issues)

*/

/* #########################################################################################################
  This application is provided free of charge .. enjoy. 

  Should you wish you can help keep me awake longer via this link

  https://www.buymeacoffee.com/xAPPO
  or paypal@ukusa.co.uk
  
  Many thanks .. much appreciated

   ######################################################################################################### */


// PLEASE NOTE:  As this application uses static @Field variables you can't just edit/save the code and continue running (as they get purged). It will need completely restarting each time you edit the code to run correctly.

import java.security.MessageDigest
//import groovy.json.JsonSlurper
import groovy.transform.Field
@Field static String block=''
@Field static String nodes = ''
@Field static Map topicLink = [:]
@Field static Map properties = [:]
@Field static Map nameMap = [:]
@Field static Map newMap = [:]
@Field static Map dynVars = [:]
@Field static String lastDevDim='none'
@Field static String lastDevOnOff='none'
@Field static String lastDev='none'


//counter = 0 // No explicit type definition.

definition(
	name: "MQTT",
	namespace: "ukusa",
	author: "Kevin Hawkins",
	importUrl: "https://raw.githubusercontent.com/GledholtHall/beta-3/master/MQTT%20app",
	description: "Links MQTT with HE devices",
	category: "Intranet Connectivity",
	iconUrl: "https://s3.amazonaws.com/smartapp-icons/Convenience/App-BigButtonsAndSwitches.png",
	iconX2Url: "https://s3.amazonaws.com/smartapp-icons/Convenience/App-BigButtonsAndSwitches@2x.png",
    installOnOpen: true,
	iconX3Url: "https://s3.amazonaws.com/smartapp-icons/Convenience/App-BigButtonsAndSwitches@2x.png"
)


preferences {  // can't use atomicState vars in this section

			//page(name: "Configuration", title: "<h2><b>MQTT</b></h2>", nextPage: "vMQTT", uninstall: false, hideable: true,hideWhenEmpty: true){
            page(name: "configuration", title: "<h2><b>MQTT</b></h2>",install: true, uninstall: true, hideable: true,hideWhenEmpty: true){
            section("  ver:   beta 3e pre 24b"){}
            section ("<b>MQTT Broker</b>", hideable: true, hidden: true){
				//createMQTTclient()
                //input "mqtt2", "device.MQTTClient", required: false, multiple: false, title: ""
                //input "mqtt", "device.MQTTClient", required: false, multiple: false, title: "<b>MQTT Broker</b>", submitOnChange: false
				input name: "hubName",  type: "text", title: "<b>Hub Name</b>", description: "  choose a unique name for this Hubitat Hub", required: true, displayDuringSetup: true, submitOnChange: false
		        input name: "MQTTBroker", type: "text", title: "<b>MQTT Broker Address</b>&nbsp&nbsp&nbsp&nbsp&nbsp prefixed tcp://...", description: "e.g. tcp://192.168.1.17:1883  - NB you must include tcp://...", required: true, displayDuringSetup: true
		        input name: "username", type: "text", title: "<b>MQTT Username</b>", description: "(leave blank if none)", required: false, displayDuringSetup: true
		        input name: "password", type: "password", title: "<b>MQTT Password</b>", description: "(leave blank if none)", required: false, displayDuringSetup: true
                input "cleanSession", "bool", title: "<b>Clean Session:</b><br> If OFF then should your MQTT session disconnect MQTT will remember your subscriptions and send messages you missed upon reconnection. [default: ON] requires HE v2.2.2+ ", required: true, defaultValue: true, submitOnChange: false
                //input "newMQTTDev", "button", title: "Create MQTT broker device driver", textColor: "green"
            }

			section ("<b>Configuration</b>", hideable: true, hidden: true) {
				input "mqttRemoveDevices", "bool", title: "<b>Purge Discovered Devices</b><br> WARNING: Setting this will delete all your 'discovered devices' when you click 'Done'. However your selected devices from HA statestream, discovery and homie discovery will be re-added automatically when app is run again but you will need to re-add them manually in your Dashboards as the ID changes. Your selected 'published' devices and any manually created 'ad-hoc' devices will not be affected", required: true, defaultValue: false, submitOnChange: false
                input "WipeDevices", "bool", title: "<b>Forget enabled devices</b><br> Warning you will have to manually re-enable your devices for export and import from MQTT", submitOnChange: false
				input "logging", "enum", title: "<b>Log Level</b>", required: false, defaultValue: "INFO", options: ["TRACE", "DEBUG", "INFO", "WARN", "ERROR", "DISABLED"]
				input "tempUnits", "enum", title: "<b>Temperature units</b>", required: false, defaultValue: "Celsius x.xx°C", options: ["Celsius x.xx°C", "Celsius x.x°C", "Fahrenheit °F","Fahrenheit x.x°F"]
				input "lengthUnits", "enum", title: "<b>Length units (not yet functional)</b>", required: false, defaultValue: "Metric (mm,m,km)", options: ["Metric (mm,m,km)", "Imperial (inches/feet/miles)"]
                input "allowMqttUnlock", "bool", title: "<b>Allow Unlock via MQTT</b><br>WARNING: Setting this will allow unlocking locks via MQTT.  It is recommended that your MQTT instance requires username/password & is protected by SSL", required: false, defaultValue: false, submitOnChange: false
                input "allowHSMDisarm", "bool", title: "<b>Allow HSM disarm via MQTT</b><br>WARNING: Setting this will allow HSM disarm via MQTT, provided 'Allow HSM control' is ON", required: false, defaultValue: false, submitOnChange: false
                input "allowHSMControl", "bool", title: "<b>Allow HSM control via MQTT</b><br>WARNING: Setting this will allow all HSM control via MQTT (except disarming if 'Allow HSM disarm' is OFF)", required: false, defaultValue: false, submitOnChange: false
                input "mqttKeypadMode", "enum", title: "<b>Allow Keypad control and specify when a code is needed</b><br>WARNING: Setting this will allow controlling Keypade code via MQTT.  It is recommended that your MQTT instance requires username/password & is protected by SSL", required: false, defaultValue: "No control of keypad", options: ["No control of keypad", "No Keycode needed", "Keycode to Arm only","Keycode to Arm/Disarm"]
				input name: "mqttKeypadCode", type: "text", title: "Keypad Code", description: " Code to be used via HA", submitOnChange: false, required: false
            }
                
            section ("<b>MQTT Publish Formats</b>", hideable: true, hidden: true){
				//input "HEBasic", "bool", title: "<b>Hubitat basic MQTT</b>", required: true, defaultValue: false, submitOnChange: false 
				input "homiePublish", "bool", title: "<b>homie 3 protocol</b>", required: true, defaultValue: true, submitOnChange: false
                input "minHomie", "bool", title: "<b>Complete & compliant homie topics</b>", required: true, defaultValue: false, submitOnChange: false
				input "homieStatesPersist","bool",title: "<b>&nbsp&nbsp&nbsp&nbsp... retain homie states</b>", required: false, defaultValue: true, submitOnChange: false
				input "HADiscovery", "bool", title: "<b>Home Assistant MQTT discovery protocol (requires homie3 publish enabled)</b>", required: true, defaultValue: false, submitOnChange: false 	
				input name: "HADiscoveryTopic",  type: "text", title: "<b>Home Assistant Discovery Topic</b>", description: "  as configured in HA", required: false, displayDuringSetup: true, submitOnChange: false
				input "HARemember", "enum", title: "<b>Home Assistant MQTT discovered devices</b>", required: false, defaultValue: "Remember",options: ["Forget", "Remember"], submitOnChange: false			    
            }
                
            section ("<b>Discovery into HE</b>",hideWhenEmpty: true, hideable: true, hidden: true) {
                 href(name: "href2",
                 title: "Discovery Protocols",
                 required: false,
                 page: "discovery")
            }

                
            section ("<b>Virtual Devices</b>",hideWhenEmpty: true, hideable: true, hidden: true) {
                 href(name: "href",
                 title: "HE Virtual devices associated with arbitrary MQTT topics",
                 required: false,
                 page: "vMQTT")
            }
                
			section ("<b>Publish these HE devices to MQTT</b>",hideWhenEmpty: true, hideable: true, hidden: true) {
                input "modes", "bool", title: "Mode changes", required: false
                input "hsm", "bool", title: "Hubitat Security Monitor", required: false
                input "everything", "capability.*",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Everything (all capabilities/attributes a selected device supports)</b>", submitOnChange: false
                input "alarms", "capability.alarm",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Alarms</b>", submitOnChange: false
            //  input "actuators", "capability.actuator",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Actuators</b>", submitOnChange: false  
                input "batterysensors", "capability.battery",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Battery sensors</b>", submitOnChange: false
                input "bulbs", "capability.bulb",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Bulbs</b>", submitOnChange: false  
                input "buttons", "capability.button",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons</b>", submitOnChange: false  
                input "buttonshold", "capability.holdableButton",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons holdable</b>", submitOnChange: false
                input "buttonspush", "capability.pushableButton",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons pushable</b>", submitOnChange: false 
                input "buttonsrelease", "capability.releasableButton",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons releasable</b>", submitOnChange: false
                input "buttonsdtap", "capability.doubleTapableButton",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons double tapable</b>", submitOnChange: false
                input "carbonmonoxidesensors", "capability.carbonMonoxideDetector",hideWhenEmpty: true,multiple: true, required: false, title: "<b>Carbon monoxide detectors</b>", submitOnChange: false
                input "chimes", "capability.chime",hideWhenEmpty: true,multiple: true, required: false, title: "<b>Chimes</b>", submitOnChange: false               
                input "colour", "capability.colorControl",hideWhenEmpty: true,multiple: true, required: false, title: "<b>Colour control light devices</b>", submitOnChange: false
				input "colourT", "capability.colorTemperature",hideWhenEmpty: true,multiple: true, required: false, title: "<b>Colour temperature light devices</b>", submitOnChange: false
                input "colourMode", "capability.colorMode",hideWhenEmpty: true,multiple: true, required: false, title: "<b>Colour Mode devices</b>", submitOnChange: false
                input "contactsensors", "capability.contactSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Contact sensors</b>", submitOnChange: false
                input "dimmers", "capability.switchLevel",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Dimmers</b>", submitOnChange: false
                input "fans", "capability.fanControl",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Fans</b>", submitOnChange: false
				input "garagedoors", "capability.garageDoorControl",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Garage Door</b>", submitOnChange: false  
                input "humiditysensors", "capability.relativeHumidityMeasurement",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Humidity sensors</b>", submitOnChange: false
				input "illuminancesensors", "capability.illuminanceMeasurement",hideWhenEmpty: false, multiple: true, required: false, title: "<b>Illuminance sensors</b>", submitOnChange: false
                input "keypads", "capability.securityKeypad",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Keypads</b>", submitOnChange: false
                input "locks", "capability.lock",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Locks</b>", submitOnChange: false  //Casey
                input "lights", "capability.light",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Lights</b>", submitOnChange: false  //Casey
				input "motionsensors", "capability.motionSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Motion sensors</b>", submitOnChange: false
                input "mqtttext", "capability.telnet",hideWhenEmpty: true, multiple: true, required: false, title: "<b>MQTT Text</b>", submitOnChange: false
                input "musicplayers", "capability.musicPlayer",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Music Players</b>", submitOnChange: false
                input "outlets", "capability.outlet",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Outlets</b>", submitOnChange: false
                input "powersensors", "capability.powerMeter",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Power sensors</b>", submitOnChange: false
				input "presencesensors", "capability.presenceSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Presence sensors</b>", submitOnChange: false
                input "ramp", "capability.switchLevel",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Ramp control via MQTT</b>", submitOnChange: false
                input "refresh", "capability.*",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Refresh (if supported by device)</b>", submitOnChange: false  //Casey
                input "relayswitches", "capability.relaySwitch",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Relay Switches</b>", submitOnChange: false
                input "sensors", "capability.sensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Sensors</b>", submitOnChange: false  
                input "shocksensors", "capability.shockSensor",hideWhenEmpty: true, title: "<b>Shock sensors</b>", multiple: true, required: false
                input "smokesensors", "capability.smokeDetector",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Smoke detectors</b>", submitOnChange: false
                input "speechsynthesis", "capability.speechSynthesis",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Speech Synthesis</b>", submitOnChange: false
                input "switches", "capability.switch",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Switches</b>", submitOnChange: false
                input "tempsensors", "capability.temperatureMeasurement",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Temperature sensors</b>", submitOnChange: false
				input "thermostats", "capability.thermostat",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Thermostats</b>", submitOnChange: false
                input "valves", "capability.valve",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Valves</b>", submitOnChange: false 
                input "globVars", "device.VirtualOmniSensor", required: false, title: "<b>Global Variables</b>",hideWhenEmpty: true, multiple: true, submitOnChange: false
                input "gVars", "device.RMConnectorVariable", required: false, title: "<b>New Global Vars</b>",hideWhenEmpty: true, multiple: true, submitOnChange: false
                //input "variables", "device.VirtualOmniSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Variables</b>", submitOnChange: false 
                input "voltagesensors", "capability.voltageMeasurement",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Voltage sensors</b>", submitOnChange: false
                input "watersensors", "capability.waterSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Water Sensors</b>", submitOnChange: false
                input "windowshades", "capability.windowShade",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Window Shades</b>", submitOnChange: false
                input "listAll", "capability.*",hideWhenEmpty: true, title: "<b>List devices Capabilities and Attributes to Hubitat Topic</b>", multiple: true, required: false
                //TODO add remaining sensors type (as and if requested)
   
			}	
		}

    //page(name: "vMQTT", nextPage: "discovery") 
    
    page(name: "vMQTT", nextPage: "configuration") 
    page(name: "synchDiscoveries", nextPage: "configuration")
    page(name: "synchHA", nextPage: "configuration")
    page(name: "discovery", title: "Select MQTT discovered devices", install: false,uninstall: false, nextPage: "configuration")
}

def vMQTT() {
    
    // This dynamic page code is truly awful I know.   I have learned a lot more since I first wrote it and will revisit it again soon.
    // It's a real kludge but works I think
    // If you are viewing this code for help with dynamic pages then it wont ! Check out someone else's dynamic page code
    
      dynamicPage(name: "vMQTT", title: "<h2><b>Virtual MQTT Devices and Data</b></h2>(optional)", install:false, nextPage: "configuration") {
          
        atomicState.vList=["RM Connector Variable", "MQTT Text","Remote Thermostat", "Virtual audioVolume","Virtual CO Detector", "Virtual Color Temperature Light", "Virtual Contact Sensor", "Virtual Dimmer", "Virtual Fan Controller", "Virtual Garage Door Controller", "Virtual Humidity Sensor", "Virtual Illuminance Sensor", "Virtual Lock", "Virtual Moisture Sensor", "Virtual Motion Sensor", "Virtual Multi Sensor", "Virtual Omni Sensor", "Virtual Presence", "Virtual RGB Light", "Virtual RGBW Light", "Virtual Shade","Virtual Smoke Detector", "Virtual Switch", "Virtual Temperature Sensor", "Virtual Thermostat"  ]
        section {
          input "virtuals", "capability.virtual",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Virtual Devices</b>", submitOnChange: false
          input(name: "capability", type: "enum", title: "Device Type",description: null, multiple: false, required: false, submitOnChange: true, options: atomicState.vList)
        }  
        attList=[]
        mqtt = getChildDevice("MQTT: Child device driver")
        log ("Device is $atomicState.dni", "LOG")
          log ("======================================================================", "LOG")
          settings.each {k,v -> 
               //log.debug "it.name=$k, it.value=$v"
              if (k.startsWith("vAr_")) {
                  //log.debug "Inputs: $k      $v"
                  //log.debug ("Stored: " + dynVars[k])
                  if (dynVars[k] != v)  {
                      if (dynVars[k]==null) 
                      {
                          log("ignored null dynVars ","LOG")
                          dynVars[k]=v
                      }
                          
                    log("$k changed from " + dynVars[k] + " to $v","KH")
                      udDNI=''
                      index1=k.indexOf('_',8)
                      //log ("Index1 is $index1","KH")
                      if (index1 != -1) {
                          index2=k.indexOf('_',index1+1)
                          //log ("Index2 is $index2","KH")
                          if (index2 != -1) {
                              index3=k.indexOf('_',index2+1)
                              //log ("Index3 is $index3","KH")
                              if (index3 != -1) {
                                  index4=k.indexOf('_',index3+1)
                                  if (index4==-1) log ("string was $k", "KH")
                                  else {
                                      //log ("Index4 is $index4","KH")
                                      udDNI=k.substring(index1+1, index3)
                                  }
                                  if (udDNI!=null) {
                                      log ("udDNI: $udDNI","KH")
                                      udDev=getChildDevice (udDNI)
                                      if (udDev!=null) {
                                          log ("udDevice: $udDev.displayName","KH")
                                          aTopic=k.substring(index3+1)
                                          if ((aTopic!=null)&&(aTopic!='')){
                                              if (aTopic=="text_MAP") return  // block a text_MAP being created
                                               if (v=='~~delete~~') {
                                                   udDev.removeDataValue ("$aTopic")
                                                   log ("Deleted data $aTopic","WARN")
                                               }
                                               else {
                                                  log ("AttributeData: $aTopic","KH")

                                                  log ("[$udDev.displayName] Updated Data $aTopic to [$v]","KH")
                                                  udDev.updateDataValue("$aTopic", "$v")
                                                   if ((mqtt!=null)&&(aTopic.endsWith("_Topic"))){
                                                       mqtt.subscribeTopic ("$v")
                                                       // need to add to topiclink too
                                                       updateTopicLink (udDev.displayName,v, udDNI) 
                                                   }
                                              }
                                          }
                                      }
                                  }
                              }
                              else {
                                  udDNI=k.substring(index1+1)
                                  log ("udDNI: $udDNI","KH")
                                  log ("Attribute data is missing from this device", "KH")
                              }
                          }
                      }
                  dynVars[k]=v  // recreates the current
                }
              }
            }
          log ("======================================================================", "LOG")      
        

        if (atomicState.Mappings==null) atomicState.Mappings=[:]

        if (capability) {
            def String varCap = "var_" + "${capability}".replaceAll("\\s","")
            sensor=false
            settings[varCap].each { virtDev ->
                if (virtDev !=null) virtDev.updateDataValue("mqtt", "enabled") // remove ?? not useful as we don't ever disable them ...
                dOrigin = (virtDev.getDataValue("origin"))
                if ((dOrigin=='user')||(dOrigin=="HA Discovery")) {  // This avoids registering HE devices (again)
                    
                    log ("Subscribe to events from virtual device $virtDev","LOG")
                    registerAll (virtDev,0,'auto')
                }
            }
            
            dType = "capability.nowt"
            if (capability.contains("Sensor")||capability.contains("Presence")) sensor=true
            dType="device."+capability.replaceAll("\\s","")           
 //     TODO  iNVESTIGATE IMPACT OF USING NON VIRTUAL DEVICES
            //else if (capability == "All Switches") dType= "capability.switch"
            //else if (capability == "All Dimmers") dType= "capability.switchLevel"
                section {
 
                    atomicState.tete =[]

                    input(name: varCap, type: dType, title: "MQTT enabled $capability devices",description: null, multiple: true, required: false, submitOnChange: true)
 
                }
            
                section {
                    app.removeSetting("vDev")     
                    input(name: "vDev", type: dType, title: "Edit this $capability device",description: null, multiple: false, required: false, submitOnChange: true)
                    if (vDev == null) {
                    app.updateSetting("vDevName","")
                    input (name: "vDevName",type: "text", title: "... or create a new virtual $capability device called ..." , required: false, submitOnChange: true)
                    if (vDevName != null){
                        atomicState.newDevName=vDevName  // This isn't enough to identify it from an incoming MQTT message - can only identify by topic
                        atomicState.newDevType=capability
                        input "newVDev", "button", title: "Create device $vDevName", textColor: "green"
                    }
                    else atomicState.vDevName=""
                    }
                    else {
                        enabled=false
                        settings[varCap].each { enab ->
                            if ("$enab"=="$vDev")  enabled=true
                        }
                         // input "editVDev", "button", title: "Edit device $vDev", textColor: "blue"
                        dOrigin = (vDev.getDataValue("origin"))
                        
                        //log ("Device is $vDev.displayName","INFO")
                        //log ("Origin is $dOrigin","INFO")
                        atomicState.device=vDev
                        if (dOrigin=="user" && (enabled)) input "oldVDev", "button", title: "Delete device $vDev", textColor: "red"
                    }                   
                }// end section
        }  // end capability
        atomicState.first=false

        if (vDev) { // && atomicState.edit) {  // this is the whole page
          // if ((dOrigin=='user'){  // open it to all
          if ((dOrigin=='user')||(dOrigin=='HA Discovery')||(dOrigin=='Home Assistant')||(dOrigin=="C-Bus")||(dOrigin=='homie')) {
            log ("Selected Device is ${vDev.displayName}  - last was {$atomicState.vDev}","DEBUG")            
            if (vDev.displayName==atomicState.vDev) newDev=false else newDev=true
            log ("newDev is $newDev","LOG")
          if (newDev) { 
                log("#### Blocking any data updates to device from previous screen ####","INFO")
                atomicState.attList=[]
				temp=atomicState.attList						
				if (vDev.getTypeName()=="RM Connector Variable") temp.add("variable")
                else if (vDev.getTypeName()=="MQTT Text") temp.add("text")
                    else if (vDev.getTypeName()=="Remote Thermostat") temp.add("whatsit")
              
                vDev.capabilities.each { cap ->
                    log ("Found $cap in vDev $vDev.displayName","INFO")
                    cap.attributes.each { attr ->
                    log ("Found attribute $attr in $vDev.displayName [$cap]", "WARN")
                    temp.add("${attr}")
               }
          }
		  log ("Attribute list is now $temp","WARN") 
          atomicState.attList=temp											  
		// atomicState.attList now contains every attribute that the newly selected device has	but caution - may not align with attrList=vDev.getSupportedAttributes()	
        // this is because 1) I force text values into atomicState.attList e.g. 'variable' and 'text' and also attrList has ALL (custom) attributes not just those within a capability
                    
        }
          else log ("Refresh of page with no change of device","LOG")  //something changed or F5
            
            section {
                   // input(name: "atts", type: "enum", title: "Device Attributes",description: null, multiple: false, required: false, submitOnChange: true, options: ["Hi","you"])
                }
            atomicState.vDev=vDev.displayName

          if (enabled) {   // don't display if not mqtt enabled
              section {
                    temp=atomicState.attList.sort()
                    atomicState.attList=temp
                    //input(name: "atts", type: "enum", title: "Device atomic Attributes",description: null, multiple: false, required: false, submitOnChange: true, options: atomicState.attList)

assisted=false   // beta2 and beta3 .. disabling this feature temporarily as confusing
                    if (assisted) input (name: "devWildcard", type: "text", title: "Please enter a wildcarded topic encompassing the whole device but no others", submitOnChange: true)
                    if ((assisted) && (devWildcard != null)) {

                        atomicState.dTopic=devWildcard
                        atomicState.devTopics = (atomicState.devTopics != null)?atomicState.devTopics:[]
                        input "topics", "button", title: "Get device topics from MQTT for ${devWildcard}"

                        input "deviceTopics", "enum", multiple: false, title: "<b>MQTT discovered topics within ${devWildcard} device</b>", options: atomicState.devTopics.sort()
                        if (!sensor){
                            input(name: "cmdSuffix", type: "text", title: "Command suffix for topics eg /set or /cmd", required: false, submitOnChange: true)
                        }
                    
                    }
               } //end section
            atomicState.devTopics = (atomicState.devTopics != null)?atomicState.devTopics:[]
            temp2=atomicState.devTopics
            for (i=0; i < temp2.size(); i++) {
                temp2[i]=temp2[i]+ "${cmdSuffix}"
            }
             
      section {  //data value update section 
          atomicState.dni = vDev.displayName

        for (i = 0; i < atomicState.attList.size(); i++) { // loops for every attribute device has
            
                        def String var = "vAr_Var_${i}_"+vDev.deviceNetworkId+'_'
                        def String varCmd = "vAr_Cmd_${i}_"+vDev.deviceNetworkId+'_'
            log ("The accompanying [$i] attribute is $atomicState.attList[i]","LOG")
                        def String varAtt = "vAr_Att_${i}_"+vDev.deviceNetworkId+'_'
                        //def String varJSON = "vAr_JSN_${i}_"+vDev.deviceNetworkId+'_'
                        // TODO Check - if this is a new device what happens
                        // Purge previous device settings
                        log ( "var is " + var + " and attribute is  "+ atomicState.attList[i],"LOG")
                         try {
                            data=vDev.getDataValue("${atomicState.attList[i]}_Topic")
                             log ("newDev is $newDev for ${atomicState.attList[i]}","ERROR")
                             if (newDev)  app.updateSetting (var,data)

                             
                            dataAtt=vDev.getDataValue("${atomicState.attList[i]}_MAP") 
                             log ("Recovered data for map $i $dataAtt","LOG")
                             if (newDev)  app.updateSetting (varAtt,dataAtt)
                            //dataJSON=vDev.getDataValue("${atomicState.attList[i]}_JSON")
                            // if (newDev)  app.updateSetting (varJSON,dataJSON)  //could be null

                         }
                         catch (e) {
                             log ("No state for $i","DEBUG")
                          } 
                        if (!sensor){
                          try {
                            dataC=vDev.getDataValue("${atomicState.attList[i]}_Cmd")  
                            log ("_Cmd recovered $varCmd -- $dataC --  $newDev","KH")
                            if (newDev) app.updateSetting (varCmd,dataC) 

                          }
                         catch (e) {
                             log ("No cmd for $i","DEBUG")
                          }
                        }
            
                if (!newDev){ // this happens when a data value was updated and the device is redisplayed (it also happens when page two is originally entered too)


                            log ("Settings for $var is ${settings[var]} ~ ${attList[i]}", "KH")
                            
                            
							if ((settings[var]!=null) && (settings[var]!=data)) {
                                
                                //log ("  ","KH")
                                //log ("[$i] UPDATE device $vDev.displayName - ${atomicState.attList[i]}_Topic","KH")
                                //log ("[$i] UPDATING - from " + vDev.getDataValue("${atomicState.attList[i]"}_Topic),"KH")
                                                                                     
         // disabled vDev.updateDataValue("${atomicState.attList[i]}_Topic", settings[var].trim())
                                myVal=settings[var].trim()  // this is not the latest value :-(
// #############################  TODO need to strip JSON 
                                
                                
//                                log ("Updating topicLink .. $myVal = $vDev.deviceNetworkId","LOG")                                
                                //if (temp.containsKey(myVal)){
                                //    list=temp[myVal]       //.add(topic)
                                updateTopicLink(vDev.displayName, myval,vDev.deviceNetworkId)
                                
                                log ("[$i] UPDATED on add to $myVal","KH")  //   ${settings[var]}","LOG")
                                jas=myVal.indexOf("{")
                                if ((jas>0) && (myVal.endsWith(':}'))){  //strip json
                                            //log ("Strip JSON value $defOne for subscribe" , "KH")
                                            myVal=myVal.substring(0, jas)   
                                }

                                if (mqtt!=null) mqtt.subscribeTopic ("$myVal") // // ("${settings[var]}")  
                                                             
                            }
                            if ((settings[varAtt]!=null) && (settings[varAtt]!=dataAtt)) {

//TODO THIS IS A TEMPORARY FIX / HACK
//===================================
                               //attrList=vDev.getSupportedAttributes()
                                //if (attrList[i]!=null && attrList[i].dataType =="ENUM") {
                               if ((atomicState.attList[i]=='level')|(atomicState.attList[i]=='text')|(atomicState.attList[i]=='battery')) {   //   TODO A lot more of these shouldn't have map data
                               log ("Blocking adding _MAP data for $atomicState.attList[i]","KH")
                                   log ("was to be " + settings[varAtt].trim(),"KH")
                                }
                               else {
                                   log ("Updated[$i] " + atomicState.attList[i] +"_Map to" + settings[varAtt].trim(),"LOG")
          // disabled vDev.updateDataValue("${atomicState.attList[i]}_MAP", settings[varAtt].trim())
                               }
                            }

                          if (!sensor) {
                            if ((settings[varCmd]!=null) && (settings[varCmd]!=dataC)) {
                                // ToDo - be able to send a JSON command
                                //log ("[$i] UPDATE device $vDev.displayName - ${atomicState.attList[i]}_Cmd","KH")
                                //log ("[$i] UPDATING - from " + vDev.getDataValue("${atomicState.attList[i]}_Cmd"),"KH")
                                //myVal=settings[varCmd].trim()
                                //log ("myVal cmd $myVal  vDev  $vDev.deviceNetworkId","DEBUG")
                                //temp[myVal] = vDev.deviceNetworkId  //  Don't get incoming messages on Cmd topics
                                //log ("[$i] UPDATED to ${settings[varCmd]}","KH")
                                //log ("  ","DEBUG")
                                // subscribe this device for all attributes/events
                                log ("Subscribing to events from device $vDev","KH")
                                registerAll (vDev,0,'auto')
                            }  
                            }

                } // not newDev
                        
                        log ("atomicState.devTopics is $atomicState.devTopics","TRACE")  //maybe old - for the last looked up device
                        log ("atomicState.attList is $atomicState.attList","TRACE")
                        
                        if (assisted) {
                            var=var+"${atomicState.attList[i]}_Topic"
                            input(name: var, type: "enum", title: "<b> ${atomicState.attList[i]} </b> attribute MQTT status topic   [$var]", description: null, multiple: false, required: false, submitOnChange: true, options: atomicState.devTopics.sort() + "/sett")
                            if ((atomicState.attList[i]=='battery')|(atomicState.attList[i]=='networkStatus')) {  // Block _Cmd data entry fields // Should really check is MQTT Text device when block networkStatus
                            }
                            else {
                                varCmd=varCmd+"${atomicState.attList[i]}_Cmd"
                                if (!sensor) input(name: varCmd, type: "enum", title: "<b> ${atomicState.attList[i]} </b> MQTT command topic", description: null, multiple: false, required: false, submitOnChange: true, options: temp2.sort())
                            }
                        }
                        else {
                            defOne=vDev.getDataValue("${atomicState.attList[i]}_Topic")
                            if (i==0){
                            if ((defOne != null)&&(defOne!='')){
                                log ("TODO This is now not a valid topic to use for ID [$i] [$defOne] ","KH")
                                // This is not now viable as one topic can now map to several devices
                                //if (i==0){
                                    try {
                                        jas=defOne.indexOf("{")
                                        if ((jas>0) && (defOne.endsWith(':}'))){
//                                            log ("Strip JSON value $defOne for DNI" , "KH")
                                            defOne=defOne.substring(0, jas ) 
                                        }
                                        //vDev.setDeviceNetworkId("MQTT:virtual_" + defOne )
//                                        log ("$vDev.displayName - Blocked updating DeviceNetworkId with $defOne","KH")
                                    }
                                    catch(e) { 
                                        log ("DNI nametopic [MQTT:virtual_$defOne already exists please choose another: " +e,"ERROR")
                                        dup=getChildDevice("MQTT:virtual_"+defOne)
                                        if  (dup!=null) log ("You already have a HE device [$dup.displayName] mapped to this MQTT topic","WARN")
                                    }
                                }
                            }
                            //if (i>0) log ("Several state topics for $vDev","DEBUG")
                        }
                            defTwo=vDev.getDataValue("${atomicState.attList[i]}_Cmd")
            
                            var=var+"${atomicState.attList[i]}_Topic"
                            app.updateSetting(var,defOne)  //KH
                            input(name: var, type: "text", defaultValue: defOne,title: "<b> ${atomicState.attList[i]} </b> attribute MQTT status topic", description: null, multiple: false, required: false, submitOnChange: true)
                            if ((atomicState.attList[i]=='battery')|(atomicState.attList[i]=='networkStatus')) {  // Block _Cmd data entry fields // Should really check is MQTT Text device when block networkStatus
                            }
                            else {
                                varCmd=varCmd+"${atomicState.attList[i]}_Cmd"
                                if (defTwo!=null) app.updateSetting(varCmd,defTwo)  //KH
                                if (!sensor) input(name: varCmd, type: "text", defaultValue: defTwo, title: "<b> ${atomicState.attList[i]}    </b> MQTT command topic", description: null, multiple: false, required: false, submitOnChange: true)         
                            }

       //  try {
            
// BUG TOFIX our i values aren't aligned - we might skip attributes
           attrList=vDev.getSupportedAttributes() // why do this when we have atomicState.attList[] - these may not align as this misses 'text and 'variable' but includes custom attributes and those not within a capability
           // attrList is an attribute object  atomicState.AttList is a text list of attributes.
log (atomicState.attList,"LOG")   //  << much bigger list - complete
log (attrList,"LOG")
//log(attrList[i].dataType + "- networkStatus should be ENUM - its string", "TRACE")

           if (attrList[i]!=null && attrList[i].dataType =="ENUM") {   
               
             String atts = "${attrList[i].getPossibleValues()}" 
               log ("ENUM on " + attrList[i] + " === " +atomicState.attList[i] + " === " + atts, "LOG")
             //if (vDev.getDataValue("${atomicState.attList[i]}_MAP")){
               if (vDev.getDataValue("${attrList[i]}_MAP")){
                // Think I already have this in dataFalse
               //try {dataAtt=vDev.getDataValue("${atomicState.attList[i]}_MAP")} catch(e) {log ("FAIL OFF","WARN")}
                   try {dataAtt=vDev.getDataValue("${attrList[i]}_MAP")} catch(e) {log ("FAIL OFF","WARN")}
                   // if (newDev){                        
                        app.updateSetting(varAtt,dataAtt)
                        defAtt=dataAtt
                   // }
                   
                    //if (atomicState.attList[i] != "level") {  // Need to expand this to other numerics and non binaries
                   if ("${attrList[i]}" != "level") {  // Need to expand this to other numerics and non binaries  ?? Cant be it's an ENUM
                        if (attrList[i].dataType =="ENUM") {
                         //varAtt=varAtt+"${atomicState.attrList[i]}_MAP"
                        varAtt=varAtt+"${attrList[i]}_MAP"
                        //input(name: varJSON, type: "text", defaultValue: '', title: "JSON {attribute:} name (optional)" , required: false, submitOnChange: false, hideWhenEmpty: true, width: 4)
                        //input(name: varAtt, type: "text", defaultValue: defAtt, title: "&nbsp &nbsp &nbsp &nbsp MQTT payload map values for <b>$atts</b> for the <b>${attrList[i]}</b> attribute <br> $varAtt &nbsp &nbsp &nbsp &nbsp [status] or [status][command]" , required: false, submitOnChange: true)// , width: 6)
                       input(name: varAtt, type: "text", defaultValue: defAtt, title: "<b>${attrList[i]}</b> attribute MQTT payload map values to <b>${atts.replace(', ',',')}</b> for both [status & command] or different [status][command]" , required: false, submitOnChange: true)// , width: 6)
                        }
                        if (!newDev)  {
                            //log ("2a Updating old ${atomicState.attList[i]}_MAP with ${settings[varAtt]} on $vDev.displayName","KH")
                            //if (settings[varAtt] != null) vDev.updateDataValue("${atomicState.attList[i]}_MAP", settings[varAtt])// $settings?.stateOFF)
                            //log.debug "2b Updating old ${atomicState.attList[i]}_JSON with ${settings[varJSON]} on $vDev.displayName"
                            //if ((settings[varJSON] != null)&&(settings[varJSON] != ' ')) vDev.updateDataValue("${atomicState.attList[i]}_JSON", settings[varJSON])// $settings?.stateOFF)
                        }
                    }
            }
            else {
                log ("Adding the default value for ${atomicState.attList[i]}_MAP","KH")
                //vDev.updateDataValue("${atomicState.attList[i]}_MAP", atts)
                atts=atts.replace(', ', ',')
      // disabled vDev.updateDataValue("${attrList[i]}_MAP", atts.trim())
                log ("Updating with #$atts#  #${atts.trim()}#","WARN")
            }
           } //not ENUM
        }// end for loop on each attribute (i) 
   } // end data value update section
         try {
            if (vDev.getDataValue("max_Level")){
				app.removeSetting("maxLev")							  
                section {
                    currentMax=vDev.getDataValue("max_Level")
                    if (currentMax != "null") {  //null is a text value
                        app.updateSetting("maxLev",currentMax) 
                        //if (maxLev!=null) currentMax=maxLev
                        if (!assisted) input(name: "maxLev", type: "text",defaultValue: currentMax, title: "Please enter the maximum possible level:" , required: false, submitOnChange: true)
                        else input(name: "maxLev", type: "enum",defaultValue: currentMax, title: "Please enter the maximum possible level:   [$maxLev]" , required: false, submitOnChange: true,multiple: false, options: atomicState.devTopics.sort())
                        //if (!newDev)  vDev.updateDataValue("max_Level", "$Topic6")
                    }
                }
            }
        }
        catch (e) {}
        //atomicState.edit=false      
        } // not enabled for MQTT

        else {
                if (vDev!=null) section (title: "This device <b> $vDev </b> is not enabled above") { }
                }
            } //dOrigin=user
            else section (title: "This device <b> $vDev </b> was not created within this app and so can't be edited here") { }
        } // end dynamic page    (vDev)          
    }
}

//=========================================================================================================================================================================================================================================
def synchDiscoveries() {
    
    mqtt = getChildDevice("MQTT: Child device driver")
    if ((settings?.CBusDiscovery == true)  && (settings?.CBusTopic != '') && (settings?.CBusTopic != null))
    {
        mqtt = getChildDevice("MQTT: Child device driver")
        mqtt.setCBusTopic(settings?.CBusTopic)
        numEnabled=0
        if (settings.CBus_light!=null) numEnabled += settings?.CBus_light.size()
        if (settings.CBus_text!=null) numEnabled += settings?.CBus_text.size()
        if (numEnabled != atomicState.CBNumEnabled) {
            log ("Need to run CBus Discovery $numEnabled ~ atomicState.CBNumEnabled", "WARN")
            atomicState.CBNumEnabled=numEnabled
            CBusDiscovery()
        }
    }
 
    atomicState.homie=settings?.homieDevice
    if ((settings?.homieDiscovery == true) &&(settings?.homieDevice != '') && (settings?.homieDevice != null))
    {
     /*   numEnabled=0
        if (Homie_onoff!=null) numEnabled += settings?.Homie_onoff.size()
		if (Homie_dim!=null) numEnabled += settings?.Homie_dim.size()
		if (Homie_sensors!=null) numEnabled += settings?.Homie_sensor.size()
        if (Homie_button!=null) numEnabled += settings?.Homie_button.size()
        if (Homie_variable!=null) numEnabled += settings?.Homie_variable.size()
        if (Homie_unknowns!=null) numEnabled += settings?.Homie_unknowns.size()
        if (numEnabled != atomicState.homieNumEnabled) {
            log ("Need to run homie Discovery  $numEnabled ~ $atomicState.homieNumEnabled", "WARN")
            atomicState.HomieNumEnabled=numEnabled
            homieDiscovery()
        }
*/
/*            
        	mqtt.subscribeTopic('homie/'+atomicState.homie+'/$nodes')
	        mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/$properties')  //Started using this 
	        mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/$type')      //TODO from here could get a device > type list as this returns all devices with a type
        	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/onoff')

            mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/dim')
            mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/dim/$format')  // to recover max_Level																							 
            mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/+/$unit')   

        	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/$name')
*/
        
        settings?.Homie_onoff.each {val -> 
                log ("Sensor Name is " + val, "KH")                   
                mqtt.subscribeTopic('homie/'+atomicState.homie+"/$val/"+'$type') 
                //mqtt.subscribeTopic('homie/'+atomicState.homie+"/$val/"+'$properties')
            }
            settings?.Homie_dim.each {val -> 
                log ("Sensor Name is " + val, "KH")                   
                mqtt.subscribeTopic('homie/'+atomicState.homie+"/$val/"+'$type')
                //mqtt.subscribeTopic('homie/'+atomicState.homie+"/$val/"+'$properties')
            }
            settings?.Homie_sensor.each {val -> 
                log ("Sensor Name is " + val, "KH")                   
                mqtt.subscribeTopic('homie/'+atomicState.homie+"/$val/"+'$type')
                //mqtt.subscribeTopic('homie/'+atomicState.homie+"/$val/"+'$properties')
            }
            settings?.Homie_button.each {val -> 
                log ("Sensor Name is " + val, "KH")                   
                mqtt.subscribeTopic('homie/'+atomicState.homie+"/$val/"+'$type')
                //mqtt.subscribeTopic('homie/'+atomicState.homie+"/$val/"+'$properties')
            }
            settings?.Homie_variable.each {val -> 
                log ("Sensor Name is " + val, "KH")                   
                mqtt.subscribeTopic('homie/'+atomicState.homie+"/$val/"+'$type')
                //mqtt.subscribeTopic('homie/'+atomicState.homie+"/$val/"+'$properties')
            }




    }
    atomicState.HA=settings?.HAStatestreamTopic
    if ((settings?.HAStatestream == true)  && (settings?.HAStatestreamTopic != '') && (settings?.HAStatestreamTopic != null))
    {     
        if (HA_Lights!=null) log ("HA Enabled lights: " + settings?.HA_Lights,"KH")
        
        // TODO investigate determining just new ones and also removing disabled devices  TODO
        /*                                                                             
        // always running currently - likely faster
        numEnabled=0
		if (HA_Sensors!=null) numEnabled += settings?.HA_Sensors.size()
		if (HA_BinarySensors!=null) numEnabled += settings?.HA_BinarySensors.size()
		if (HA_Groups!=null) numEnabled += settings?.HA_Groups.size()
        if (HA_Presence!=null) numEnabled += settings?.HA_Presence.size()
		if (HA_InputBooleans!=null) numEnabled += settings?.HA_InputBooleans.size()
        if (numEnabled != atomicState.HANumEnabled) {
           log ("Need to run HA Discovery  $numEnabled ~ $atomicState.HANumEnabled", "WARN")
           atomicState.HANumEnabled=numEnabled
           HADiscovery()
        }
        */
            settings?.HA_Lights.each {val ->                    
                // Now add these individually as discovery is based on device_class   <<< Think wrong as device_class often absent - Need to double check this TODO
                mqtt.subscribeTopic(atomicState.HA+"/light/$val/friendly_name")
                //mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing') 
                //pacingSet("HAFriendly1End")             
            }
            HA_Sensors.each {val -> 
                log ("Sensor Name is " + val, "KH")                   
                mqtt.subscribeTopic(atomicState.HA+"/sensor/$val/friendly_name")           
            }
            HA_BinarySensors.each {val -> 
                log ("BinarySensor Name is " + val, "KH")                   
                mqtt.subscribeTopic(atomicState.HA+"/binary_sensor/$val/friendly_name")            
            }
            HA_Groups.each {val -> 
                log ("Group Name is " + val, "KH")                   
                mqtt.subscribeTopic(atomicState.HA+"/group/$val/friendly_name")             
            }
            HA_Presence.each {val -> 
                log ("Presence Name is " + val, "KH")                   
                mqtt.subscribeTopic(atomicState.HA+"/person/$val/friendly_name")        
            }
            HA_InputBooleans.each {val -> 
                log ("InputBoolean Name is " + val, "KH")                   
                mqtt.subscribeTopic(atomicState.HA+"/input_boolean/$val/friendly_name")
            }
        
        
        
                                                                                                        // TODO Some are missing here ! 
        

    }

    if ((settings?.HAInDiscovery==true) && (settings?.HAInTopic!=null))
    {
        
        /*
            numEnabled=0
            if (HAIn_switch!=null) numEnabled = settings?.HAIn_switch.size()
		    if (HAIn_light!=null) numEnabled += settings?.HAIn_light.size()
		    if (HAIn_sensors!=null) numEnabled += settings?.HAIn_sensor.size()
		    if (HAIn_binary!=null) numEnabled += settings?.HAIn_binary.size()
		    if (HAIn_cover!=null) numEnabled += settings?.HAIn_cover.size()
            if (HAIn_climate!=null) numEnabled += settings?.HAIn_climate.size()
            if (HAIn_person!=null) numEnabled += settings?.HAIn_person.size()
            if (HAIn_automation!=null) numEnabled += settings?.HAIn_automation.size()
            if (HAIn_group!=null) numEnabled += settings?.HAIn_group.size()
            if (HAIn_lock!=null) numEnabled += settings?.HAIn_lock.size()

            if (numEnabled != atomicState.HAInNumEnabled) {
            log ("Need to run HAIn Discovery  $numHAInDevs ~ $atomicState.HAInNumEnabled", "WARN")
            atomicState.HAInNumEnabled=numEnabled
            HAInDiscovery()
         }
        */
            settings?.HAIn_switch.each {val ->  
                homieSubs("switch",val)
            }
            settings?.HAIn_light.each {val -> 
                homieSubs("light",val)
             }
            settings?.HAIn_sensor.each {val ->
                homieSubs("sensor",val)
            }
            settings?.HAIn_binary.each {val -> 
                homieSubs("binary_sensor",val)
             }
            settings?.HAIn_cover.each {val ->
                homieSubs("cover",val)
             }
            settings?.HAIn_climate.each {val -> 
                homieSubs("climate",val)
             }
            settings?.HAIn_person.each {val ->
                homieSubs("person",val)
            }
            settings?.HAIn_automation.each {val ->
                homieSubs("automation",val)
            }
            settings?.HAIn_group.each {val ->  
                homieSubs("group",val)
             }
            settings?.HAIn_lock.each {val ->
                homieSubs("lock",val)
            }
    
    }

    dynamicPage(name: "synchDiscoveries", title: "<h2><b>Synchronising enabled Discoveries</b></h2><b><b>  .. in background - you can click 'Next' and changes will appear in HE shortly</b> ", nextPage: "configuration") {}

}

def homieSubs(type,val) {
    val=normalize2(val)
        log ("homie sub to " + settings?.HAInTopic+"/$type/$val/config", "WARN")
    
                    mqtt.subscribeTopic(settings?.HAInTopic+"/$type/$val/config")  //two topic constructs
	                mqtt.subscribeTopic(settings?.HAInTopic+"/$type/+/$val/config") 
                    //mqtt.subscribeTopic(settings?.HAInTopic+"/$type/+/+/$val/config")
    
                    //mqtt.subscribeTopic(settings?.HAInTopic+"/$type/$val/state")  //two topic constructs
	               // mqtt.subscribeTopic(settings?.HAInTopic+"/$type/+/$val/state") 
                    //mqtt.subscribeTopic(settings?.HAInTopic+"/$type/+/+/$val/state")

}

def discovery() {  // can use atomicState vars in this section
    devVersion=true
    dynamicPage(name: "discovery", title: "<h2><b>MQTT Discovery Protocols into HE </b></h2>", nextPage: synchDiscoveries) {
    //dynamicPage(name: "discovery", title: "<h2><b>MQTT Discovery Protocols into HE </b></h2>", install: false, uninstall: false, nextPage: "configuration") {
	section ("(optional)"){
		//if (settings?.homieDiscovery && settings?.homieDevice!=null && settings?.homieRunEvery) homieEnabled='<font color="green">' else homieEnabled='<font color="darkred">'
		//if (settings?.HAStatestream && settings?.HAStatestreamTopic!=null && settings?.HARunEvery)  HAEnabled='<font color="green">' else HAEnabled='<font color="darkred">'
		if (settings?.homieDiscovery && settings?.homieDevice!=null) homieEnabled='<font color="green">' else homieEnabled='<font color="darkred">'
		if (settings?.HAStatestream && settings?.HAStatestreamTopic!=null)  HAEnabled='<font color="green">' else HAEnabled='<font color="darkred">'
        if (settings?.CBusDiscovery && settings?.CBusTopic!=null)  CBusEnabled='<font color="green">' else CBusEnabled='<font color="darkred">'
        if (settings?.HAInDiscovery && settings?.HAInTopic!=null)  HAInEnabled='<font color="green">' else HAInEnabled='<font color="darkred">'
        if (settings?.SonoffDiscovery)  SonoffEnabled='<font color="green">' else SonoffEnabled='<font color="darkred">'
        if (settings?.ShellyDiscovery)  ShellyEnabled='<font color="green">' else ShellyEnabled='<font color="darkred">'

	}
    
		numText=''
        numhomieDevs=0  // number of homie devices
		if (atomicState.onoffDevices != null) numhomieDevs+= atomicState.onoffDevices.size()  // these are all homie devices
		if (atomicState.dimDevices != null) numhomieDevs+= atomicState.dimDevices.size()
		if (atomicState.sensorDevices != null) numhomieDevs+= atomicState.sensorDevices.size()
        if (atomicState.lockDevices != null) numhomieDevs+= atomicState.lockDevices.size()  //Casey
        if (atomicState.buttonDevices != null) numhomieDevs+= atomicState.buttonDevices.size()
        if (atomicState.varDevices != null) numhomieDevs+= atomicState.varDevices.size()
        if (atomicState.homieUnknownDevices != null) numhomieDevs+= atomicState.homieUnknownDevices.size()
        
        numHADevs=0  // number of HA devices
		if (atomicState.HABinarySensorDevices != null) numHADevs+= atomicState.HABinarySensorDevices.size()  // these are all homie devices
		if (atomicState.HAClimateDevices != null) numHADevs+= atomicState.HAClimateDevices.size()
		if (atomicState.HACoverDevices != null) numHADevs+= atomicState.HACoverDevices.size()
        if (atomicState.HADeviceTrackerDevices != null) numHADevs+= atomicState.HADeviceTrackerDevices.size()  //Casey
        if (atomicState.HAGroupDevices != null) numHADevs+= atomicState.HAGroupDevices.size()
        if (atomicState.HAInputBooleanDevices != null) numHADevs+= atomicState.HAInputBooleanDevices.size()
        if (atomicState.HALightDevices != null) numHADevs+= atomicState.HALightDevices.size() 
        if (atomicState.HALockDevices != null) numHADevs+= atomicState.HALockDevices.size()  //Casey
        if (atomicState.HAPresenceDevices != null) numHADevs+= atomicState.HAPresenceDevices.size()
        if (atomicState.HASensorDevices != null) numHADevs+= atomicState.HASensorDevices.size()                
        if (atomicState.HASwitchDevices != null) numHADevs+= atomicState.HASwitchDevices.size()
        if (atomicState.HAUnknownDevices != null) numHADevs+= atomicState.HAUnknownDevices.size()
        // TODO add more ? .. test for null redundant
        numHAInDevs=0  // number of HAIn (discovery) devices
		if (atomicState.HAInBinarySensorDevices != null) numHAInDevs+= atomicState.HAInBinarySensorDevices.size()  // these are all homie devices
		if (atomicState.HAInClimateDevices != null) numHAInDevs+= atomicState.HAInClimateDevices.size()
		if (atomicState.HAInCoverDevices != null) numHAInDevs+= atomicState.HAInCoverDevices.size()
        //if (atomicState.HAInDeviceTrackerDevices != null) numHAInDevs+= atomicState.HAInDeviceTrackerDevices.size()  //Casey
        if (atomicState.HAInGroups != null) numHAInDevs+= atomicState.HAInGroups.size()
        //if (atomicState.HAInInputBooleanDevices != null) numHAInDevs+= atomicState.HAInInputBooleanDevices.size()
        if (atomicState.HAInLightDevices != null) numHAInDevs+= atomicState.HAInLightDevices.size() 
        if (atomicState.HAInLockDevices != null) numHAInDevs+= atomicState.HAInLockDevices.size()  //Casey
        if (atomicState.HAInAutomations != null) numHAInDevs+= atomicState.HAInAutomations.size()  //Casey
        if (atomicState.HAInPresenceDevices != null) numHAInDevs+= atomicState.HAInPresenceDevices.size()
        if (atomicState.HAInSensorDevices != null) numHAInDevs+= atomicState.HAInSensorDevices.size()                
        if (atomicState.HAInSwitchDevices != null) numHAInDevs+= atomicState.HAInSwitchDevices.size()
        //if (atomicState.HAInUnknownDevices != null) numInHADevs+= atomicState.HAInUnknownDevices.size()
        atomicState.numHAInDevs=numInHADevs
        numCBusLightDevs=0
        numCBusTextDevs=0
        if (atomicState.CBusLightDevices != null) numCBusLightDevs+= atomicState.CBusLightDevices.size()
        if (atomicState.CBusTextDevices != null) numCBusTextDevs+= atomicState.CBusTextDevices.size()
		def numEnabled=0
		if (Homie_onoff!=null) numEnabled += settings?.Homie_onoff.size()
		if (Homie_dim!=null) numEnabled += settings?.Homie_dim.size()
		if (Homie_sensors!=null) numEnabled += settings?.Homie_sensor.size()
        if (Homie_button!=null) numEnabled += settings?.Homie_button.size()
        if (Homie_variable!=null) numEnabled += settings?.Homie_variable.size()
        if (Homie_unknowns!=null) numEnabled += settings?.Homie_unknowns.size()
		if (settings?.homieDiscovery){
            if (atomicState.started) {
                numText = "${numEnabled} of ${numhomieDevs} discovered devices enabled"
                atomicState.homieNumEnabled=numEnabled
            }
			else numText="checking"
		}
		else {
			numText="disabled"
		}

        
    section (homieEnabled+"<b>homie</b>    <br>     [${numText}]</font>", hideable: true, hidden: true, submitOnChange: true){
        if (settings?.Homie_onoff != null) ho = settings?.Homie_onoff.size() else ho=0  // Elvis isnt in the house TODO
        if (settings?.Homie_dim != null) hd = settings?.Homie_dim.size() else hd=0
		if (settings?.Homie_sensor != null) hs = settings?.Homie_sensor.size() else hs=0
		if (settings?.Homie_button != null) hb = settings?.Homie_button.size() else hb=0
		if (settings?.Homie_variable != null) hv = settings?.Homie_variable.size() else hv=0
        if (settings?.Homie_lock != null) hl = settings?.Homie_lock.size() else hl=0
        if (settings?.Homie_unknowns != null) hu = settings?.Homie_unknowns.size() else hu=0
    	input "homieDiscovery", "bool", title: "<b>homie 3 protocol<b>", required: true, defaultValue: false, submitOnChange: false
        input "homieRunEvery", "bool", title: "<b>Run every time app starts</b>", required: true, defaultValue: false, submitOnChange: false
        input "RunhomieDiscovery", "button", title: "Run homie Discovery now"
		input name: "homieDevice", type: "text", title: "<b>homie device topic name</b>", description: "... to import devices from", required: false, displayDuringSetup: false, submitOnChage: true
		input "ClearhomieDiscovery", "button", title: "Clear discovered devices in dropdown lists" //, these can be recreated but the enabled device status is lost"
        input "DeletehomieDiscoveryDevices", "button", title: "Delete enabled devices from HE" //, these can be recreated as long as the enabled status is present
        input "Homie_onoff", "enum", multiple: true, title: "<b>Discovered ${atomicState.onoffDevices.size()} homie switches &nbsp &nbsp &nbsp [^${ho}]</b>", options: atomicState.onoffDevices.sort()
		input "Homie_dim", "enum", multiple: true, title: "<b>Discovered ${atomicState.dimDevices.size()} homie dimmers &nbsp &nbsp &nbsp [^${hd}]</b>", options: atomicState.dimDevices.sort()
		input "Homie_sensor", "enum", multiple: true, title: "<b>Discovered ${atomicState.sensorDevices.size()} homie sensors &nbsp &nbsp &nbsp [^${hs}]</b>", options: atomicState.sensorDevices.sort()
		input "Homie_button", "enum", multiple: true, title: "<b>Discovered ${atomicState.buttonDevices.size()} homie buttons &nbsp &nbsp &nbsp [^${hb}]</b>", options: atomicState.buttonDevices.sort()
        input "Homie_variable", "enum", multiple: true, title: "<b>Discovered ${atomicState.varDevices.size()} homie variables &nbsp &nbsp &nbsp [^${hv}]</b>", options: atomicState.varDevices.sort()
        input "Homie_lock", "enum", multiple: true, title: "<b>Discovered ${atomicState.lockDevices.size()} homie locks &nbsp &nbsp &nbsp [^${hl}]</b>", options: atomicState.lockDevices.sort()
        input "Homie_unknowns", "enum", multiple: true, title: "<b>Discovered ${atomicState.homieUnknownDevices.size()} homie devices that are not supported yet &nbsp &nbsp &nbsp [^${hu}]</b>", options: atomicState.homieUnknownDevices.sort() 
        
        
    }

		
	section {}
		numText=''
		numEnabled=0
		// TODO - below line can still error initially ....alpha
		if (HA_Switches!=null) numEnabled = settings?.HA_Switches.size()
		if (HA_Lights!=null) numEnabled += settings?.HA_Lights.size()
		if (HA_Sensors!=null) numEnabled += settings?.HA_Sensors.size()
		if (HA_BinarySensors!=null) numEnabled += settings?.HA_BinarySensors.size()
		if (HA_Groups!=null) numEnabled += settings?.HA_Groups.size()
        if (HA_Presence!=null) numEnabled += settings?.HA_Presence.size()
		if (HA_InputBooleans!=null) numEnabled += settings?.HA_InputBooleans.size()
		if (numEnabled>=0) numText = "${numEnabled} of ${numHADevs} enabled"
		if (settings?.HAStatestream){
            if (atomicState.started) {
                numText = "${numEnabled} of ${numHADevs} discovered devices enabled"
                atomicState.HANumEnabled=numEnabled
            }
			else numText="checking"
		}
		else {
			numText="disabled"
		}
		section (HAEnabled+"<b>Home Assistant statestream</b><br>     [${numText}]</font>", hideable: true, hidden: true,submitOnChange: true) {
            if (settings?.HA_Switches != null) HAsw = settings?.HA_Switches.size() else HAsw=0  // Elvis isnt in the house TODO
			if (settings?.HA_Lights != null) HAli = settings?.HA_Lights.size() else HAli=0
			if (settings?.HA_Sensors != null) HAse = settings?.HA_Sensors.size() else HAse=0
			if (settings?.HA_BinarySensors != null) HAbs = settings?.HA_BinarySensors.size() else HAbs=0
			if (settings?.HA_Groups != null) HAg = settings?.HA_Groups.size() else HAg=0
            if (settings?.HA_Presence != null) HAp = settings?.HA_Presence.size() else HAp=0
			if (settings?.HA_InputBooleans != null) HAib = settings?.HA_InputBooleans.size() else HAib=0
            if (settings?.HA_Covers != null) HAco = settings?.HA_Covers.size() else HAco=0
            if (settings?.HA_Locks != null) HAlo = settings?.HA_Locks.size() else HAlo=0
            if (settings?.HA_DeviceTrackers != null) HAd = settings?.HA_DeviceTrackers.size() else HAd=0
            if (settings?.HA_Climates != null) HAcl = settings?.HA_Climates.size() else HAcl=0
		    input "HAStatestream", "bool", title: "Home Assistant statestream", required: true, defaultValue: false, submitOnChange: true
            input "HARunEvery", "bool", title: "<b>Run every time app starts</b>", required: true, defaultValue: true, submitOnChange: false
            input "RunHADiscovery", "button", title: "Run HA Discovery now"
	    	input name: "HAStatestreamTopic", type: "text", title: "Home Assistant Statestream topic", description: "", required: false, displayDuringSetup: false
		    input "ClearHAstatestreamDiscovery", "button", title: "Clear discovered devices in dropdown lists" //, these can be recreated but the enabled device status is lost"
            input "DeleteHAstatestreamDiscoveryDevices", "button", title: "Delete enabled devices from HE" //, these can be recreated as long as the enabled status is present
            input "HA_Switches", "enum", multiple: true, title: "Discovered  ${atomicState.HASwitchDevices.size()} Home Assistant switches &nbsp &nbsp &nbsp [^${HAsw}]", options: atomicState.HASwitchDevices.sort()
		    input "HA_Lights", "enum", multiple: true, title: "Discovered ${atomicState.HALightDevices.size()} Home Assistant lights &nbsp &nbsp &nbsp [^${HAli}]" , options: atomicState.HALightDevices.sort()
		    input "HA_Sensors", "enum", multiple: true, title: "Discovered ${atomicState.HASensorDevices.size()} Home Assistant sensors &nbsp &nbsp &nbsp [^${HAse}]" , options: atomicState.HASensorDevices.sort()
		    input "HA_BinarySensors", "enum", multiple: true, title: "Discovered ${atomicState.HABinarySensorDevices.size()} Home Assistant binary sensors &nbsp &nbsp &nbsp [^${HAbs}]" , options:  atomicState.HABinarySensorDevices.sort()
		    input "HA_Groups", "enum", multiple: true, title: "Discovered ${atomicState.HAGroupDevices.size()} Home Assistant groups &nbsp &nbsp &nbsp [^${HAg}]" , options: atomicState.HAGroupDevices.sort()
            input "HA_Presence", "enum", multiple: true, title: "Discovered ${atomicState.HAPresenceDevices.size()} Home Assistant persons &nbsp &nbsp &nbsp [^${HAp}]" , options: atomicState.HAPresenceDevices.sort()
		    input "HA_InputBooleans", "enum", multiple: true, title: "Discovered ${atomicState.HAInputBooleanDevices.size()} Home Assistant input booleans &nbsp &nbsp &nbsp [^${HAib}]" , options:  atomicState.HAInputBooleanDevices.sort()
		    input "HA_Covers", "enum", multiple: true, title: "Discovered ${atomicState.HACoverDevices.size()} Home Assistant Covers &nbsp &nbsp &nbsp [^${HAco}]" , options:  atomicState.HACoverDevices.sort()
		    input "HA_Locks", "enum", multiple: true, title: "Discovered ${atomicState.HALockDevices.size()} Home Assistant Locks &nbsp &nbsp &nbsp [^${HAlo}]" , options:  atomicState.HALockDevices.sort()
		    input "HA_DeviceTrackers", "enum", multiple: true, title: "Discovered ${atomicState.HADeviceTrackerDevices.size()} Home Assistant Device Trackers &nbsp &nbsp &nbsp [^${HAd}]" , options:  atomicState.HADeviceTrackerDevices.sort()
            input "HA_Climates", "enum", multiple: true, title: "Discovered ${atomicState.HAClimateDevices.size()} Home Assistant Climate Devices &nbsp &nbsp &nbsp [^${HAcl}]" , options:  atomicState.HAClimateDevices.sort()
            input "HA_Unknowns", "enum", multiple: false, title: "Discovered ${atomicState.HAClimateDevices.size()} Home Assistant Devices that are not supported yet &nbsp &nbsp &nbsp [^${HAcl}]" , options:  atomicState.HAUnknownDevices.sort()   
        }
        


 /*       
   if (devVersion==true) {
        section ("<b>zigbee2mqtt (UNFINISHED likely to be deprecated)</b>    ", hideable: true, hidden: true){

    	input "zigbee2mqttDiscovery", "bool", title: "<b>zigbee2mqtt<b>", required: true, defaultValue: false, submitOnChange: false
        input "zigbee2mqttRunEvery", "bool", title: "<b>Run every time app starts</b>", required: true, defaultValue: false, submitOnChange: false
        input "Runzigbee2mqttDiscovery", "button", title: "Run zigbee2mqtt Discovery now"
		input name: "zigbee2mqttTopic", type: "text", title: "<b>zigbee2mqtt topic name</b>", description: "... to import devices from", required: false, displayDuringSetup: false
		input "zigbee2mqtt_onoff", "enum", multiple: true, title: "<b>Discovered ${atomicState.onoffDevices.size()} zigbee2mqtt switches &nbsp &nbsp &nbsp [^${ho}]</b>", options: atomicState.onoffDevices.sort()
		input "zigbee2mqtt_light", "enum", multiple: true, title: "<b>Discovered ${atomicState.zigbee2mqttLightDevices.size()} zigbee2mqtt lights &nbsp &nbsp &nbsp [^${hd}]</b>", options: atomicState.zigbee2mqttLightDevices.sort()
		input "zigbee2mqtt_sensor", "enum", multiple: true, title: "<b>Discovered ${atomicState.sensorDevices.size()} zigbee2mqtt sensors &nbsp &nbsp &nbsp [^${hs}]</b>", options: atomicState.sensorDevices.sort()
		input "zigbee2mqtt_button", "enum", multiple: true, title: "<b>Discovered ${atomicState.buttonDevices.size()} zigbee2mqtt buttons &nbsp &nbsp &nbsp [^${hb}]</b>", options: atomicState.buttonDevices.sort()
        input "zigbee2mqtt_variable", "enum", multiple: true, title: "<b>Discovered ${atomicState.varDevices.size()} zigbee2mqtt variables &nbsp &nbsp &nbsp [^${hv}]</b>", options: atomicState.varDevices.sort()
        input "zigbee2mqtt_lock", "enum", multiple: true, title: "<b>Discovered ${atomicState.lockDevices.size()} zigbee2mqtt locks &nbsp &nbsp &nbsp [^${hl}]</b>", options: atomicState.lockDevices.sort()
        input "zigbee2mqtt_unknowns", "enum", multiple: true, title: "<b>Discovered ${atomicState.homieUnknownDevices.size()} zigbee2mqtt devices that are not supported yet &nbsp &nbsp &nbsp [^${hu}]</b>", options: atomicState.homieUnknownDevices.sort()   
        }
   }  
*/
 if (atomicState.myHub) {      
    if (devVersion==true) {
        section{}
        numEnabled=0
        if (settings.CBus_light!=null) numEnabled += settings?.CBus_light.size()
        if (settings.CBus_text!=null) numEnabled += settings?.CBus_text.size()
        atomicState.CBNumEnabled=numEnabled
		if (settings?.CBusDiscovery){
            if (atomicState.started) {
                numText = "${numEnabled} of ${numCBusLightDevs+numCBusTextDevs} discovered devices enabled"
                atomicState.CBusNumEnabled=numEnabled
            }
			else numText="checking"
		}
		else {
			numText="disabled"
		}
        if (settings?.CBus_light != null) CBl = settings?.CBus_light.size() else CBl=0
        if (settings?.CBus_text != null) CBt = settings?.CBus_text.size() else CBt=0
        section (CBusEnabled+"<b>C-Bus</b><br>     [${numText}]</font>", hideable: true, hidden: true){

    	input "CBusDiscovery", "bool", title: "<b>C-Bus<b>", required: true, defaultValue: false, submitOnChange: false
        input "CBusRunEvery", "bool", title: "<b>Run every time app starts</b>", required: true, defaultValue: false, submitOnChange: false
        input "RunCBusDiscovery", "button", title: "Run C-Bus Discovery now"
		input name: "CBusTopic", type: "text", title: "<b>C-Bus topic name</b>", description: "", required: false, displayDuringSetup: false
		input "ClearCBusDiscovery", "button", title: "Clear discovered devices in dropdown lists" //, these can be recreated but the enabled device status is lost"
        input "DeleteCBusDiscoveryDevices", "button", title: "Delete enabled devices from HE" //, these can be recreated as long as the enabled status is present

        input "CBus_light", "enum", multiple: true, title: "<b>Discovered ${atomicState.CBusLightDevices.size()}  C-Bus lights &nbsp &nbsp &nbsp [^$CBl]</b>", options: atomicState.CBusLightDevices.sort()
        input "CBus_text", "enum", multiple: true, title: "<b>Discovered ${atomicState.CBusTextDevices.size()}  C-Bus text &nbsp &nbsp &nbsp [^$CBt]</b>", options: atomicState.CBusTextDevices.sort()
		//input "CBus_sensor", "enum", multiple: true, title: "<b>Discovered ${atomicState.sensorDevices.size()} zigbee2mqtt sensors &nbsp &nbsp &nbsp [^${hs}]</b>", options: atomicState.sensorDevices.sort()
        }
    }
 }

/*        
    //section (zwave2mEnabled+"<b>zwavejs2mqtt</b>    [${numText}]</font>", hideable: true, hidden: true){
   if (devVersion==true) {
        section ("<b>zwavejs2mqtt  (UNFINISHED likely to be deprecated)</b></font>", hideable: true, hidden: true){

    	input "zwave2mqttDiscovery", "bool", title: "<b>zwave2mqtt<b>", required: true, defaultValue: false, submitOnChange: false
        input "zwave2mqttRunEvery", "bool", title: "<b>Run every time app starts</b>", required: true, defaultValue: false, submitOnChange: false
        input "Runzwave2mqttDiscovery", "button", title: "Run zwave2mqtt Discovery now"
		input name: "zwave2mqttTopic", type: "text", title: "<b>zwave2mqtt topic name</b>", description: "... to import devices from", required: false, displayDuringSetup: false
		input "zwave2mqtt_onoff", "enum", multiple: true, title: "<b>Discovered ${atomicState.onoffDevices.size()} zwave2mqtt switches &nbsp &nbsp &nbsp [^${ho}]</b>", options: atomicState.onoffDevices.sort()
		input "zwave2mqtt_dim", "enum", multiple: true, title: "<b>Discovered ${atomicState.dimDevices.size()} zwave2mqtt dimmers &nbsp &nbsp &nbsp [^${hd}]</b>", options: atomicState.dimDevices.sort()
		input "zwave2mqtt_sensor", "enum", multiple: true, title: "<b>Discovered ${atomicState.sensorDevices.size()} zwave2mqtt sensors &nbsp &nbsp &nbsp [^${hs}]</b>", options: atomicState.sensorDevices.sort()
		input "zwave2mqtt_button", "enum", multiple: true, title: "<b>Discovered ${atomicState.buttonDevices.size()} zwave2mqtt buttons &nbsp &nbsp &nbsp [^${hb}]</b>", options: atomicState.buttonDevices.sort()
        input "zwave2mqtt_variable", "enum", multiple: true, title: "<b>Discovered ${atomicState.varDevices.size()} zwave2mqtt variables &nbsp &nbsp &nbsp [^${hv}]</b>", options: atomicState.varDevices.sort()
        input "zwave2mqtt_lock", "enum", multiple: true, title: "<b>Discovered ${atomicState.lockDevices.size()} zwave2mqtt locks &nbsp &nbsp &nbsp [^${hl}]</b>", options: atomicState.lockDevices.sort()
        input "zwave2mqtt_unknowns", "enum", multiple: true, title: "<b>Discovered ${atomicState.homieUnknownDevices.size()} zwave2mqtt devices that are not supported yet &nbsp &nbsp &nbsp [^${hu}]</b>", options: atomicState.homieUnknownDevices.sort()   
        } 
   }
 */       
        section {}
        numText=''
		numEnabled=0
        if (settings?.HAInDiscovery){
            if (HAIn_switch!=null) numEnabled = settings?.HAIn_switch.size()
		    if (HAIn_light!=null) numEnabled += settings?.HAIn_light.size()
		    if (HAIn_sensors!=null) numEnabled += settings?.HAIn_sensor.size()
		    if (HAIn_binary!=null) numEnabled += settings?.HAIn_binary.size()
		    if (HAIn_cover!=null) numEnabled += settings?.HAIn_cover.size()
            if (HAIn_climate!=null) numEnabled += settings?.HAIn_climate.size()
            if (HAIn_person!=null) numEnabled += settings?.HAIn_person.size()
            if (HAIn_automation!=null) numEnabled += settings?.HAIn_automation.size()
            if (HAIn_group!=null) numEnabled += settings?.HAIn_group.size()
            if (HAIn_lock!=null) numEnabled += settings?.HAIn_lock.size()
		    if (numEnabled>=0) numText = "${numEnabled} of ${numHAInDevs} enabled"   
            if (atomicState.started) {
                numText = "${numEnabled} of ${numHAInDevs} discovered devices enabled"
                atomicState.HAInNumEnabled=numEnabled
            }
			else numText="checking"
		}
		else {
			numText="disabled"
		}
        section (HAInEnabled+"<b> Home Assistant MQTT Discovery</b><br>     [${numText}]</font>", hideable: true, hidden: true){
        if (settings?.HAIn_switch != null) HAInsw = settings?.HAIn_switch.size() else HAInsw=0  // Elvis isnt in the house TODO
        if (settings?.HAIn_light != null) HAInli = settings?.HAIn_light.size() else HAInli=0
        if (settings?.HAIn_binary != null) HAInbi = settings?.HAIn_binary.size() else HAInbi=0
        if (settings?.HAIn_sensor != null) HAInse = settings?.HAIn_sensor.size() else HAInse=0
        if (settings?.HAIn_climate != null) HAIncl = settings?.HAIn_climate.size() else HAIncl=0
        if (settings?.HAIn_cover != null) HAInco = settings?.HAIn_cover.size() else HAInco=0
        if (settings?.HAIn_lock != null) HAInlo = settings?.HAIn_lock.size() else HAInlo=0
        if (settings?.HAIn_automation != null) HAInau = settings?.HAIn_automation.size() else HAInau=0 
        if (settings?.HAIn_person != null) HAInpe = settings?.HAIn_person.size() else HAInpe=0 
        if (settings?.HAIn_group != null) HAIngr = settings?.HAIn_group.size() else HAIngr=0 
            
        // alarm_control_panel   camera  device_automation
            
        input "HAInDiscovery", "bool", title: "<b>HA Incoming Discovery<b>", required: true, defaultValue: false, submitOnChange: true
        input "HAInRunEvery", "bool", title: "<b>Run every time app starts</b>", required: true, defaultValue: false, submitOnChange: true
        input "incNonConfig","bool", title: "<b>Include sensors missing a config topic</b>", required: true, defaultValue: false, submitOnChange: true
        input "RunHAInDiscovery", "button", title: "Run HA MQTT Discovery now"
		input name: "HAInTopic", type: "text", title: "<b>Home Assistant MQTT Discovery incoming topic name</b>", description: "... to import devices from", required: false, displayDuringSetup: false
		input "ClearHAInDiscovery", "button", title: "Clear discovered devices in dropdown lists" //, these can be recreated but the enabled device status is lost"
        input "DeleteDiscoveryDevices", "button", title: "Delete enabled devices from HE" //, these can be recreated as long as the enabled status is present
        input "HAIn_switch", "enum", multiple: true, title: "<b>Discovered ${atomicState.HAInSwitchDevices.size()} HA switches &nbsp &nbsp &nbsp [^${HAInsw}]</b>", options: atomicState.HAInSwitchDevices.sort()
        input "HAIn_light", "enum", multiple: true, title: "<b>Discovered ${atomicState.HAInLightDevices.size()} HA lights &nbsp &nbsp &nbsp [^${HAInli}]</b>", options: atomicState.HAInLightDevices.sort()
        input "HAIn_binary", "enum", multiple: true, title: "<b>Discovered ${atomicState.HAInBinarySensorDevices.size()} HA binary sensors &nbsp &nbsp &nbsp [^${HAInbi}]</b>", options: atomicState.HAInBinarySensorDevices.sort()
        input "HAIn_sensor", "enum", multiple: true, title: "<b>Discovered ${atomicState.HAInSensorDevices.size()} HA sensors &nbsp &nbsp &nbsp [^${HAInse}]</b>", options: atomicState.HAInSensorDevices.sort()
        input "HAIn_climate", "enum", multiple: true, title: "<b>Discovered ${atomicState.HAInClimateDevices.size()} HA climate devices &nbsp &nbsp &nbsp [^${HAIncl}]</b>", options: atomicState.HAInClimateDevices.sort()
        input "HAIn_cover", "enum", multiple: true, title: "<b>Discovered ${atomicState.HAInCoverDevices.size()} HA covers &nbsp &nbsp &nbsp [^${HAInco}]</b>", options: atomicState.HAInCoverDevices.sort()
        input "HAIn_lock", "enum", multiple: true, title: "<b>Discovered ${atomicState.HAInLockDevices.size()} HA locks &nbsp &nbsp &nbsp [^${HAInlo}]</b>", options: atomicState.HAInLockDevices.sort()
        input "HAIn_automation", "enum", multiple: true, title: "<b>Discovered ${atomicState.HAInAutomations.size()} HA automations &nbsp &nbsp &nbsp [^${HAInau}]</b>", options: atomicState.HAInAutomations.sort()
        input "HAIn_person", "enum", multiple: true, title: "<b>Discovered ${atomicState.HAInPersonDevices.size()} HA persons &nbsp &nbsp &nbsp [^${HAInpe}]</b>", options: atomicState.HAInPersonDevices.sort()
        input "HAIn_group", "enum", multiple: true, title: "<b>Discovered ${atomicState.HAInGroups.size()} HA groups &nbsp &nbsp &nbsp [^${HAIngr}]</b>", options: atomicState.HAInGroups.sort()
        }
   
         
        section {
			paragraph "<hr>"
			input "Go Back", "button", title: "Go Back", width: 3
            input "Update", "button", title: "Update", width: 3
        }


		}
    //log ("End Discovery Dynamic Page","KH")
}



def appButtonHandler(btn) {
    mqtt = getChildDevice("MQTT: Child device driver")
    if (btn=="Go Back") {
        //return configuration()
        log ("Go Back","KH")
    }
    if (btn=="Update") {
        log ("Apply updates","KH")
    }
    if (btn=="newVDev") {
            createVirtual()   
        }
    else if (btn=="topics") {
        atomicState.devTopics=[]
        mqtt.subscribeWildcardTopic (atomicState.dTopic)
    }
    else if (btn=="commit") {
        log ("updating the topics","TRACE")
             }
    else if (btn=="resetMappings") {
        atomicState.Mappings=[:]
    }
    else if (btn=="oldVDev") {
        deleteChildDevice(atomicState.device.deviceNetworkId)
        log ("Deleted virtual device $vDev","WARN")
    }
    else if (btn=="editVDev") {
        atomicState.edit=true
    }
    else if (btn=="RunHADiscovery") {
        atomicState.HA=settings?.HAStatestreamTopic
        if ((settings?.HAStatestream == true)  && (settings?.HAStatestreamTopic != '') && (settings?.HAStatestreamTopic != null)) HADiscovery()
    }
    else if (btn=="RunhomieDiscovery") {
        atomicState.homie=settings?.homieDevice
        if ((settings?.homieDiscovery == true) &&(settings?.homieDevice != '') && (settings?.homieDevice != null))  homieDiscovery()
    }
    else if (btn=="Runzigbee2mqttDiscovery") {
        zigbee2mqttDiscovery()
    }
    else if (btn=="RunCBusDiscovery") {
        //atomicState.cbus=CBusTopic
        if (settings?.CBusTopic!=null) mqtt.setCBusTopic(settings?.CBusTopic)
        if ((settings?.CBusDiscovery) && (settings?.CBusTopic!='') && (settings?.CBusTopic!=null))  CBusDiscovery()
    }
    else if (btn=="Runzwave2mqttDiscovery") {
        zwave2mqttDiscovery()
    }
    else if (btn=="RunHAInDiscovery") {
        if ("$settings?.HAinTopic" != null) {
            mqtt.setHAInTopic(settings?.HAInTopic)
        }
        if ((settings?.HAInDiscovery) && (settings?.HAinTopic!='') && (settings?.HAInTopic!=null))  HAInDiscovery()
    }
    else if (btn=="ClearHAInDiscovery") {
        HAInClear()
    }
    else if (btn=="ClearHAstatestreamDiscovery") {
        HAstatestreamClear()
    }
    else if (btn=="ClearhomieDiscovery") {
        homieClear()
    }
    else if (btn=="ClearCBusDiscovery") {
        atomicState.CBusLightDevices=[]
        atomicState.CBusTextDevices=[]
    }
    else if (btn=="DeleteHAInDiscoveryDevices") {
        HADeleteDev("MQTT:HADisc_")
    }
    else if (btn=="DeleteCBusDiscoveryDevices") {
        HADeleteDev("MQTT:CBus_")
    }
    else if (btn=="DeleteHAstatestreamDiscoveryDevices") {
        HADeleteDev("MQTT:HA_[")
    }
    else if (btn=="DeletehomieDiscoveryDevices") {
        HADeleteDev("MQTT:homie_")
    }
}

def checkAtomics () {
     
	atomicState.onoffDevices = (atomicState.onoffDevices != null)?atomicState.onoffDevices:[]
	atomicState.dimDevices = (atomicState.dimDevices != null)?atomicState.dimDevices:[]
	atomicState.sensorDevices = (atomicState.sensorDevices != null)?atomicState.sensorDevices:[]
    atomicState.buttonDevices = (atomicState.buttonDevices != null)?atomicState.buttonDevices:[]
    atomicState.varDevices = (atomicState.varDevices != null)?atomicState.varDevices:[] 
    atomicState.lockDevices = (atomicState.lockDevices != null)?atomicState.lockDevices:[] //Casey
    atomicState.homieUnknownDevices = (atomicState.homieUnknownDevices != null)?atomicState.homieUnknownDevices:[]
    atomicState.ShellyDevices = (atomicState.ShellyDevices != null)?atomicState.ShellyDevices:[]   
    atomicState.SonoffDevices = (atomicState.SonoffDevices != null)?atomicState.SonoffDevices:[]
    atomicState.HAPresenceDevices = (atomicState.HAPresenceDevices != null)?atomicState.HAPresenceDevices:[]
	atomicState.HASwitchDevices = (atomicState.HASwitchDevices != null)?atomicState.HASwitchDevices:[]
	atomicState.HALightDevices = (atomicState.HALightDevices != null)?atomicState.HALightDevices:[]
	atomicState.HASensorDevices = (atomicState.HASensorDevices != null)?atomicState.HASensorDevices:[]
	atomicState.HABinarySensorDevices = (atomicState.HABinarySensorDevices != null)?atomicState.HABinarySensorDevices:[]
	atomicState.HAGroupDevices = (atomicState.HAGroupDevices != null)?atomicState.HAGroupDevices:[]
	atomicState.HAInputBooleanDevices = (atomicState.HAInputBooleanDevices != null)?atomicState.HAInputBooleanDevices:[]
    atomicState.HACoverDevices = (atomicState.HACoverDevices != null)?atomicState.HACoverDevices:[]
    atomicState.HALockDevices =  (atomicState.HALockDevices != null)?atomicState.HALockDevices:[]
    atomicState.HADeviceTrackerDevices = (atomicState.HADeviceTrackerDevices != null)?atomicState.HADeviceTrackerDevices:[]
    atomicState.HAClimateDevices =  (atomicState.HAClimateDevices != null)?atomicState.HAClimateDevices:[]
    atomicState.HAUnknownDevices =  (atomicState.HAUnknownDevices != null)?atomicState.HAUnknownDevices:[]
    atomicState.homieUnknownDevices =  (atomicState.homieUnknownDevices != null)?atomicState.homieUnknownDevices:[]       
    atomicState.MQTTvirtuals = (atomicState.MQTTvirtuals != null)?atomicState.MQTTvirtuals:[]
    atomicState.HAInSwitchDevices = (atomicState.HAInSwitchDevices != null)?atomicState.HAInSwitchDevices:[]
	atomicState.HAInLightDevices = (atomicState.HAInLightDevices != null)?atomicState.HAInLightDevices:[]
	atomicState.HAInSensorDevices = (atomicState.HAInSensorDevices != null)?atomicState.HAInSensorDevices:[]
	atomicState.HAInBinarySensorDevices = (atomicState.HAInBinarySensorDevices != null)?atomicState.HAInBinarySensorDevices:[]
    atomicState.HAInClimateDevices = (atomicState.HAInClimateDevices != null)?atomicState.HAInClimateDevices:[]
    atomicState.HAInCoverDevices = (atomicState.HAInCoverDevices != null)?atomicState.HAInCoverDevices:[]
    atomicState.HAInLockDevices = (atomicState.HAInLockDevices != null)?atomicState.HAInLockDevices:[]
    atomicState.HAInAutomations = (atomicState.HAInAutomations != null)?atomicState.HAInAutomations:[]
    atomicState.HAInPersonDevices  = (atomicState.HAInPersonDevices != null)?atomicState.HAInPersonDevices:[]
    atomicState.HAInGroups = (atomicState.HAInGroups != null)?atomicState.HAInGroups:[]       
                
    atomicState.zigbee2mqttLightDevices=(atomicState.zigbee2mqttLightDevices != null)?atomicState.zigbee2mqttLightDevices:[]
    atomicState.CBusLightDevices=(atomicState.CBusLightDevices != null)?atomicState.CBusLightDevices:[] 
    atomicState.CBusTextDevices=(atomicState.CBusTextDevices != null)?atomicState.CBusTextDevices:[]
        
}

def HAInClear(){
    log ("Asked to forget Home Assistant Discovery dropdown lists","KH")
    atomicState.HAInSwitchDevices =[]
    atomicState.HAInLightDevices =[]
    atomicState.HAInBinarySensorDevices =[]
    atomicState.HAInSensorDevices =[]
    atomicState.HAInClimateDevices =[]
    atomicState.HAInCoverDevices =[]
    atomicState.HAInLockDevices =[]
    atomicState.HAInAutomations=[]
    atomicState.HAInGroups=[]
    atomicState.HAInPersonDevices=[]
}
def HAstatestreamClear(){
    log ("Asked to forget Home Assistant statestream dropdown lists","KH")
    atomicState.HASwitchDevices = []
    atomicState.HALightDevices = []
    atomicState.HASensorDevices = []
    atomicState.HABinarySensorDevices = []
    atomicState.HAGroupDevices = []
    atomicState.HAPresenceDevices = []
    atomicState.HAInputBooleanDevices = []
    atomicState.HACoverDevices = []
    atomicState.HALockDevices = []
    atomicState.HADeviceTrackerDevices = []
    atomicState.HAClimateDevices = []
    atomicState.HAUnknownDevices = []
}
def homieClear(){
    log ("Asked to forget homie Discovered dropdown lists","KH")
    atomicState.onoffDevices = []
    atomicState.dimDevices = []
    atomicState.sensorDevices = []
    atomicState.buttonDevices = []
    atomicState.varDevices = []
    atomicState.lockDevices = []
    atomicState.homieUnknownDevices = []
}

def HADeleteDev(match){
    log ("Request to delete discovery created devices with DNI:$match","WARN")
    count=0
	getChildDevices().each  {
    
       // mqttval= it.getDataValue("mqtt")
      try{
        origin=it.getDataValue("origin")
            if (origin!="user")  {
                    if (it.deviceNetworkId.startsWith(match)){
                    count++
                    log ("Deleted discovered device $it.displayName","INFO")
                    deleteChildDevice(it.deviceNetworkId)
                }
            }
            else log ("Saved this user created device $it.displayName","KH")
      }
       catch (e) {
            log (" Delete discovered child devices failed + $e","ERROR")
            return
            }
    }

     log (" Deleted [$count] child devices ","WARN")
}
    

//child
def createMQTTclient() {   //TODO IP username password
    if (atomicState.FirstRun==true) {
        log ("Skipped Client Creation as new run","KH")
        return
    }
    else log ("Creating a new client","KH")
    namespace='ukusa'
    log ("FYI your MQTT child devices are ${getChildDevices()} ","INFO")
    childDev=getChildDevice("MQTT: Child device driver")  
    if (childDev == null){ //This is a carryover of the client app not being 'selected' anymore in an input dropdown.
        
        log ("Creating MQTT client child driver" , "INFO")
        try {
            addChildDevice(namespace, "MQTT Client", "MQTT: Child device driver", null,[completedSetup: true,name: "MQTT: Child device driver", logging: false])
            log ("MQTT child client created","INFO")
        }
        catch (e) {
            log ("Problem creating child device " + e, "TRACE")
             } 
        
    	//childDev=getChildDevice("MQTT: Child device driver")  
    	//if (childDev == null) log ("MQTT client child was never created" , "ERROR")
    }
    else log ("MQTT child client already exists","TRACE")
}
//child
def createVirtual () {
    if ((atomicState.newDevType == "MQTT Text")|(atomicState.newDevType == "Remote Thermostat")) namespace = 'ukusa' else namespace = 'hubitat'
    addChildDevice(namespace, "$atomicState.newDevType", "MQTT:virtual_${atomicState.newDevName}", null,[completedSetup: true,name: "${atomicState.newDevName}", logging: false])
	childDev=getChildDevice("MQTT:virtual_${atomicState.newDevName}")  //hmm seems childDevice is not a device object 
	if (childDev == null) log ("Child was never created" + prefix+name , "ERROR")
    else log ("Created Child $atomicState.newDevType with name $atomicState.newDevName","INFO")
    childDev.updateDataValue("mqtt", "manual")
    childDev.updateDataValue("origin", "user")
    if (childDev.typeName.contains("Sensor")||childDev.typeName.contains("Presence")) sensor=true else sensor=false
        
                    childDev.capabilities.each { cap ->
                    log ("Found $cap in childDev $childDev.displayName","INFO")
                    cap.attributes.each { attr ->
                    log ("Found attribute $attr in $childDev.displayName [$cap]", "INFO")

                        att="$attr"
                        data=att+"_Topic"
                        if ((childDev.getDataValue(data))&&(childDev.getDataValue(data)!=" ")){
                            log ("$childDev.displayName data $data already exists","DEBUG")
                            if (att=='level') { 
                                if (!childDev.getDataValue("max_Level")) childDev.updateDataValue("max_Level", "100")
                            } 
                        }
                        else {
                            childDev.updateDataValue(data, " ")  // Have to add a space here so that data displays in my editor
                            log ("Adding data $data to $childDev.displayName","INFO")
                            if (att=='level') childDev.updateDataValue("max_Level", "100")
                        }
                        
                        // block _Cmd data vals for some sensor attributes
                        if (att=="battery") sensor=true
                        if ((childDev.typeName=="MQTT Text")&&(att=="networkStatus")) sensor=true
                            

                        if (!sensor) {
                            data=att+"_Cmd"
                            if ((childDev.getDataValue(data))&&(childDev.getDataValue(data)!=" ")){
                                 log ("$childDev.displayName data $data already exists","DEBUG")

                            }
                            else {
                               childDev.updateDataValue(data, " ")
                                log ("Adding data $data to $childDev.displayName","KH")
                            }
                        }
             }   
         }    
         attr2List=childDev.getSupportedAttributes()
         for (j = 0; j < attr2List.size(); j++) {
           if (attr2List[j].dataType =="ENUM") {
               String atts = "${attr2List[j].getPossibleValues()}" 
              if ((childDev.getDataValue("${attr2List[j]}_MAP"))&&(childDev.getDataValue("${attr2List[j]}_MAP")!=" ")){                          
                log ("$childDev.displayName ${attr2List[j]}_MAP already exists","TRACE")
              }
              else {
                 log ("Adding the default attribute values to ${attr2List[j]}_MAP","DEBUG")
                  atts=atts.trim()
                 childDev.updateDataValue("${attr2List[j]}_MAP", atts.replace(', ', ','))
              }
           }
           else log ("Attribute was not ENUM [${attr2List[j]}] $attr2List[j].dataType", "TRACE")
         }	 // end for 
          if (atomicState.newDevType == "MQTT Text") {
              childDev.updateDataValue("text_Topic", "")  // This attribute is not discovered within capability as it is custom
              childDev.updateDataValue("text_Cmd", "")
          }    
}

def installed() {
	log ( "${app.name} Installed","INFO")
    //createMQTTclient()
    atomicState.FirstRun=true
	atomicState.topicMap=[:]
	atomicState.nameMap=[:]
    //createMQTTclient() 
	wipe() // also initialises 
	initialize()
    atomicState.appCount=0
}

def updated() {
	log ("${app.name} Updated", "INFO")
	unsubscribe() 
    atomicState.count=0
	unschedule()
    checkAtomics()  
	initialize()
}

def uninstalled() {
    log ("Deleting all child devices", "WARN")
    wipe()
	removeAllChildDevices()
}

def reStart(evt) {
    log ("===================== ReStart =====================", "INFO")
    atomicState.restartPending=false
    unschedule()
    unsubscribe()
	initialize()
}

def initialize() {
              settings.each {k,v -> 
                  if (k.startsWith("vAr_")) {        
                      dynVars[k]=v  // synchs the current settings for dynamic page @FIELD
              }
            }
    mqtt = getChildDevice("MQTT: Child device driver")
    atomic_StateRemoves()
    if (mqtt==null) {
        if (atomicState.FirstRun==false) {
            createMQTTclient() 
            mqtt = getChildDevice("MQTT: Child device driver")
            if (mqtt==null) log ("MQTT client failed to create","ERROR")
        }
        else {
            log ("Skipped creating MQTT client as first run","KH")
            log ("Please run the app again","KH")
            atomicState.FirstRun=false
            return
        }
    }
    else log ("MQTT Client driver present","INFO")
    atomicState.normHubName = normalize(settings?.hubName)
    log ("Hubitat hub name is : " + settings?.hubName,"INFO")
    if (mqtt==null) {
        log ("FATAL: No MQTT broker configured","ERROR")
    }
    else {
        mqtt.setHubName (normalize(settings?.hubName),settings?.hubName)
        mqtt.setUserName (settings?.username)
        mqtt.setPassword (settings?.password)
        mqtt.setBrokerAddress (settings?.MQTTBroker)
        if (settings?.cleanSession) mqtt.setCleanSession ("true") else mqtt.setCleanSession ("false")
    }
    if (atomicState.appcount==null) atomicState.appCount=0
    log ("initialising with App count ${atomicState.appCount}","INFO")
    mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"idle",1,true)
    mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$discovery',"startup",1,true)
    atomicState.startupDiscovery='init'
    def date1 = new Date()
    properties=[:]
    topicLink=[:]
    //log.e(location.hubs[0].getZigbeeId())
    atomicState.myHub=true
    checkMyHub()
    countTry=5
    aborting=false
    atomicState.abort=false  // just added remove later
    unblockUnblock() // this will continue to run every 20 seconds
    //if (atomicState.abortable) atomicState.abort=true  // JUST TO TEST - will abort if still possible
    while (atomicState.abort) {
        log("Awaiting earlier App to abort [$countTry]","WARN")
        aborting=true
        countTry--
            if (countTry < 0) { 
                log ("Continuing.. Given up waiting for earlier app to abort", "KH")
                atomicState.abort=false
            }
       else pauseExecution(6000)
    }
    atomicState.dni=''
    atomicState.dataName=''
    atomicState.varX=''
    if (aborting) log ( "Earler app sucessfully aborted","WARN")
    aborting=false
    atomicState.abort=false
    atomicState.MQTTconnected=false
    xtra=0
    for (int i = 0; i < 86 && (atomicState.MQTTconnected==false); i++) {  // tries to reconnect every 10 seconds
        if (i==0)  log ("Waiting for MQTT connection: $atomicState.MQTTconnected","INFO")
        else log ("Waiting another try [$i] until MQTT connected: $atomicState.MQTTconnected","WARN")
        mqtt.reset()
        pauseExecution(10000+xtra)  // initially 10 seconds
        if (i>5) xtra = 20000  // increase to 30 seconds after a minute
        else if (i>24) xtra = 50000  // 1 minute after 10
        else if (i>74) xtra = 590000  // 10 minutes after an hour
        // will currently run for 2 hours    
    }
    if (i>85) {
        log ("MQTT has failed to connect. Restart the app to try again","ERROR")
        return
             }
   
    mqttSubscribes()
    if (settings?.HAStatestream) {
        mqtt.setHAStatestreamTopic(settings?.HAStatestreamTopic)
        atomicState.HA=settings?.HAStatestreamTopic
    }
    if (settings?.HAInDiscovery) {
        if (settings?.HAinTopic!=null) mqtt.setHAInTopic(settings?.HAInTopic)
        //atomicState.HAIn=settings?.HAInTopic
    }
    if (settings?.zigbee2mqttDiscovery) {
        mqtt.setzigbee2mqttTopic(settings?.zigbee2mqttTopic)
        //atomicState.zigbee2mqtt=settings?.zigbee2mqttTopic
    }
    if (settings?.zwave2mqttDiscovery) {
        mqtt.setzwave2mqttTopic(settings?.zwave2mqttTopic)
        //atomicState.zwave2mqtt=settings?.zwave2mqttTopic
    }
    if (settings?.CBusDiscovery) {
        mqtt.setCBusTopic(settings?.CBusTopic)
    }
	if (settings?.HADiscovery) {  // Outgoing HE > HA
		// TODO ensure homie publish or other adequate topic structure is enabled
		if (!settings?.homiePublish) log ("You must enable homie3 publish too for HA Discovery to work correctly","ERROR")
        
		settings?.homiePublish=true    // TODO doesn't work !  settings are r/o - need to use an atomicState var
        atomicState.HA=settings?.HAStatestreamTopic
		mqtt.subscribeTopic(atomicState.HA+'/status') 
	}
    if (!settings?.minHomie) {
		atomicState.suppress = true 
        if (settings?.homiePublish) log("Simplified homie topics - no longer homie3 compliant","INFO")
    }
	else atomicState.suppress = false
	log("Initializing...", "DEBUG")
	atomicState.restartPending=false   // TODO check MQTT connected
	atomicState.started=false
    atomicState.abortable=true
	if (atomicState.abort) { 
            abort(1)
            return
    }
	    //mqtt.unsubscribeTopic("homie/${state.normHubName}/" +'$fw/name')
        //mqtt.unsubscribeTopic("homie/${state.normHubName}/" + '$fw/client')
        //mqtt.unsubscribeTopic("homie/${state.normHubName}/" +'$fw/version')																										
   
	//if (settings?.homiePublish)
	//{
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$state','init',1,true)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$homie','3.0.1',1,true,false) 
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$implementation','groovy:uk.co.ukusa.mqtt',1,true,false)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$fw/version','3e',1,true)
        mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$fw/hub',location.hubs[0].firmwareVersionString,1,true)
        mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$fw/id',app.getHubUID(),1,true)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$fw/name','beta',1,true)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$name',settings?.hubName,1,true)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$mac','BB:AA:DD:AA:55:55',1,true,false)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$localip',location.hubs[0].localIP,1,true,false)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$fw/app','beta 3e pre 24b',1,true,false)
        //mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$MAC',location.hubs[0].macAddress,1,true,false) // no property
        if (modes) currentMode()
        if (hsm) currentHSB()
        sunTimes()
	//}

    if (atomicState.myHub) mqtt.setmyhub("true")
    mqtt.setLogLevel (determineLogLevel(settings?.logging))
	if ((settings?.mqttRemoveDevices == true))
	{
		log ("Deleting all the MQTT child devices", "DEBUG")
		removeAllDiscoveredChildDevices()  // somehow these stay orphaned, so need this or need to create differently
	}
	if (settings?.WipeDevices == true) {
		wipe()
	}
	atomicState.homie=settings?.homieDevice  // setting the homie tree master device topic for discovery
	if (atomicState.abort) { 
            abort(2)
            return
    }
    buildMQTTLookup()  // builds the mapping of device names
    deviceEventSubscribes()   
    atomicState.MQTTvirtuals=temp    
	atomicState.MQTTOnOffDevices=0
	atomicState.MQTTDimDevices=0
    atomicState.MQTTLockDevices=0
	atomicState.adhocDevices=0
	atomicState.MQTTRGBc=0
	atomicState.MQTTRGBt=0
	atomicState.MQTTKEYPADt=0    
    if (atomicState.abort) return
    count=0
    count = sensorSubscribes(count)  // currently registers ALL capabilities and attributes for these sensors from all drop downs TODO change
    count = deviceSubscribes(count)  // currently registers ALL capabilities and attributes for these devices from all drop downs TODO change
    count = everythingSubscribes(count)   // registers ALL capabilities and attributes for these devices
	log ("reinitializing", "TRACE")
	atomicState.createDevices=false

	if (settings?.homiePublish) {
		subscribeOneOffTopics("homie/${atomicState.normHubName}/+/+/set") // incoming cmds to control HE devices - all types .. or could restrict to supported types
        subscribeOneOffTopics("homie/${atomicState.normHubName}/+/+/+/set") // incoming cmds to control HE devices at sub level eg color/rgb - all types .. or could restrict to supported types
	}
	if (atomicState.abort) { 
            abort(3)
            return
    }	
	synchDevices() // handles all the initial state publications for all enabled devices
    int time=(int) ((now()-atomicState.timeStamp)/1000)
    log ("HE device publishing to MQTT has completed in $time secs ","BLUE")
	if (atomicState.abort) { 
            abort(4)
            return
    }
    
    if(settings?.ShellyDiscovery) {
         subscribeShellyTopic()
         atomicState.delay += 0  //TODO tweak
    }
    if(settings?.SonoffDiscovery) {
        runIn (atomicState.delay, "subscribeSonoffTopic")
        atomicState.delay += 0  //TODO tweak
    }	
	if(settings?.homieDiscovery && settings?.homieRunEvery) {
        mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$discovery',"homie",1,true)
        atomicState.startupDiscovery='running'
        runIn(atomicState.delay,  "homieDiscovery")
		//runIn(atomicState.delay,  "subscribeHomieTopic")
		//runIn(atomicState.delay,  "subscribeHomieStateTopics")  
        //runIn (atomicState.delay, "subscribeHomieNameTopics")
	}   
    else if(settings?.HAStatestream && settings?.HARunEvery) {
        log ("Skipping startup homie MQTT discovery", "INFO")
        mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$discovery',"HA  statestream",1,true)
        atomicState.startupDiscovery='running'
        log ("Running HA statestream discovery", "INFO")
        start_HADiscovery(null)
    }
   else if(settings?.HAInDiscovery && settings?.HAInRunEvery) {
       log ("Skipping startup homie MQTT discovery", "INFO")
       log ("Skipping HA stateStream discovery", "INFO")
       atomicState.startupDiscovery='running'
       mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$discovery',"HA In",1,true)
       log("Running HA MQTT In Discovery","KH")
       HAInDiscovery()
        }
   else {
       log ("No Discovery startups enabled", "INFO")
       mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$discovery',"complete",1,true)
       atomicState.startupDiscovery='complete'
        }

    
	if (atomicState.abort) { 
            abort(6)
            return
    }
    
    subscribeVirtuals()  // this subscribes to any adhoc virtuals we have created
    schedule("0 1 0 1/1 * ? *", sunTimes)
    atomicState.FirstRun=false
    //unsubscribeHADeviceEvents()
    log ("Initialise exit", "INFO")  
    //if ((!settings?.homieDiscovery) && (!settings?.HAStatestream) && (!settings?.HAInDiscovery)) devSummary(null)
    if (atomicState.startupDiscovery=="complete") {
        devSummary(null)
    }
    atomicState.abort=false
    atomicState.abortable=false
}

def mqttChange(evt) {  // Currently all types of devices (SWITCH DIMMER CONTACT) come in here
    
    log ("MQTT Change Event  for $evt.name ", "KH")
    if (evt.name=='switch') {
        mqtt = getChildDevice("MQTT: Child device driver")
        topic = evt.device.getDataValue("switch_Cmd")
        jas=topic.indexOf("{")  //JSON
        //khcheck
        //TODO
        
/*       
        jasEnd=topic.length()
        if (topic[jasEnd] == '}') log  ("Json appears true ","KH")
        if (!topic[jasEnd-1] == ':') log  ("Json append appears true ","KH")
        jasAppend=topic.indexOf("}{")
        if (jasAppend > 1) log  ("Json append has data ","KH")
        jasEnd=topic.indexOf(":}")
        jasLen=topic.length()
*/   
        // {value:}{"extra": "stuff", "goes": "here", "level": 55}
        // {value:,"extra": "stuff", "goes": "here", "level": 55}
        
          if ((jas>0) && (topic.endsWith(':}'))){  //strip json
                 //log ("Strip JSON value $defOne for publish" , "KH")
                  json='{"' + topic.substring(jas+1,topic.length()-2) + '":"' + evt.value +'"}'
                  topic=topic.substring(0, jas)   
          }  
            
        if (evt.value == "${evt.device.getDataValue("mqtt_Switch")}") log ("Blocking ${evt.value} command to MQTT ${evt.name} as already ${evt.value}","INFO")
        else {
            mqtt.publishMsg (topic,evt.value,1,false) // this takes no account of the switch_ON and switch_OFF settings - it assumes the /set was correct
        }
    }
    else if (evt.name=='level') {       
        topic = evt.device.getDataValue("level_Cmd")
        maxL= evt.device.getDataValue("max_Level")
        if (maxL == null) newLevel=evt.value
        else newLevel=(maxL.toInteger() * evt.value.toInteger() / 100).toInteger()  // TODO 50% should be 128 to avoid creep
        if (evt.value == "${evt.device.getDataValue("mqtt_Level")}") log ("Blocking ${evt.value} command to MQTT ${evt.name} as already ${evt.value}","INFO")  // WONT WORK as evt.value is scaled and stored isnt TODO  CONVERT
        else mqtt.publishMsg (topic,newLevel.toString(),1,false)
    } 
}    

def atomic_StateRemoves() {
    log  ("Removing unused atomicState variables","info")
    atomicState.remove("lastDevice")
    atomicState.remove("lastDev")
    atomicState.remove("properties")
    atomicState.remove("topicLink")
    atomicState.remove("nodes")
    atomicState.remove("block")
    atomicState.remove("blocked")
    atomicState.remove("newMap")
    atomicState.remove("nameMap")
    atomicState.remove("Mappings")
    atomicState.remove("ShelleyDevices")
    atomicState.remove("SonoffDevices")
    //atomicState.remove("timeStamp")
    atomicState.remove("vDev")
    atomicState.remove("vDevName")
    atomicState.remove("topicMap")
}

def abort (where) {
            log ("Abort Initialize $where","WARN")
            unschedule()// This may need removing too
            //unsubscribe()
            atomicState.abort=false
            atomicState.abortable=false
            atomicState.appCount=atomicState.appCount-1    
}

def addProperty(key,value,device=null) {
    att=value  

    
    mqtt = getChildDevice("MQTT: Child device driver")
    if (properties[key] == null) {
        if (att=='ramp') log ("key was null for $device[$value]","KH")
        properties[key] = value
        if (device!=null)   device.updateDataValue("properties", value)
        if (device.getDataValue("origin")=='user') return
        else mqtt.publishMsg (key+'/$properties',"${properties[key]}",1,true)
    }
    else {
        if (properties[key].contains (value)){
            return
        }
    properties[key] = properties[key] + "," + value
    value=properties[key]
    //if (att=='ramp') log ("Updating property data value $device[$value]","KH")
    if (device!=null)   device.updateDataValue("properties", value) //value)
    //mqtt.publishMsg (key+'/$properties',"${properties[key]}",1,true,atomicState.suppress)
    mqtt.publishMsg (key+'/$properties',"${properties[key]}",1,true)        
    }
} 

def buildMQTTLookup() {    // allows lookup of the HE device using normalised name used in homie tree  // cant I lookup to deviceNetworkID directly ?
    nameMap = [:]
    newMap=[:]
   // MQTTswitches = (settings?.switches)
	total=0
	nodes=''  //always present
    if ((modes)||(hsm)) nodes=",hub" else nodes=","
    // No sensors in here as can't be controlled from MQTT    
    count=buildMaps((settings?.switches),"switches")
       atomicState.MQTTOnOffDevices=count
       total+=count
    count=buildMaps((settings?.dimmers),"dimmers")
       atomicState.MQTTDimDevices=count
       total+=count
    count=buildMaps((settings?.colour),"RGB")
       atomicState.MQTTRGBc=count
       total+=count
    count=buildMaps((settings?.colourT),"RGBT")
       atomicState.MQTTRGBt=count
       total+=count
    count=buildMaps((settings?.refresh),"refresh")
       atomicState.MQTTrefresh=count
       total+=count
    count=buildMaps((settings?.ramp),"ramp")
       atomicState.MQTTramp=count
       total+=count
   count=buildMaps((settings?.fans),"fans")
       atomicState.MQTTfanDevices=count
       total+=count
   count=buildMaps((settings?.mqtttext),"mqtt text")
       atomicState.MQTTtext=count
       total+=count
    count=buildMaps((settings?.windowshades),"window shades")
       atomicState.MQTTwindowDevices=count
       total+=count
    count=buildMaps((settings?.locks),"locks")
       atomicState.MQTTLockDevices=count
       total+=count 
    count=buildMaps((settings?.keypads),"keypads")
       atomicState.MQTTKEYPADt=count
       total+=count 
    count=buildMaps((settings?.chimes),"chimes")
       atomicState.MQTTChimeDevices=count
       total+=count
    count=buildMaps((settings?.bulbs),"bulbs")
       atomicState.MQTTBulbDevices=count
       total+=count
    count=buildMaps((settings?.outlets),"outlets")
       atomicState.MQTTOutletDevices=count
       total+=count 
    count=buildMaps((settings?.relayswitches),"relay switches")
       atomicState.RelaySwitchDevices=count
       total+=count
    count=buildMaps((settings?.thermostats),"thermostats")
       atomicState.MQTTThermostats=count
       total+=count 
    count=buildMaps((settings?.valves),"valves")
       atomicState.MQTTValveDevices=count    
       total+=count 
    count=buildMaps((settings?.globVars),"global variables")
       atomicState.MQTTGlobalVarDevices=count
       total+=count 
    count=buildMaps((settings?.gVars),"gVars")
       atomicState.MQTTgVarDevices=count
       total+=count 
    count=buildMaps((settings?.everything),"everything")
       atomicState.MQTTEverythingDevices=count
       total+=count
    count=buildMaps((settings?.alarms),"alarms")
       atomicState.MQTTAlarmDevices=count
       total+=count 
    nodes=nodes.substring(1)
    atomicState.TotalDevices=total
    if (settings?.homiePublish){
        mqtt = getChildDevice("MQTT: Child device driver")
        mqtt.publishMsg ("homie/${atomicState.normHubName}/"+'$nodes',nodes,1,true,atomicState.suppress)
    }
    nodes1=nodes
    noddy= nodes1.split(',')
    log ("[${noddy.size()}] nodes added $nodes", "TRACE")
}

def buildMaps (devices, type) {
        count=0
        if (devices != null) {
            devices.each { dev -> 
                name=dev.displayName.toString()
                UID=dev.deviceNetworkId.toString()
                normName=normalize(name).toString()
                log ("    MQTT $type Device " + name + " + " + normName + UID, "TRACE")
		        if (normName!=null) nodes += ',' + normName 
                else log ("null name on $dev.displayName","DEBUG")
			    // Build a lookup table for normName to full name & UID
			    nameMap [normName] = name
                newMap [normName] = UID
                count++
            }     
        }
     return (count)    
}    

def mqttSubscribes() {  //events from MQTT driver
    mqtt = getChildDevice("MQTT: Child device driver")
    //subscribe(mqtt,"MQTTStatus", mqttStatus)
    subscribe(mqtt,"HADiscoverStart",start_HADiscovery)
	//subscribe(mqtt,"HASynch", synchDevices)
	subscribe(mqtt,"OnOffDev", onoffCapability)
	subscribe(mqtt,"DimDev", dimCapability)
    subscribe(mqtt,"ButtonDev", buttonCapability)
	subscribe(mqtt,"SensorDev", sensorCapability)
    subscribe(mqtt,"LockDev", lockCapability) //Casey
	//subscribe(mqtt,"LabelDevice", reNameDev)  //LabelDeviceP()
	//subscribe(mqtt,"HASwitchDev", HASwitchCapability)
	//subscribe(mqtt,"HALightDev", HALightCapability)
	//subscribe(mqtt,"HASensorDev", HASensorCapability)  //friendly name
    //subscribe(mqtt,"HASensorType", HASensorType)  //device_class
	//subscribe(mqtt,"HABinarySensorDev", HABinarySensorCapability)
	//subscribe(mqtt,"HAInputBooleanDev", HAInputBooleanCapability)
    //subscribe(mqtt,"HAPerson", HAPresenceCapability)
	//subscribe(mqtt,"HACoverDev", HACoverCapability)
    //subscribe(mqtt,"HALockDev", HALockCapability)
    //subscribe(mqtt,"HADeviceTrackerDev", HADeviceTrackerCapability)
    //subscribe(mqtt,"HAClimateDev", HAClimateCapability)
    //subscribe(mqtt,"HAGroupDev", HAGroupCapability)
    subscribe(mqtt,"ShellyDevice",ShellyCapabilities)
    //subscribe(mqtt,"ShellyDimDev",dimCapabilityShelly)
	//subscribe(mqtt,"OnOff", onoffEvent)
	//subscribe(mqtt,"Dim",dimEvent)
	//subscribe(mqtt,"Command",cmdEvent)
	//subscribe(mqtt,"Sensor",sensorEvent)
	//subscribe(mqtt,"BinarySensor",binarySensorEvent)
	//subscribe(mqtt,"SensorUnit",sensorUOM)
    //subscribe(mqtt,"Lock", lockEvent) //Casey
	//subscribe(mqtt,"Group",groupEvent)
    subscribe(mqtt,"VariableDev",varCapability)
	//subscribe(mqtt,"InputBoolean",inputBooleanEvent)
    //subscribe(mqtt,"WildcardTopics","wildcardTopics")
    //subscribe(mqtt,"person",presenceEvent)
    subscribe (mqtt,"presence", mqttOnline)  //MQTT Broker connected indicator
	//subscribe(mqtt,"Lookup", LookupManual)  //deprecated
	//subscribe(mqtt,"SensorDevClass",HABinSensorType)  //??  doesnt exist
	//subscribe(mqtt,"getTopic", topicPayload)
    //subscribe (mqtt,"HAUnknown",HAUnknownCapability)
    subscribe (mqtt,"HEUnknown",homieUnknownCapability)
    subscribe (mqtt,"endDiscovery",devSummary)
    subscribe (mqtt,"Waiting",mqttProgress)
    subscribe (mqtt,"unsubscribeFriendly",unsubscribeHADevices)
	subscribe (mqtt,"Format",format)
															  
}

def lockEvent(evt) {
        log  ("Lock Event Handler is AWOL","WARN")									
}

def mqttProgress(evt) {
    log ("Waiting for $evt.value","LOG")
}
							   
def deviceEventSubscribes() {   // This raises subscriptions for all enabled devices for the switch , level and lock attributes

    if (hsm) subscribe(location, locationEvent) 
    else {
        if(modes) subscribe(location,"mode",locationEvent)
	    subscribe(location, "systemStart", locationEvent)
    }
	subscribe(switches, "switch", switched)
	subscribe(dimmers, "level", dimmed)
	subscribe(dimmers, "switch", switchedDim) 

	//subscribe(colour, "color", colourDevices)  //ToDo check this is correct commented out
    //subscribe(locks, "lock", locked) //Casey

    subscribe(var_VirtualSwitch, "switch", switched)
    subscribe(var_VirtualDimmer, "level", dimmed)
    subscribe(var_VirtualColorTemperatureLight, "level", dimmed) // ??
    subscribe(var_VirtualRGBLight, "level", dimmed)
    subscribe(var_VirtualRGBWLight, "level", dimmed)
    subscribe(var_VirtualDimmer, "switch", switchedDim)
    subscribe(var_VirtualColorTemperatureLight, "switch", switchedDim)  // ??
    subscribe(var_VirtualRGBLight, "switch", switchedDim)
    subscribe(var_VirtualRGBWLight, "switch", switchedDim)
    subscribe(var_VirtualGarageDoorController, "contact", otherDevices)  //check
    subscribe(var_VirtualGarageDoorController, "door", otherDevices)  //check
    subscribe(var_VirtualShade, "position", otherDevices)  //check  == level
    subscribe(var_VirtualShade, "switch", otherDevices)  //check
    subscribe(var_VirtualShade, "windowShade", otherDevices)  //check
    subscribe(var_VirtualLock,"lock",locked)  //check
    subscribe(var_VirtualFanController, "speed", otherDevices)  //check

    //subscribe(var_RM Connector Variable,what,what)
    subscribe(var_MQTTText,"text",otherDevices)
    subscribe (var_RemoteThermostat,"climate","thermostatDevices")
               
    
/*  subscribe(var_Virtual audioVolume,what,what)
    subscribe(var_Virtual Button,what,what)
    subscribe(var_Virtual CO Detector,what,what)
    subscribe(var_Virtual Contact Sensor,what,what)
    subscribe(var_Virtual Fan Controller,what,what)
    subscribe(var_Virtual Humidity Sensor,what,what)
    subscribe(var_Virtual Illuminance Sensor,what,what)
    subscribe(var_Virtual Moisture Sensor,what,what)
    subscribe(var_Virtual Motion Sensor,what,what)
    subscribe(var_Virtual Multi Sensor,what,what)
    subscribe(var_Virtual Omni Sensor,what,what)
    subscribe(var_Virtual Presence,what,what)
    subscribe(var_Virtual Shade,what,what)
    subscribe(var_Virtual Smoke Detector,what,what)
    subscribe(var_Virtual Temperature Sensor,what,what)
    subscribe(var_Virtual Thermostat,what,what)
*/

/*					   
    // adhoc events from driver
	subscribe(adhoc,"OnOff",onoffEvent)
    // TODO CHECK  no dimEvent sub ??
	subscribe(adhoc,"topic", stateTopics)
	subscribe(adhoc,"mapTopic", mapTopics)
	subscribe(adhoc,"changeState",stateChange)
	subscribe(adhoc,"changeLevel",levelChange)
    subscribe(adhoc,"changeText",textChange)
*/    
    //subscribe (motionsensors,"motion",sensorDevices)
    subscribe (globVars,"variable",varChange)
    subscribe (gVars,"variable",varChange)
    subscribe (vSwitch,"switch",mqttChange)
    subscribe (vContact,"contact",mqttChange)
    subscribe (vDimmer,"level",mqttChange)
    subscribe (vDimmer,"switch",mqttChange)
}

def sensorSubscribes(count) {   // These are report only attributes- they have no commands
    
        attCount=0  // TODO now not local
        count = registerSpecificAttribute (motionsensors,count,'motion','sensorDevices')
        count = registerSpecificAttribute (contactsensors,count,'contact','sensorDevices')
    //count = registerAll (listAll,count,'auto')  // for Hubitat topic
    //count = registerAll (sensors,count,'sensorDevices')   // for homie topic
        count = registerSpecificAttribute (shocksensors,count,'shock','sensorDevices')
        count = registerSpecificAttribute (smokesensors,count,'smoke','sensorDevices')
        count = registerSpecificAttribute (presencesensors,count,'presence','sensorDevices')
        count = registerSpecificAttribute (humiditysensors,count,'humidity','sensorDevices')
        count = registerSpecificAttribute (illuminancesensors,count,'illuminance','sensorDevices')
        count = registerSpecificAttribute (tempsensors,count,'temperature','sensorDevices')
        count = registerSpecificAttribute (batterysensors,count,'battery','sensorDevices')
        count = registerSpecificAttribute (carbonmonoxidesensors,count,'carbonmonoxide','sensorDevices')
        count = registerSpecificAttribute (voltagesensors,count,'voltage','sensorDevices')
        count = registerSpecificAttribute (powersensors,count,'power','sensorDevices')
        count = registerSpecificAttribute (watersensors,count,'water','sensorDevices')  
        count = registerSpecificAttribute (globVars,count,'variable','otherDevices')  //  ?? Not a sensor as updateable
        count = registerSpecificAttribute (gVars,count,'variable','otherDevices')  //  ?? Not a sensor as updateable
        
    return (count)
}

def deviceSubscribes(count) {  // TODO check - Here I might only have enabled one capability but I am subscribing to all capabilities and attributes - need to only use attributes that are in the capability
    mqtt = getChildDevice("MQTT: Child device driver")
        log ("deviceSubscribes","DEBUG")

        count=registerAll (everything,count)  // auto lookup handle
     
// MUST now use registerSpecificCapability as only specific capabilities are enabled here
 
        // actuators  do nothing no attributes
        // refresh                     TODO
        count = registerSpecificCapability (refresh,count,'Refresh','otherDevices')
        count = registerSpecificCapability (colour,count,'ColorControl','colourDevices')
        count = registerSpecificCapability (colourT,count,'ColorTemperature','colourDevices')
        count = registerSpecificCapability (colourMode,count,'ColorMode','colourDevices')
        count = registerSpecificCapability (thermostats,count,'Thermostat','thermostatDevices')
        count = registerSpecificCapability (buttonspush,count,'PushableButton','buttons')
        count = registerSpecificCapability (buttonshold,count,'HoldableButton','buttons')
        count = registerSpecificCapability (buttonstap,count,'TapableButton','buttons')
        count = registerSpecificCapability (buttonsrelease,count,'ReleasableButton','buttons')
        count = registerSpecificCapability (buttonsdtap,count,'DoubleTapableButton','buttons')
        count = registerSpecificCapability (alarms,count,'Alarm','otherDevices')
        count = registerSpecificCapability (bulbs,count,'Bulb','otherDevices')
        count = registerSpecificCapability (chimes,count,'Chime','otherDevices')
        count = registerSpecificCapability (garagedoors,count,'GarageDoorControl','otherDevices')
        count = registerSpecificCapability (fans,count,'FanControl','otherDevices')
        count = registerSpecificCapability (keypads,count,'SecurityKeypad','keypadDevices')
        count = registerSpecificCapability (outlets,count,'Outlet','otherDevices')
        count = registerSpecificCapability (relayswitches,count,'RelaySwitch','otherDevices')
        count = registerSpecificCapability (musicplayers,count,'MusicPlayer','audioDevices')
        count = registerSpecificCapability (speechsynthesis,count,'SpeechSynthesis','audioDevices')
        count = registerSpecificCapability (valves,count,'Valve','OtherDevices')
        count = registerSpecificCapability (windowshades,count,'WindowShade','otherDevices')
        //count = registerSpecificCapability (windowshades,count,'Level','otherDevices')
        count = registerSpecificCapability (windowshades,count,'Switch','otherDevices')
        count = registerSpecificCapability (dimmers,count,'SwitchLevel','dimmed')
        count = registerSpecificCapability (locks,count,'Lock','locked')
        count = registerSpecificCapability (switches,count,'Switch','switched')
        count = registerSpecificCapability (lights,count,'Switch','switched')
        count = registerSpecificAttribute (settings?.mqtttext,count,'text','otherDevices')
        count = registerSpecificAttribute (settings?.mqtttext,count,'textPrefix','otherDevices')
        count = registerSpecificAttribute (settings?.mqtttext,count,'textSuffix','otherDevices')
        //count = registerSpecificCapability (switches,count,'Switch','switchedDim')   //??
     

    atomicState.delay=0
    int i= count/5
    estStartup= atomicState.delay + (count/3)
    atomicState.timeStamp=now()
    log ("Starting HE device publishing to MQTT for ${count} HE devices with ${attCount} attributes","BLUE")
    if (settings?.homieDevice) mqtt.setHomieDevice(settings?.homieDevice)
	count=0
}

 
def everythingSubscribes(count) {   
    count = registerAll (everything,count)
    if (everything != null) log ("Registering $everything" , "LOG")
}


def registerSpecificCapability (devList, count, capability, handlerReq='auto'){      //registers handlers for a specific device capability
    changes=true
     devList.each { dev ->
          dev.capabilities.each { cap ->
              if ("${cap}" == "${capability}") {
                  cap.attributes.each { attr ->
                          prop=whatProperty(attr.name)
                          normName=normalize(dev.displayName)
                          key = "homie/${atomicState.normHubName}/$normName"
                          if (changes && prop!='unknown') addProperty (key,prop,dev)
                          lookupHandler(dev,cap.name,attr.name,handlerReq)
                          attCount++
                      } 
                  }
              else log ("Capability [$cap][$capability] not required for device [$dev] ", "DEBUG")  
          }
      count++
      }
return (count)
    
    
}

def registerSpecificAttribute (devList, count, attribute, handlerReq='auto'){      //registers handlers for a specific device capability 
     changes=true
     devList.each { dev ->
                      if (attribute=='variable'){   //variables don't list as attributes 
                          normName=normalize(dev.displayName)
                          key = "homie/${atomicState.normHubName}/$normName"
                          if (changes) addProperty (key,'variable',dev)
                          lookupHandler(dev,'Variable','variable',handlerReq)
                          attCount++  
                          return false
                      }
                      else if (attribute=='text'){   //variables don't list as attributes 
                          normName=normalize(dev.displayName)
                          key = "homie/${atomicState.normHubName}/$normName"
                          if (changes) {
                              addProperty (key,'text',dev)
                              addProperty (key,'prefix',dev)
                              addProperty (key,'suffix',dev)
                          }
                          lookupHandler(dev,'Text','text',handlerReq)
                          lookupHandler(dev,'Text','prefix',handlerReq)
                          lookupHandler(dev,'Text','suffix',handlerReq)
                          attCount++  
                          return false
                      }

          dev.capabilities.each { cap ->
                  cap.attributes.each { attr ->
                      if ("${attr}" == "${attribute}") {
                          log ("$dev Specific Att Registration of $cap $attr", "GREEN")                          
                          prop=whatProperty(attr.name)
                          normName=normalize(dev.displayName)
                          key = "homie/${atomicState.normHubName}/$normName"
                          if (changes && prop!='unknown') addProperty (key,prop,dev)
                          lookupHandler(dev,cap.name,attr.name,handlerReq)
                          attCount++
                      }
                      else log ("$dev [$attribute] attribute - attribute [$attr] not required for capability [$cap] ", "KGREEN")   // ERROR 
                  }
          }
      count++
      }
return (count)
}

def registerEventHandler (dev) {  //registers an event handlers for every capability a device has
    //  a variable or text (MQTT Text) attribute will not get registered as it has no matching capability !

          if (dev.typeName == "MQTT Text") subscribe(dev,"text",otherDevices)
          dev.capabilities.each { cap ->

              if (cap.name=='Switch') 	{
                  subscribe(dev, "switch", switched)
                  log ("$dev (switch) registering  event handler for " + cap.name,"KH") 
              }        
              else if (cap.name=='Level') {   
                  log ("$dev (level) registering  event handler for " + cap.name,"KH") 
                  //subscribe(dev, "level", dimmed)
              }
              else if (cap.name=='SwitchLevel') {   
                  log ("$dev (switchlevel) registering  event handler for " + cap.name,"KH") 
                  subscribe(dev, "level", dimmed)
              }
              else if (cap.name=='Refresh') {   
                  log ("$dev (refresh) ignoring registering  event handler for " + cap.name,"KH") 
              }
              else log ("$dev no event handler available or registered for: " + cap.name,"WARN") 
	}
}



def registerAll (devList,count,handlerReq='auto') {  //registers handlers for every capability and attribute a device has
    //  a variable or text (MQTT Text) attribute will not get registered as it has no matching capability !
        changes=true
        devList.each { dev ->
          if (dev.typeName == "MQTT Text") subscribe(dev,"text",otherDevices)
          dev.capabilities.each { cap ->
            cap.attributes.each { attr ->
                log ("$dev (all) subscribing to " + cap.name + "  " + attr.name + "  " + handlerReq, "DEBUG")

                prop=whatProperty(attr.name)
                normName=normalize(dev.displayName)
                key = "homie/${atomicState.normHubName}/$normName"
                if (changes && prop!='unknown') addProperty (key,prop,dev)
                
                //subscribe(dev, attr.name, buttons)
                lookupHandler(dev,cap.name,attr.name,handlerReq)
                //attCount++
                
                

                // released doubleTaped pushed numberOfButtons held
            }
            //capCount++
	    }
        count++        
	}
    return (count)
}

def whatProperty(attr) {
    found=true
    switch (attr) {
        case "switch":
            property="onoff"
            break
        case "level":
            property="dim"
            break
        case "colorTemperature":
            property="color-temperature"
            break
        //case "colorControl":
        case "colorName":
            property="color-name"
            break
        case "hue":
        case "saturation":
        case "hsv":
        case "RGB":
        case "RGBT":
        case "color":
            property="color"
            break
        case "colorMode":
        case "cMode":
            property="color-mode"
            break
        case "thermostatSetpoint":
            property="thermostat-setpoint"
            break
        case "heatingSetpoint":
            property="heating-setpoint"
            break
        case "coolingSetpoint":
            property="cooling-setpoint"
            break
        case "thermostatMode":
            property="mode"
            break
        case "thermostatModes":
        case "supportedThermostatModes":
            property="modes"
            break
        case "thermostatOperatingState":
            property="state"
            break
        case "thermostatFanMode":
            property="fanmode"
            break
        case "thermostatFanModes":
        case "supportedThermostatFanModes":
            property="fanmodes"
            break
        case "hysteresis":
            property="unknown"
            //property "hysteresis"
            break
        case "schedule":
            //property "schedule"
        property="unknown"
            break
        case "lastCodeName":
            property="lastuser"
            break
        case "securityKeypad":
            property="securitymode"
            break
        case "lockCodes":                        //TODO
        case "maxCodes":
        case "codeLength":
        case "codeChanged":
            property='unknown'
            break

        case "battery":
        case "water":
        case "temperature":
        case "humidity":
        case "voltage":
        case "energy":
        case "power":
        case "illuminance":
        case "carbonDioxide":
            property="measure-"+attr
            break
        case "smoke":
        case "carbonMonoxide":
            property=attr+"-alarm"
            break
        case "pushed":
        case "released":
        case "held":
        case "doubleTapped":
        case "numberOfButtons":
            property="button"
            break
        case "status":
        case "volume":
        case "mute":
        case "trackData":
        case "trackDescription":
        case "level": // This can never be executed due to match > dim previously
        case "motion":
        case "contact":
        case "alarm":
        case "presence":                        //CHECK
        case "acceleration":                    //CHECK
        case "cover":
        case "door":
        case "position":
        case "speed":
        case "valve":
        case "variable":
        case "lock":
            property=attr.toLowerCase()
            break
        case "windowShade":
            property='state'
            break
        case "networkstatus":
            property='state'
            break
        default:
            log ("Unknown property value $attr","WARN")
            //property=attr.toLowerCase()
            property='unknown'
            found=false
            break
        }      
        return (property)
    // return (property,false)
}

def lookupHandler(device,capability,attribute,handlerReq='auto')
{
   def handler=''
   log ("$device: Need to subscribe to events from ${capability}  ${attribute} using ${handlerReq}", "DEBUG")    
   switch(capability) {
   case "SwitchLevel":
	   handler="dimmed"
	   break
   case "Switch":
   case "Light":
	   handler="switched"   
       break
   case "Switched":   
	   handler="switchedDim"
       break
   case "Thermostat": 
       handler="thermostatDevices"
       break
   case "ColorControl":
   case "ColorTemperature":
   case "ColorMode":
       handler="colourDevices" 
       break
   case "Lock":
        handler="locked"
		break
   case "SpeechSynthesis":
   case "MusicPlayer":
       handler="audioDevices"
       break
   case "HoldableButton":
   case "PushableButton":
   case "DoubleTapableButton":
   case "ReleasableButton":
       handler="buttons"
       break
   case "Alarm":
   case "Bulb":
   case "Chime":
   case "FanControl":
   case "GarageDoorControl":
   case "Outlet":   
   case "RelaySwitch":
   case "Text":
   case "Valve":
   case "Variable":  // artificial
   case "WaterSensors":
   case "WindowShade":
       handler="otherDevices" 
       break
   case "SecurityKeypad":
       handler="keypadDevices"
       break
   default:
       log ("Handling ${device} ${capability} ${attribute} with (default) sensor", "LOG")
       handler="sensorDevices"
       break

    }
   if (handlerReq != 'auto') {
           if (handlerReq != handler) log ( "Auto Handler Mismatch [${device} ${capability} ${attribute}] ReqHandler:${handlerReq} AutoHandler:${handler}", "KH")
           handler=handlerReq  // give it the requested one for now...
    }
    else log ("Everything events subscribe to $device $attribute $handler","DEBUG") // Is attribute inclusion right here ???
    log ("Events subscribe to $device $attribute $handler","DEBUG") // Is attribute inclusion right here ???
    if (handler!="") {
        subscribe(device,attribute,handler)
        log ("LookUp Event Handler Reg: $device $attribute $handler", "TRACE")
    }
    else log ("No handler found for $device $attribute","WARN")
}


def wipe() { 
	atomicState.onoffDevices=[] 
	atomicState.dimDevices=[]
	atomicState.sensorDevices=[]
    atomicState.buttonDevices=[]
    atomicState.lockDevices=[]  //Casey
    atomicState.homieUnknownDevices=[]
    atomicState.varDevices=[]
    atomicState.SonoffDevices=[]
    atomicState.ShellyDevices=[]
	atomicState.HASwitchDevices=[]
	atomicState.HALightDevices=[]
	atomicState.HASensorDevices=[]
	atomicState.HABinarySensorDevices=[]
	atomicState.HAInputBooleanDevices=[]
    atomicState.HACoverDevices=[]
    atomicState.HAClimateDevices=[]
    atomicState.HADeviceTrackerDevices=[]
    atomicState.HALockDevices=[]
	atomicState.HAGroupDevices=[]
    atomicState.HAPresenceDevices=[]
    atomicState.HAUnknownDevices=[]
    atomicState.homieUnknownDevices=[]
    atomicState.buttonDevices=[]
    atomicState.varDevices=[]
    atomicState.MQTTvirtuals=[]
    atomicState.HAInSwitchDevices=[]
	atomicState.HAInLightDevices=[]
	atomicState.HAInBinarySensorDevices=[]
    atomicState.HAInSensorDevices=[]
    atomicState.HAInPersonDevices=[]
    atomicState.HAInCoverDevices=[]
    atomicState.HAInLockDevices=[]
    atomicState.HAInClimateDevices=[]
    atomicState.HAInAutomations=[]
    atomicState.HAInGroups=[]
    

    atomicState.zigbee2mqttLightDevices=[]
    atomicState.zigbee2mqttSwitchDevices=[]
    atomicState.zigbee2mqttSensorDevices=[]
    atomicState.zigbee2mqttButtontDevices=[]
    atomicState.CBusLightDevices=[]
    atomicState.CBusTextDevices=[]
    atomicState.Mappings=[:]
    log ("All atomicState devices[] cleared","WARN")
    atomicState.vList.each { devType ->
        setting= "var_" + "${devType.replaceAll("\\s","")}"

        app.removeSetting(setting)
    }
    	log ("All discovered devices forgotten","WARN")   
}

def currentMode() {  
	        if (settings?.homiePublish) {
                mqtt = getChildDevice("MQTT: Child device driver")
			    normName = normalize(name)
                sTopic=	"homie/${atomicState.normHubName}/hub/"
                mqtt.publishMsg (sTopic+'$name',settings?.hubName,1,true)
                if (! hsm) mqtt.publishMsg (sTopic+'$properties',"mode",1,true)
                else mqtt.publishMsg (sTopic+'$properties',"mode,hsmStatus, hsmAlert,hsmArm",1,true)
                mqtt.publishMsg (sTopic+'$type',"sensor",1,true)
			    sTopic=	"homie/${atomicState.normHubName}/hub/mode"
                mqtt.publishMsg (sTopic,"${location.mode}",1,true)
                mqtt.publishMsg (sTopic+'/$datatype','enum',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$retained','true',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$settable','true',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$format',"${location.modes}",1,true,atomicState.suppress)
            }
} 

def currentHSB() {  
	        if (settings?.homiePublish) {
                mqtt = getChildDevice("MQTT: Child device driver")
			    normName = normalize(name)
                sTopic=	"homie/${atomicState.normHubName}/hub/"
                mqtt.publishMsg (sTopic+'$name',settings?.hubName,1,true)
                if (!modes) mqtt.publishMsg (sTopic+'$properties',"hsm",1,true)
                else mqtt.publishMsg (sTopic+'$properties',"mode,hsmStatus, hsmAlert,hsmArm",1,true)
                mqtt.publishMsg (sTopic+'$type',"sensor",1,true)
			    sTopic=	"homie/${atomicState.normHubName}/hub/hsmStatus"
                mqtt.publishMsg (sTopic,"${location.hsmStatus}",1,true)
                mqtt.publishMsg (sTopic+'/$datatype','enum',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$retained','true',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$settable','false',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$format',"[armedAway, armingAway, armedHome, armingHome, armedNight, armingNight, disarmed, allDisarmed]",1,true,atomicState.suppress)
			    sTopic=	"homie/${atomicState.normHubName}/hub/hsmAlert"
                mqtt.publishMsg (sTopic,"none",1,true)
                mqtt.publishMsg (sTopic+'/$datatype','enum',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$retained','true',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$settable','false',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$format',"[intrusion, intrusion-home, intrusion-night,smoke, water, rule, cancel, arming, none]",1,true,atomicState.suppress)
            	sTopic=	"homie/${atomicState.normHubName}/hub/hsmArm"
                // mqtt.publishMsg (sTopic," ",1,true)
                mqtt.publishMsg (sTopic+'/$datatype','enum',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$retained','true',1,true,atomicState.suppress) 
                if (settings?.allowHSMControl) mqtt.publishMsg (sTopic+'/$settable','true',1,true,atomicState.suppress) 
                else mqtt.publishMsg (sTopic+'/$settable','false',1,true,atomicState.suppress)
                if (settings?.allowHSMDisarm) mqtt.publishMsg (sTopic+'/$format',"[armAway, armHome, armNight, disarm, armRules, disarmRules, disarmAll, armAll, cancelAlerts, blocked, unknown]",1,true,atomicState.suppress)
                else mqtt.publishMsg (sTopic+'/$format',"[armAway, armHome, armNight, armRules, armAll, cancelAlerts, unknown]",1,true,atomicState.suppress)
        }
}

def sunTimes() {
    	        if (settings?.homiePublish) {
                mqtt = getChildDevice("MQTT: Child device driver")
			    normName = normalize(name)
                sTopic=	"homie/${atomicState.normHubName}/hub/"
                mqtt.publishMsg (sTopic+'$name',settings?.hubName,1,true)
                if (!settings?.modes) mqtt.publishMsg (sTopic+'$properties',"sunset,sunrise,hsm",1,true)
                else mqtt.publishMsg (sTopic+'$properties',"sunset,sunrise,mode,hsm",1,true)
                mqtt.publishMsg (sTopic+'$type',"sensor",1,true)
			    sTopic=	"homie/${atomicState.normHubName}/hub/sunrise"
                mqtt.publishMsg (sTopic,"${location.sunrise}",1,true)
                mqtt.publishMsg (sTopic+'/$datatype','string',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$retained','true',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$settable','false',1,true,atomicState.suppress) 
                //mqtt.publishMsg (sTopic+'/$format',"[armedAway, armingAway, armedHome, armingHome, armedNight, armingNight, disarmed, allDisarmed]",1,true,atomicState.suppress)
			    sTopic=	"homie/${atomicState.normHubName}/hub/sunset"
                mqtt.publishMsg (sTopic,"${location.sunset}",1,true)
                mqtt.publishMsg (sTopic+'/$datatype','string',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$retained','true',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$settable','false',1,true,atomicState.suppress) 
                //mqtt.publishMsg (sTopic+'/$format',"[armedAway, armingAway, armedHome, armingHome, armedNight, armingNight, disarmed, allDisarmed]",1,true,atomicState.suppress)
            }    
}

def mqttStatus(status) {
    if (status=="Error") log("MQTT reports status of $status","ERROR")
    else log("MQTT reports status of $status","INFO")
    if (status=='Online'){
        log ("MQTT already connected", "INFO")
        atomicState.MQTTconnected=true
    }
        
    else if (status=='Connect') { 
        atomicState.delay=0
        atomicState.MQTTconnected=true
        if (settings?.cleanSession) {
            log ("Continuing , no restart required","KH") 
        }
        else {
            log ("MQTT has reconnected, restarting APP", "KH")
            if (!atomicState.started) {
            //atomicState.abort=true  // should kill the existing app if it's within the initialisation method
            log("restart requested but there's maybe another instance still initializing","WARN")
            log (" Abort is $atomicState.abort ", "WARN")
             //   runIn(10, "reStart")
            }
        //  runIn(5, "reStart") 
        }
    }
    
    else {
        if (atomicState.delay!=0)atomicState.delay+=10000
        if (settings?.cleanSession) {
            log ("Restarting MQTT app and reconnecting to MQTT in ${atomicState.delay/1000} seconds", "WARN")
            pauseExecution(atomicState.delay)
            atomicState.MQTTconnected=false
            atomicState.abort=true // This should cause any code running in initialize() to abort
            runIn(200, "reStart") // will force a restart anyway in 2 minutes if app doesn't abort itself.
            atomicState.restartPending=true
            if (!atomicState.started) {
                if (atomicState.abortable==true) atomicState.abort=true   // requests app to abort
            
                if (atomicState.abort) log ("Will now wait up to 2 minutes for abort ", "WARN")
                count=-10
                while (atomicState.abort) {
                count+=10
                log("App restart requested after MQTT disconnect but there's maybe another instance still initializing","WARN")
                log.warn "Waiting ... [$count seconds]"
                pauseExecution (10000)
                }
            }
        log("Previous run was aborted succesfully","INFO")
        runIn (1,"reStart")  //cancels timed restart
    }
    else {
        log ("MQTT disconnected but trying to reconnect as CleanSession was FALSE","ERROR")
        mqtt = getChildDevice("MQTT: Child device driver")
        pauseExecution (10000)
        mqtt.reset()
    }
    } 
}

def clearRestart() {
    log ("Force clearing the reset pending flag","ERROR")
    atomicState.restartPending=false
}

def synchDevices() {
    mqtt = getChildDevice("MQTT: Child device driver")
    log ("Resynch MQTT device states and HA discovery topics","INFO")
    publishList=[:]
    
    devLoop (settings?.switches,"switch","switched","onoff")   // moved to here (earlier) before color
    devLoop (settings?.dimmers,"level","dimmed","dim") 
    
    
    MQTTRGB = (settings?.colour)  //separate as extra values
        count=0
        if (MQTTRGB != null){
        MQTTRGB.each {
            if (settings?.HADiscovery && (!publishList.containsKey(myName))) {
                publishList.put(it.id,[myName,"light","colour"])
            }
			mydName = it.displayName
			myName = it.displayName
		    //for (String item : MQTTRGB) {
			    //switchedDim(null, myName,"onoff", it.currentSwitch,it.id)  //?? handle in colourDevices() ??
		   	    //dimmed(null, myName, "dim", it.currentLevel,it.id)  //??
		    	hsv=[it.currentHue, it.currentSaturationz, it.currentLevel]
	    		colourDevices(null, myName, "hsv", hsv,it)
//#NEW           
                rgb=it.currentRGB
                log ("New RGB attribute value for $it is $rgb","LOG")
                //if (rgb!=null) colourDevices (null,myName,"RGB",rgb,it)
            
                color=it.currentColor
                log ("New color attribute value for $it is $color","LOG")
                //if (color!=null) colourDevices (null,myName,"color",color,it)

            
                normName=normalize(myName)
            	sTopic="homie/${atomicState.normHubName}/${normName}"
                mqtt.publishMsg (sTopic+'/-device-driver',it.typeName,1,true)
            
                try {
                    colorName=it.currentColorName
                    colourDevices(null,myName,"colorName",colorName,it) 
                }
                catch (e) {
			    }            
                count++
		   // }
	    }
     }
    MQTTRGBT = (settings?.colourT) 
	if (MQTTRGBT != null){
                
        count=0
        MQTTRGBT.each {
            if (settings?.HADiscovery && (!publishList.containsKey(myName))){
                publishList.put(it.id,[myName,"light","colour"])
            }
            
			mydName = it.displayName
			myName = it.displayName
			//switchedDim(null, myName,"onoff", it.currentSwitch,it.id)
			//dimmed(null, myName, "dim", it.currentLevel,it.id)
            colorTemp=it.currentColorTemperature
            colourDevices(null,myName,"colorTemperature",colorTemp,it)
                normMame=normalize(myName)
            	sTopic="homie/${atomicState.normHubName}/${normName}"
                mqtt.publishMsg (sTopic+'/-device-driver',it.typeName,1,true)
            try {
                colorName=it.currentColorName
                colourDevices(null,myName,"colorName",colorName,it)
            }
            catch (e) {
            }
                colourDevices(null,myName,"cMode","CT",it)

            count++
		}
	}
    
    everyThing = (settings?.everything)
    if (everyThing != null){
        count=0 
        everyThing.each {
            myName=it.displayName
                if (it.hasCommand ("refresh")) {
                    normName=normalize(myName)
            	    sTopic="homie/${atomicState.normHubName}/${normName}"
                    addProperty(sTopic,'refresh',it)
                    mqtt.publishMsg (sTopic+'/refresh','false',1,true)
                    mqtt.publishMsg (sTopic+'/refresh/$datatype','boolean',1,true)
                    mqtt.publishMsg (sTopic+'/refresh/$settable','true',1,true)
                    mqtt.publishMsg (sTopic+'/refresh/$name',it.displayName,1,true)
                    mqtt.publishMsg (sTopic+'/refresh/$retained','true',1,true)
                }
            
            //log ("Everything type name is $it.typeName","LOG")
            if (it.typeName.contains("Sensor")||it.typeName.contains("Presence")) sensor=true else sensor=false 
                if (sensor) {
                    devLoopAll (it,"all","sensorDevices")  // passing all devices here not just sensors BUG
                    return false
                }
            else if (it.typeName.contains("Thermostat")){
                devLoopAll (it,"all","thermostatDevices")  
                return false
            }
            else if (it.typeName.contains("OpenWeatherMap")){
                devLoopAll (it,"all","sensorDevices")  // passing all devices here not just sensors BUG
                return false
            }
  
            else {  // Not a sensor or thermostat
                if (settings?.HADiscovery && (!publishList.containsKey(myName))){
                //publishList.put(it.id,[myName,"light","colour"])   
                }
                
            sTopic="homie/${atomicState.normHubName}/${normalize(it.displayName)}"
            mqtt.publishMsg (sTopic+'/$name',it.displayName,1,true)
            // $properties
            // $type
            // do an attribute to 
            mqtt.publishMsg (sTopic+'/-device-driver',it.typeName,1,true) 
            col=false
            it.capabilities.each { cap ->
                //log (":::$it::: Cap: $cap", "INFO")
                cap.attributes.each { attrib ->
                    attName=attrib.name
                    log ("Everything: [$myName] Cap: [$cap]  Att: [$attName] [${it.currentValue(attName)}]", "DEBUG") 
                    if ("$cap"=="Switch" || "$cap"=='Light')  {  // Is this right to call both ?
                        switched(null, myName, attName, it.currentValue(attName),it) //,multiple)
                        switchedDim(null, myName, attName, it.currentValue(attName),it) //,multiple)
                    }
                    else if ("$cap"=="SwitchLevel" && !col)  dimmed(null, myName, attName, it.currentValue(attName),it) //,multiple)
                    else if ("$cap"=="ColorTemperature") {
                            col=true
                            colourDevices(null, myName, attName, it.currentValue(attName).toString(),it) //,multiple)
                    }
                    else if ("$cap"=="ColorControl") {
                            col = true
                            colourDevices(null, myName, attName, it.currentValue(attName).toString(),it) //,multiple)
                    }
                    else if ("$cap"=="ColorMode") {
                        col=true
                        colourDevices(null, myName, attName, it.currentValue(attName).toString(),it) //,multiple)
                    }
                    else if ("$cap"=="buttons") buttons(null, myName, attName, it.currentValue(attName),it) //,multiple,dev.id)   //CHECK
                    else if ("$cap"=="LockCodes") locked(null, myName, attName, it.currentValue(attName),it) //,multiple,dev.id)   //CHECK
                    else if ("$cap"=="Lock") locked(null, myName, attName, it.currentValue(attName),it) //,multiple,dev.id)   //CHECK
                    else if ("$cap"=="keypadDevices") keypadDevices(null, myName, attName, it.currentValue(attName),it) //,multiple,dev.id)   //CHECK
                    else if ("$cap"=="audioDevices") audioDevices(null, myName, attName, it.currentValue(attName),it) //,multiple,dev.id)   //CHECK
                   // else if ("$cap"=="RealtiveHumidityMeasurement")  sensors(null, myName, attName, it.currentValue(attName),it) //,multiple)
                   // else if ("$cap"=="TemperatureMeasurement")  sensors(null, myName, attName, it.currentValue(attName),it) //,multiple)
                    else {
                            log ("Unhandled so using otherDevices [$cap $attrib]","LOG")
                            otherDevices(null, myName, "$attrib", it.currentValue("$attrib"),it) //,multiple,dev)   //CHECK
                    }
                }
            }
            col=false
            
            
/*
				it.capabilities.each { cap ->
					mqtt.publishMsg ("Hubitat/${settings?.hubName}/${myName}/capabilities/${cap}","-")
					cap.attributes.each { attrib ->
						try {
							def currentState = it.currentState(attrib.name)
							aValue= currentState.value.toString()
							mqtt.publishMsg ("Hubitat/${settings?.hubName}/${myName}/capabilities/${cap}/${attrib}",aValue)
						}
						catch (e) {
							mqtt.publishMsg ("Hubitat/${settings?.hubName}/${myName}/capabilities/${cap}/${attrib}",'-')
						}
					}
				}
            
            
*/            
            def attrs = it.supportedAttributes
			//if (attrs.size()>1) multiple=true else multiple=false
			attrs.each { attr ->
				def currentState = it.currentState(attr.name)   // what not use currentValue instead TODO ?
				try {
					aValue= currentState.value.toString()
				}
				catch (e) {
				 	aValue='-'
				}
                if (aValue!="-") {
                    //mqtt.publishMsg (sTopic+"/${attr}",aValue,1)
                    //mqtt.publishMsg (sTopic+"/${attr}",aValue,1)
                    //mqtt.publishMsg (sTopic+"/${attr}/settable",'false',1)
                    devLoop (settings?.contactsensors,"contact","sensorDevices")
                }
                count++    
            }
        }
    }
}
    
    
    
    
    loopDev = (settings?.listAll)    // These are the devices to list to Hubitat capabilities/attributes topic 
	if (loopDev != null){
			loopDev.each{
			mydName = it.displayName
			myName = it.displayName
			def attrs = it.supportedAttributes
			if (attrs.size()>1) multiple=true else multiple=false
				attrs.each { attr ->
					def currentState = it.currentState(attr.name)   // what not use currentValue instead TODO ?
					try {
						aValue= currentState.value.toString()
					}
					catch (e) {
				 		aValue=' '
					}
					mqtt.publishMsg ("Hubitat/${settings?.hubName}/${myName}/attributes/${attr}",aValue)	
				}
				it.capabilities.each { cap ->
					mqtt.publishMsg ("Hubitat/${settings?.hubName}/${myName}/capabilities/${cap}"," ")
					cap.attributes.each { attrib ->
						try {
							def currentState = it.currentState(attrib.name)
							aValue= currentState.value.toString()
							mqtt.publishMsg ("Hubitat/${settings?.hubName}/${myName}/capabilities/${cap}/${attrib}",aValue)
						}
						catch (e) {
							mqtt.publishMsg ("Hubitat/${settings?.hubName}/${myName}/capabilities/${cap}/${attrib}",' ')
						}
					}
				}	
        	}
		}

    //devLoop (settings?.switches,"switch","switched","onoff")   // moved earlier 
    //devLoop (settings?.dimmers,"level","dimmed","dim") 
    //devLoop (settings?.dimmers,"switch","switchedDim","onoff")
    devLoop (settings?.locks,"lock","locked")
    // others
    devLoop (settings?.alarms,"alarm","otherDevices")
    devLoop (settings?.bulbs,"switch","switched","onoff")
    devLoop (settings?.chimes,"chime","otherDevices")
    devLoop (settings?.garagedoors,"contact","otherDevices")
    devLoop (settings?.garagedoors,"door","otherDevices")
    devLoop (settings?.fans,"speed","otherDevices")
    devLoop (settings?.windowshades,"switch","otherDevices")
    devLoop (settings?.windowshades,"position","otherDevices")
    devLoop (settings?.windowshades,"level","otherDevices")
    devLoop (settings?.windowshades,"windowShade","otherDevices")
    devLoop (settings?.keypads,"lastCodeName","keypadDevices")
    devLoop (settings?.keypads,"securityKeypad","keypadDevices")
    devLoop (settings?.outlets,"outlet","otherDevices")
    devLoop (settings?.relayswitches,"relaySwitch","otherDevices")
    devLoop (settings?.speechsynthesis,"speech","audioDevices")
    devLoop (settings?.musicplayers,"music","audioDevices")
    devLoop (settings?.valves,"valve","otherDevices")
    devLoop (settings?.watersensors,"water","sensorDevices")
    devLoop (settings?.globVars,"variable","otherDevices")
    devLoop (settings?.gVars,"variable","otherDevices")
    //buttons
    devLoop (settings?.buttonspush,"numberOfButtons","buttons")
    devLoop (settings?.buttonspush,"pushed","buttons")
    devLoop (settings?.buttonshold,"held","buttons")
    devLoop (settings?.buttonsdtap,"doubleTapped","buttons")
    devLoop (settings?.buttonsrelease,"released","buttons")
    devLoop (settings?.buttons,"button","buttons")  
     //sensors 
    devLoop (settings?.contactsensors,"contact","sensorDevices")
    devLoop (settings?.tempsensors,"temperature","sensorDevices")
    devLoop (settings?.batterysensors,"battery","sensorDevices")
    devLoop (settings?.motionsensors,"motion","sensorDevices")
    devLoop (settings?.humiditysensors,"humidity","sensorDevices")
    devLoop (settings?.illuminancesensors,"illuminance","sensorDevices")
    devLoop (settings?.smokesensors,"smoke","sensorDevices")
    devLoop (settings?.presencesensors,"presence","sensorDevices")
    devLoop (settings?.powersensors,"power","sensorDevices")
    devLoop (settings?.voltagesensors,"voltage","sensorDevices")
    // thermostats
    devLoop (settings?.thermostats,"temperature","thermostatDevices")
    devLoop (settings?.thermostats,"heatingSetpoint","thermostatDevices")
    devLoop (settings?.thermostats,"coolingSetpoint","thermostatDevices")
    devLoop (settings?.thermostats,"thermostatMode","thermostatDevices")
    devLoop (settings?.thermostats,"thermostatFanMode","thermostatDevices")
    devLoop (settings?.thermostats,"supportedThermostatModes","thermostatDevices","thermostatModes")
    devLoop (settings?.thermostats,"supportedNestThermostatModes","thermostatDevices","thermostatModes") 
    devLoop (settings?.thermostats,"supportedThermostatFanModes","thermostatDevices","thermostatFanModes")
    devLoop (settings?.thermostats,"supportedNestThermostatFanModes","thermostatDevices","thermostaFantModes")
    devLoop (settings?.thermostats,"thermostatOperatingState","thermostatDevices")
    devLoop (settings?.mqtttext,"text","otherDevices")
    devLoop (settings?.mqtttext,"prefix","otherDevices")
    devLoop (settings?.mqtttext,"suffix","otherDevices")
    devLoop (settings?.refresh,"suffix","otherDevices")
    
    settings?.refresh.each { dev ->
            if (dev.hasCommand ("refresh")) {
                normName=normalize(dev.displayName)
            	sTopic="homie/${atomicState.normHubName}/${normName}"
                addProperty(sTopic,'refresh',dev)
                mqtt.publishMsg (sTopic+'/refresh','false',1,true)
                mqtt.publishMsg (sTopic+'/refresh/$datatype','boolean',1,true)
                mqtt.publishMsg (sTopic+'/refresh/$settable','true',1,true)
                mqtt.publishMsg (sTopic+'/refresh/$name',dev.displayName,1,true)
                mqtt.publishMsg (sTopic+'/refresh/$retained','true',1,true)
            }
    }
    settings?.ramp.each { dev ->
        normName=normalize(dev.displayName)
        sTopic="homie/${atomicState.normHubName}/${normName}"
            if (dev.hasCommand ("setLevel")) {
                addProperty(sTopic,'ramp',dev)
                sRamp=dev.getDataValue("[MQTT]_ramp")  // this is last stored ramp value 
                if ((sRamp!=null) && (sRamp!='') && (sRamp!=' ')) mqtt.publishMsg (sTopic+'/ramp',sRamp,1,true)
                mqtt.publishMsg (sTopic+'/ramp/$datatype','string',1,true)
                mqtt.publishMsg (sTopic+'/ramp/datatype','json',1,true)
                mqtt.publishMsg (sTopic+'/ramp/$format','{"level": xx,"ramp": xx}',1,true)
                mqtt.publishMsg (sTopic+'/ramp/$settable','true',1,true)
                mqtt.publishMsg (sTopic+'/ramp/$name',dev.displayName,1,true)
                mqtt.publishMsg (sTopic+'/ramp/$retained','true',1,true)
            }
    }
        

	if (publishList.size() != 0) {
    log(">>>>>>>>>>>>>>>>>>>>>   Publish List is $publishList","LOG")
    //publishList.each {k, v -> HADiscoveryAdvertise(v[0],v[1],v[2], k) }
    }
}


def devLoop(deviceList, attribute, handler, type='none'){  // This registers a single 'named' attribute for a device  
        mqtt = getChildDevice("MQTT: Child device driver")
		deviceList.each{ dev->
            
			mydName = dev.displayName
			myName = dev.displayName
                normName=normalize(myName)
            	sTopic="homie/${atomicState.normHubName}/${normName}"
                mqtt.publishMsg (sTopic+'/-device-driver',dev.typeName,1,true)

            
            
            
            
                def attrs = dev.supportedAttributes  //this gets all attributes in variable, custom etc
            if (type == 'none') type=attribute
			if(dev.currentValue(attribute)!=null){
				log ("## " + dev.displayName + " $attribute  ${dev.currentValue(attribute)}","TRACE") // + ${attrs}
				if (attrs.size()>1) multiple=true else multiple=false // TODO BUG Need to handle multiple attributes here
                log ("#### $attribute sensor #### ${myName} has attributes ${attrs}","TRACE")  // not all are sensors

                if(handler=="sensorDevices") sensorDevices(null, myName, type, dev.currentValue(attribute),dev,multiple)
                else if (handler=="thermostatDevices") thermostatDevices(null, myName, type, dev.currentValue(attribute),dev,multiple)
                else if (handler=="switched") switched(null, myName, type, dev.currentValue(attribute),dev) //,multiple)
                else if (handler=="dimmed") dimmed(null, myName, type, dev.currentValue(attribute),dev) //,multiple)
                else if (handler=="switchedDim") switchedDim(null, myName, type, dev.currentValue(attribute),dev) //,multiple)
                else if (handler=="buttons") buttons(null, myName, type, dev.currentValue(attribute),dev) //,multiple,dev.id)
                else if (handler=="otherDevices") otherDevices(null, myName, type, dev.currentValue(attribute),dev) //,multiple)
                else if (handler=="locked") locked(null, myName, type, dev.currentValue(attribute),dev) //,multiple,dev.id)
                else if (handler=="keypadDevices") keypadDevices(null, myName, type, dev.currentValue(attribute),dev) //,multiple)
                else if (handler=="audioDevices") audioDevices(null, myName, type, dev.currentValue(attribute),dev) //,multiple)
			}
            
            else log("No [" + attribute + "] attribute value available for [${myName}]", "DEBUG")
		}
}


def devLoopAll(dev, attribute, handler, type='none'){  // This registers all attributes for a device
    if (dev != null){
        mqtt = getChildDevice("MQTT: Child device driver")
//		deviceList.each{ dev->
			mydName = dev.displayName
			myName = dev.displayName
                normName=normalize(myName)
            	sTopic="homie/${atomicState.normHubName}/${normName}"
                mqtt.publishMsg (sTopic+'/-device-driver',dev.typeName,1,true)
                // iattrs = dev.supportedAttributesf (attribute=='all' && handler=="sensorDevices") { //Only use this for sensors - adds all attributes to device    
                def attrs = dev.supportedAttributes
                if (attrs.size()>1) multiple=true else multiple=false // TODO BUG Need to handle multiple attributes here        //jeff      
                if (attribute=='all' && handler=="sensorDevices") { //Only use this for sensors - adds all attributes to device
                    attrs.each { attr ->
                        sensorDevices(null, myName, "$attr", dev.currentValue("$attr"),dev,multiple)
                    }
                    return
                }
                else if (attribute=='all' && handler=="thermostatDevices") { 
                    attrs.each { attr ->
                        thermostatDevices(null, myName, "$attr", dev.currentValue("$attr"),dev,multiple)
                    }
                    return
                }
                else log ("Attribute $attribute passed to devLoop2" , "LOG")
        
/*  
            if (type == 'none') type=attribute
			if(dev.currentValue(attribute)!=null){
				log ("## " + dev.displayName + " $attribute  ${dev.currentValue(attribute)}","TRACE") // + ${attrs}
				if (attrs.size()>1) multiple=true else multiple=false // TODO BUG Need to handle multiple attributes here
                log ("#### $attribute sensor #### ${myName} has attributes ${attrs}","TRACE")  // not all are sensors

                if(handler=="sensorDevices") sensorDevices(null, myName, type, dev.currentValue(attribute),dev,multiple)
                else if (handler=="thermostatDevices") thermostatDevices(null, myName, type, dev.currentValue(attribute),dev.id,multiple)
                else if (handler=="switched") switched(null, myName, type, dev.currentValue(attribute),dev.id) //,multiple)
                else if (handler=="dimmed") dimmed(null, myName, type, dev.currentValue(attribute),dev.id) //,multiple)
                else if (handler=="switchedDim") switchedDim(null, myName, type, dev.currentValue(attribute),dev.id) //,multiple)
                else if (handler=="buttons") buttons(null, myName, type, dev.currentValue(attribute),dev.id) //,multiple,dev.id)
                else if (handler=="otherDevices") otherDevices(null, myName, type, dev.currentValue(attribute),dev.id) //,multiple)
                else if (handler=="locked") locked(null, myName, type, dev.currentValue(attribute),dev.id) //,multiple,dev.id)
                else if (handler=="keypadDevices") keypadDevices(null, myName, type, dev.currentValue(attribute),dev.id) //,multiple)
                else if (handler=="audioDevices") audioDevices(null, myName, type, dev.currentValue(attribute),dev.id) //,multiple)
			}
            
            else log("No [" + attribute + "] attribute value available for [${myName}]", "WARN")
//		}
        
        */

	}
    else log ("Null Device passed to devLoop2","TRACE")
}


def stateTopics(evt) {  // Returns names of all registered state topics for adhoc devices
	log ("Got topic ${evt.value}","DEBUG")
	subscribeOneOffTopics(evt.value)
}
    
def mqttOnline(evt) {
       if (evt.value=="present") atomicState.MQTTconnected=true
       else atomicState.MQTTconnected=false      
}

def maptopics2() {    
}

def mapTopics(evt) {  	
	def tempMap=atomicState.topicMap
	def content=[:]
	def data = parseJson(evt.data)
	log ("Topic mapped key " + data.level + " to " + data.state + " with " + data.valueMax, "DEBUG")
	if (data.valueMax!=null) valueMax=data.valueMax else valueMax='?'
	if (data.stateON!=null) valueON=data.stateON else valueON='?'
	if (data.stateOFF!=null) valueOFF=data.stateOFF else valueON='?'		
	content=[topic: data.state,maxValue : valueMax, stateON: data.stateON, stateOFF: data.stateOFF, type: "dim"]
	tempMap[data.level]=content
	content=[topic: data.state, maxLevel: valueMax, stateON: data.stateON, stateOFF: data.stateOFF, type: "onoff"]
	tempMap[data.state]=content   // this creates an entry for the switch part of a dimmer so states are available
	atomicState.topicMap = tempMap
		for (e in tempMap) {
    		//log ( "[topic]: key = ${e.key}, value = ${e.value}","ERROR")
		}
}

def varChange(evt) {  // for an enabled Omni Device with variable attribute (globalVars)
			index=0
        mqtt = getChildDevice("MQTT: Child device driver")
			for (String item : settings?.globVars) { 
			if (item == evt.displayName){
                log ("Matched item [" + index + "] "  + index, "TRACE")
                sTopic=sTopic="homie/${atomicState.normHubName}/${normalize(evt.displayName)}/variable"
				mqtt.publishMsg (sTopic,evt.value,1,true)  
				}
			index++
	}
    	    index=0
			for (String item : settings?.gVars) { 
			if (item == evt.displayName){
                log ("Matched item [" + index + "] "  + index, "TRACE")
                sTopic=sTopic="homie/${atomicState.normHubName}/${normalize(evt.displayName)}/variable"
				mqtt.publishMsg (sTopic,evt.value,1,true)  
				}
			index++
	}
}

private logDebug(msg) {
	if (settings?.debugOutput || settings?.debugOutput == null) {
		log ("$msg", "DEBUG")
	}
}

private determineLogLevel(data) {

    switch (data?.toUpperCase()) {
        case "TRACE":
            return 0
            break
        case "DEBUG":
            return 1
            break
        case "INFO":
            return 2
            break
        case "WARN":
            return 3
            break
        case "ERROR":
        	return 4
            break
		case "DISABLED":
		    return 5
			break
        case "RED":
        case "BLUE":
        case "GREEN":
        case "YELLOW":
        case "ORANGE":
        case "KGREEN":
        case "KORANGE":
        case "KYELLOW":
        case "LOG":
        case "KH":
            return 6
            break
        default:
            return 1
    }
}

def topicPayload(value,status,topic) {
    mqtt = getChildDevice("MQTT: Child device driver")
	if (value!='#NoNe#'){
		log ('Acknowledge $property exists',"TRACE")
	}
	if (atomicState.Category=='') {
		log ("Blank category","DEBUG")
		return
	}
	//def data = parseJson(evt.data)	
	if (status.contains(atomicState.Category)){
		log ("${atomicState.Category}  already exists in ${status}","DEBUG")
		return
	}
	log  ("RX:  $value  /  ${status[]}  /  $topic  +  ${atomicState.Category}","DEBUG") 
	if (value=="#NoNe#") first='' else first=","
	mqtt.publishMsg (topic, status.join(",") + first + atomicState.Category,1,true,atomicState.suppress)
	log ("Publishing to $topic payload is ${status.join(",") + first + atomicState.Category}","DEBUG")
	atomicState.Category=''	
}

def HADiscoveryAdvertise (name, type="none", category="none", id='0', payON="true",payOFF="false",nameSuffix='',UOM='') {  // payON and payOFF vary a lot for sensors so need extra params) {
    if (!settings?.HADiscovery) return   // && HAtype!='?')
    if (HAtype=='unknown'){
        if (!atomicState.myHub)log ("$name not supported for HA Discovery","DEBUG")
        else log ("$name not supported for HA Discovery","LOG")
        return
    }
    if (category=='block'){
        log ("Blocking advertising dimmer $name as a switch to HA ","TRACE")
        return
    }
    //if (nameSuffix!=null) log ("NameSuffix at HA advertise was not removed: $name[$nameSuffix]","KGREEN")
	normName = normalize(name+nameSuffix)
    //normName = normalize(name)
	log ("Advertising ${name} device ${type} ${category} to HA with ID $id","TRACE")
    if (id==0) log ("The ID for device $name $type was 0","WARN")
	//if (nameMap.containsValue(name)) log ("Found in nameMap " + name, "LOG") else log ("NOT Found in nameMap " + name, "LOG")
		sTopic="homie/${atomicState.normHubName}/${normName}"+'/onoff'   //TODO tidy
        pAvail=',"availability_topic":"homie/' + "${atomicState.normHubName}" + '/$state"'
        pAvailPay=',"payload_available":"ready"'
        pNotAvailPay=',"payload_not_available":"init"'
        if (name=="vFan") name="vFantastic"
		pName = '"name":"'+name+nameSuffix+'"'
        
		pUID = ',"unique_id":"Hubitat-MQTT:_' + normName + '"'
		pDevClass=''
		payload=''
        pID=''
    String ID = "${id}"
    if (ID != '0') {
        pID= ',"device": {"identifiers": "HE_'+ ID + '","name": "'+name+ '","sw_version":"pre 21 beta 3e","model":"'+"${atomicState.normHubName}"+'","manufacturer":"Hubitat"}'  // TODO Investigate if this can work
    }
    else log ("ID is 0 for device $name  $type","WARN")
		pON = ',"payload_on":"true"'  //default for booleans in homie
		pOFF = ',"payload_off":"false"'
    
    
    
    if (type=="fan") {
        pFanMode=''
        pFanCmd=''
        pFanModes=''
        pMode=''
        pModeCmd=''
        pModes=''
        pSetpointCmd=''
        pHSetpointCmd=''
        pCSetpointCmd=''
        
        //pDevClass = ',"device_class": "fan"'
        pDevClass=''
        sFanTopic="homie/${atomicState.normHubName}/${normName}/speed"
        pCmd = ',"command_topic": "' + sFanTopic + '/set"'
        pStatus = ',"state_topic": "' + "homie/${atomicState.normHubName}/${normName}/onoff"+'"'
        pSpeedMode = ',"speed_state_topic": "' + sFanTopic +'"'
        pSpeedCmd = ',"speed_command_topic": "' + sFanTopic + '/set"'
        //pSpeedModes = ',"speeds": "' + sFanTopic + '/$format"'
        pSpeedModes = '' 
        pSpeedModes=',"speeds": ["low","medium-low","medium","medium-high","high","auto","on","off"]'
        pSpeedLow = ',"payload_low_speed": "low"'
        pSpeedMed = ',"payload_medium_speed": "medium"'
        pSpeedHigh = ',"payload_high_speed": "high"'
     
        


       // [“auto”, “off”, “cool”, “heat”, “dry”, “fan_only”]
        
        pState = ',"state_topic":"'+ sTopic + '"'
        pState = ''
        pON= ',"payload_on": "on"'
        pOFF= ',"payload_off": "off"'
        pUOM=''
        //pON
        //pOFF
        //pIcon
        //pDev
        //pValTemp
        //pID 
        payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pDevClass+pCmd+pON+pOFF+pStatus+pSpeedMode+pSpeedCmd+pSpeedModes+pSpeedLow+pSpeedMed+pSpeedHigh+'}'   
    } 

    else if (type=="climate") {
        pFanMode=''
        pFanCmd=''
        pFanModes=''
        pMode=''
        pModeCmd=''
        pModes=''
        pSetpointCmd=''
        pHSetpointCmd=''
        pCSetpointCmd=''
        //pName = '"name":"'+name+nameSuffix+'"'
        pName = '"name":"'+name +'"'
        
        pDevClass = ',"device_class": "climate"'
        pCurrTemp = ',"current_temperature_topic": "homie/'+"$atomicState.normHubName/$normName" + '/measure-temperature"'
        
        pSetpoint = ',"temperature_state_topic":"homie/'+"$atomicState.normHubName/$normName" + '/thermostat-setpoint"'
        pSetpointCmd = ',"temperature_command_topic": "homie/'+"$atomicState.normHubName/$normName" + '/thermostat-setpoint/set"'
        
        pHSetpoint = ',"temperature_high_state_topic": "homie/'+"$atomicState.normHubName/$normName" + '/cooling-setpoint"'
        pHSetpointCmd = ',"temperature_high_command_topic": "homie/'+"$atomicState.normHubName/$normName" + '/cooling-setpoint/set"'

        pCSetpoint = ',"temperature_low_state_topic": "homie/'+"$atomicState.normHubName/$normName" + '/heating-setpoint"'
        pCSetpointCmd = ',"temperature_low_command_topic": "homie/'+"$atomicState.normHubName/$normName" + '/heating-setpoint/set"'


        pFanMode = ',"fan_mode_state_topic": "homie/'+"$atomicState.normHubName/$normName" + '/fanmode"'
        pFanCmd = ',"fan_mode_command_topic": "homie/'+"$atomicState.normHubName/$normName" + '/fanmode/set"'
        //pFanModes = ',"fan_modes": "homie/'+"$atomicState.normHubName/$normName" + '/fanmodes/$format"'
      
        pMode = ',"mode_state_topic": "homie/'+"$atomicState.normHubName/$normName" + '/mode"'
        pModeCmd = ',"mode_command_topic": "homie/'+"$atomicState.normHubName/$normName" + '/mode/set"'
        //pModes = ',"modes": "homie/'+"$atomicState.normHubName/$normName" + '/$format"'
        //pModes=',"modes": "[“auto”, “off”, “cool”, “heat”]"'
        pValTemp=''
        if (tempUnits=="Celsius x.x°C")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
        else if (tempUnits=="Fahrenheit x.x°F")	pValTemp = ',"value_template":"{{ value | round(1) }}"'


       // [“auto”, “off”, “cool”, “heat”, “dry”, “fan_only”]
        
        pState = ',"state_topic":"'+ sTopic + '"'
        pState = ''
        pON=''
        pOFF=''
        pUOM=''
        //pON
        //pOFF
        //pIcon
        //pDev
        //pValTemp
        //pID 
        //pValTemp = ',"value_template":"{{ value | round(0) }}"'  // acts as convert to int
        payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pDevClass+pState+pUOM+pON+pOFF+pIcon+pValTemp+pID+pCurrTemp+pSetpoint+pSetpointCmd+pHSetpoint+pHSetpointCmd+pCSetpoint+pCSetpointCmd+pFanMode+pFanCmd+pFanModes+pMode+pModeCmd+pModes+pDev+'}'        
    } 
	else if (type=="switch"|type=="light") {
            sDimTopic="homie/${atomicState.normHubName}/${normName}"+'/dim'
		    sColorTopic="homie/${atomicState.normHubName}/${normName}"+'/color'
			pState = ',"state_topic":"'+ sTopic + '"'
			pCmd = ',"command_topic":"'+ sTopic + '/set"'
			pUOM = ''
			//pON = ',"payload_on":"'+payON+'"'   // Is this ever needed ?
			//pOFF = ',"payload_off":"'+payOFF+'"'
			pIcon = '' // ',"icon":"mdi:power"'
			pDev = ''
			pValTemp = ',"value_template":"{{ value }}"'
			if (type=="switch") payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pUOM+pON+pOFF+pIcon+pDev+pValTemp+pID+'}'
			if (type=="light") {
				pOnType = ',"on_command_type":"first"'
				pBriState = ',"brightness_state_topic":"' + sDimTopic + '"'
				pBriCmd = ',"brightness_command_topic":"' + sDimTopic + '/set"'
				pBriTemp= ',"brightness_value_template":"{{ value }}"'
				pBriScale = ',"brightness_scale":100'
				if (category=="colour") {
					pColState = ',"color_temp_state_topic": "' + sColorTopic + '-temperature/temp"'
					pColTempCmd = ',"color_temp_command_topic": "' + sColorTopic + '-temperature/set"'
					//pColTempVal = ',"color_temp_value_template": "{{ ((value | float / 100) * (500 - 153)) + 153  }}"'  
					pColTempVal = ',"color_temp_value_template": "{{ value | round(0)  }}"'  //@jwilliams
                    //pHSState = ',"hs_state_topic": "' + sColorTopic + '/hsv"'
                    pHSState = ',"hs_state_topic": "' + sColorTopic +'"'
					pHSCmd = ',"hs_command_topic": "' + sColorTopic + '/set"'
					//pHSValTemp = ',"hs_value_template": "{{ value_json.h }},{{ value_json.s }}"'
                    pHSValTemp = ',"hs_value_template":"' + "{{value.split(',')[0]}},{{value.split(',')[1]}}" + '"'
					HAtype="light"  // for discovery
					payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pUOM+pON+pOFF+pIcon+pDev+pValTemp+pOnType+pBriState+pBriCmd+pBriTemp+pBriScale+pColState+pColTempCmd+pColTempVal+pHSState+pHSCmd+pHSValTemp+pID+'}'
				}
				else payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pUOM+pON+pOFF+pIcon+pDev+pValTemp+pOnType+pBriState+pBriCmd+pBriTemp+pBriScale+pID+'}'
			}
		}	
		else if (type=="binary_sensor" | type=="sensor") {
			 // TODO Look at why this is different to above and combine if poss
            sSensTopic="homie/${atomicState.normHubName}/${normalize(name)}"  // the suffix is not used here
			sTopic=sSensTopic+'/'+category
			//pName = '"name":"'+name+'"'
			//pON = ',"payload_on":"'+payON+'"'  // Is this ever needed
			//pOFF = ',"payload_off":"'+payOFF+'"'
			//pDevClass=''
			pState = ',"state_topic":"'+ sTopic + '"'
		
			//if (UOM!='') pUOM = ',"unit_of_measurement":"'+UOM+'"' else pUOM=''
			pIcon = '' // ',"icon":"mdi:power"'
			pDev = ''
			pValTemp = ',"value_template":"{{ value }}"'
			if (type=="binary_sensor") {
				// HA categories for various binary sensors https://www.home-assistant.io/components/binary_sensor/
				// TODO must map binary_sensor payload values to ON OFF
				if (category == "motion") pDevClass = ',"device_class": "motion"'
				else if (category == "contact") {
					pDevClass = ',"device_class": "opening"'  
					//pState = ',"state_topic":"'+ sTopic + '/status"'  // Here we are electing between onoff boolean and the status name e.g active/inactive. Using true:false as HA templates value anyway
				}
				else if (category == "smoke-alarm") pDevClass = ',"device_class": "smoke"'
				else if (category == "carbonMonoxide-alarm") pDevClass = ',"device_class": "gas"'
                else if (category == "presence-sensor") pDevClass = ',"device_class": "presence"'
				else if (category == "water") pDevClass = ',"device_class": "moisture"'
                else if (category == "door") pDevClass = ',"device_class": "door"'                  
                else pDevClass = ',"device_class": "notHandled"'
				//else if (category == "battery") pDevClass = ',"device_class": "battery"'  // LOW/OK indicator, perhaps set if < 10%
				//pON = ',"payload_on":"'+payON+'"'  //TODO check if this is ever needed for boolean sensors - will be for enum
				//pOFF = ',"payload_off":"'+payOFF+'"'   //TODO need a selector here
				pUOM=''
			}
			if (type=="sensor") {
				pUOM=',"unit_of_measurement": "'+UOM+'"'
				pON=''  // remove on:off states from sensor adverts ? Do I need to be more selective say with some (analogue?) 'sensors' that might also have an on:off state ? TODO check
				pOFF=''
                pValTemp = ',"value_template":"{{ value | round(0) }}"'  // acts as convert to int
				if (category == "measure-temperature")  { 
				    pDevClass = ',"device_class": "temperature"'
				    if (tempUnits=="Celsius x.x°C")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
                    else if (tempUnits=="Fahrenheit x.x°F")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
				}
                else if (category == "measure-battery") pDevClass = ',"device_class": "battery"'
                else if (category == "illuminance") pDevClass = ',"device_class": "illuminance"'
                else if (category == "signal_strength") pDevClass = ',"device_class": "signal_strength"'
                else if (category == "humidity") pDevClass = ',"device_class": "humidity"'
                else if (category == "power") pDevClass = ',"device_class": "power"'
                else if (category == "timestamp") pDevClass = ',"device_class": "timestamp"'
                else if (category == "pressure") pDevClass = ',"device_class": "pressure"'
			}				
			payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pDevClass+pState+pUOM+pON+pOFF+pIcon+pDev+pValTemp+pID+'}' 			
		}
    //Casey <
        else if (type=="lock") {
            sLockTopic="homie/${atomicState.normHubName}/${normName}"+'/lock'  //Casey
			pState = ',"state_topic":"'+ sLockTopic + '"'
			pCmd = ',"command_topic":"'+ sLockTopic + '/set"'
    		pLock = ',"payload_lock":"true"'  //default for booleans in homie
	    	pUnlock = ',"payload_unlock":"false"'
            pLocked=',"state_locked":"true"'  //default for booleans in homie
            pUnlocked=',"state_unlocked":"false"'  //default for booleans in homie
			pUOM = ''
			pIcon = '' // ',"icon":"mdi:lock"'
			pDev = ''
			pValTemp = ',"value_template":"{{ value }}"'
			payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pUOM+pLock+pUnlock+pLocked+pUnlocked+pIcon+pDev+pValTemp+pID+'}'
    }
    else if (type=="shade") {
        sCoverTopic="homie/${atomicState.normHubName}/${normName}"+'/onoff'
        sCover2Topic="homie/${atomicState.normHubName}/${normName}"+'/state'
        sCover3Topic="homie/${atomicState.normHubName}/${normName}"+'/position'
        // Need to add the 0-100 position attribute in here //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        pState = ',"state_topic":"'+ sCover2Topic + '"'
        pCmd = ',"command_topic":"'+ sCover2Topic + '/set"'
        pPos= ',"position_topic":"'+ sCover3Topic +'"'
        pPosCmd= ',"set_position_topic":"'+ sCover3Topic + '/set"'
        pCLOSE = ',"payload_close":"close"' //default for booleans in homie
        pOPEN = ',"payload_open":"open"'
        pSTOP = ', "payload_stop": null '
        pUOM = ''
        pIcon = '' // ',"icon":"mdi:garage"'
        pDev = ''
        pValTemp = ',"value_template":"{{ value }}"'
        payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pPos+pPosCmd+pUOM+pOPEN+pSTOP+pCLOSE+pIcon+pDev+pValTemp+pID+'}'
        type='cover'  //revert to cover
    } 
    else if (type=="cover") {
        sCoverTopic="homie/${atomicState.normHubName}/${normName}"+'/window'
        sCover2Topic="homie/${atomicState.normHubName}/${normName}"+'/door'
        pState = ',"state_topic":"'+ sCover2Topic + '"'
        pCmd = ',"command_topic":"'+ sCover2Topic + '/set"'
        pCLOSE = ',"payload_close":"close"' //default for booleans in homie
        pOPEN = ',"payload_open":"open"'
        pSTOP = ', "payload_stop": null '
        pUOM = ''
        pIcon = '' // ',"icon":"mdi:garage"'
        pDev = ''
        pValTemp = ',"value_template":"{{ value }}"'
        payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pUOM+pOPEN+pSTOP+pCLOSE+pIcon+pDev+pValTemp+pID+'}'
    }
    else if (type=="alarm_control_panel") {
            sAlarmTopic="homie/${atomicState.normHubName}/${normalize(name)}/securitymode"  // the suffix is not used here
			pState= ',"state_topic":"' + sAlarmTopic+'"'
			pCmd = ',"command_topic":"' + sAlarmTopic+'/set"'
			pDisarm = ',"payload_disarm":"disarm"'
			pArmHome = ',"payload_arm_home":"armed home"'
			pArmAway = ',"payload_arm_away":"armed away"'
			pArmNight = ',"payload_arm_night":"armed night"'
			pCodeArm = ""
			pCodeDisarm = ""
			pCodeArmTemplate = ""
            pKeyCode=""
			if (mqttKeypadMode == "No control of keypad" || mqttKeypadMode == "No Keycode needed") {
			    pCodeArm = ',"code_arm_required": "false"'                
			}
			else {
			    if (mqttKeypadMode == "Keycode to Arm only") {
					pCodeArm = ',"code_arm_required": "true"'
					pCodeDisarm = ',"code_disarm_required": "false"'
				} else {
                    pCodeArm = ',"code_arm_required": "true"'
					pCodeDisarm = ',"code_disarm_required": "true"'
				}		
				pCodeArmTemplate = ',"command_template":"{{action}},{{code}}"'
			}
			if (mqttKeypadCode != null) {
			    pKeyCode = ',"code":"' + mqttKeypadCode.trim() + '"'
			}			        
			payload = '{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pCodeArm+pCodeDisarm+pCodeArmTemplate+pKeyCode+pDisarm+pArmHome+pArmAway+pArmNight+pDev+pID+'}'
		}    
        else
        { 
            if (type=="button") log( "Buttons are not supported in HA Discovery","TRACE")
            else if (type=="unknown") log ("Unknown Device type $type presented for HA MQTT Discovery advertise from device $name","INFO")
            else log ("Unknown Device type $type presented for HA MQTT Discovery advertise from device $name","WARN")
        }
        //Casey >
        if (pDevClass=='opening' && category=="contact" && type=="binary_sensor") log ("Blocked HA Discovery for device $normName","WARN")
        else {
		   // if (payload.size()>1 ){  // shouldnt need this anymore although I see sensors keep sensing when activated 
	        if (payload.size()>1 ) {
                mqtt = getChildDevice("MQTT: Child device driver")
			    log ("Sending Discovery: message "+ name + " "  + payload, "TRACE") 
			    if (settings?.HARemember=="Remember") mqtt.publishMsg ("${settings?.HADiscoveryTopic}/${type}/$id/${normName}/config", payload.toString(),1,true)
			    else mqtt.publishMsg ("${settings?.HADiscoveryTopic}/${type}/$id/${normName}/config", payload)
		}
        }    
}	

def log(data, type) {
	data = "MQTT: ${data ?: ''}"
    if (determineLogLevel(type) >= determineLogLevel(settings?.logging ?: "INFO")) {
        switch (type?.toUpperCase()) {
            case "TRACE":
                log.trace "${data}"
                break
            case "DEBUG":
                log.debug "${data}"
                break
            case "INFO":
                log.info "${data}"
                break
            case "WARN":
                log.warn "${data}"
                break
            case "ERROR":
                log.error "${data}"
                break
			case "DISABLED":
			    break
            case "BLUE":
                log.info "<font color='blue'>${data}</font>"
                break
            case "RED":
                log.info "<font color='red'>${data}</font>"
                break
            case "ORANGE": //silly but BGREEN not working
                log.info "<font color='Green'><b>${data}</font></b>"
                //log.info "<font color='orange'>${data}</font>"
                break
            case "GREEN":
                log.info "<font color='green'>${data}</font>"
                break
            case "BGREEN":
                log.info "<font color='Green'><b>${data}</font>,/b."
                break
            case "YELLOW":
                log.info "<font color='yellow'>${data}</font>"
                break
            case "KGREEN":
                 if (atomicState.myHub) log.trace "<font color='green'>${data}</font>"
                 break           
            case "KYELLOW":
                 if (atomicState.myHub) log.trace "<font color='yellow'>${data}</font>"
                 break
            case "KORANGE":
                 if (atomicState.myHub) log.trace "<font color='orange'>${data}</font>"
                 break
            case "KH":
                 if (atomicState.myHub) log.trace "<font color='red'>${data}</font>"
                 break
            case "LOG":
                 if (atomicState.myHub) log.trace "<font color='blue'>${data}</font>"
                 break
            default:
                log.error "MQTT: -- ${data.label} -- Invalid Log Setting"
        }
    }
}

private removeAllChildDevices() {  
	getChildDevices().each { deleteChildDevice(it.deviceNetworkId) }
	log ("Deleted all child devices", "WARN")
}

private removeAllDiscoveredChildDevices() {  
	getChildDevices().each  {
       // mqttval= it.getDataValue("mqtt")
        try{
        origin=it.getDataValue("origin")
            if (origin!="user") {
                if (it.getTypeName()=="MQTT Client") { 
                   log ("Keeping MQTT client driver","INFO")
                } 
                else deleteChildDevice(it.deviceNetworkId)
            }
            else log ("Saved this user created device $it.displayName","TRACE")           
        }
        catch (e) {
            log (" Delete all discovered child devices failed + $e","ERROR")
            return
            }      
    }
     log (" Deleted all discovered child devices ","WARN")
}

//#######################################################################################################################################
//#######################################   This section handles subscriptions to MQTT topics   #########################################
//#######################################################################################################################################


def subscribeShellyTopic() {
	//log ("Adding Shelly status topics","INFO") //
	//mqtt.subscribeTopic('shellies/#')
    mqtt = getChildDevice("MQTT: Child device driver")
    mqtt.subscribeTopic('shellies/+/onlineRet') // /online  is no use here as is not a retained or updated topic used in LWT (bug in Shelly)
}
def subscribeSonoffTopic() {
	log ("Adding Sonoff property and node subscription topics [Not Yet implemented]","INFO")
	//mqtt.subscribeTopic('homie/'+atomicState.homie+'/$nodes')
}

def subscribeHomieTopic() {
    mqtt = getChildDevice("MQTT: Child device driver")
    atomicState.timeStamp=now()
    log ("================ Starting homie Discovery =================", "BLUE")
    mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$discovery',"homie",1,true)
    atomicState.progress = now()
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/$nodes')
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/$properties')  //Started using this 
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/$type')      //TODO from here could get a device > type list as this returns all devices with a type
    mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
    pacingSet("homieEnd")
    //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"homieEnd",1,false)
}

def subscribeHAInTopic() {
    mqtt = getChildDevice("MQTT: Child device driver")
    atomicState.timeStamp=now()
    log ("================  Starting HA incoming Discovery  ================", "BLUE")
    mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$discovery',"HA In",1,true)
    mqtt.setHAInDiscovery(true)
    atomicState.progress = now()
	//mqtt.subscribeTopic(atomicState.haIn+'/switch')
	mqtt.subscribeTopic(settings?.HAInTopic+'/+/+/config')  //two topic constructs
	mqtt.subscribeTopic(settings?.HAInTopic+'/+/+/+/config') 
    //mqtt.subscribeTopic(settings?.HAInTopic+'/+/+/+/+/config')
    mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
    pacingSet("HAInEnd")
    //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"HAInEnd",1,false)
}
def subscribezigbee2mqttTopic() {
    mqtt = getChildDevice("MQTT: Child device driver")
    atomicState.timeStamp=now()
    log ("Starting Zigbee2mqtt Discovery", "BLUE")
    atomicState.progress = now()
	log ("Adding Zigbee2mqtt subscription topics for " + settings?.zigbee2mqttTopic, "INFO")
	//mqtt.subscribeTopic(atomicState.haIn+'/switch')
	mqtt.subscribeTopic(settings?.zigbee2mqttTopic+'/+')
    mqtt.subscribeTopic(settings?.zigbee2mqttTopic+'/bridge/devices')
	//mqtt.subscribeTopic(settings?.zigbee2mqttTopic+'/+/+/+/config')    
}
def subscribezwave2mqttTopic() {
    mqtt = getChildDevice("MQTT: Child device driver")
    atomicState.timeStamp=now()
    log ("Starting Zwave2mqtt Discovery", "BLUE")
    atomicState.progress = now()
	log ("Adding Zwave2mqtt incoming subscription topics for " + settings?.zwave2mqttTopic, "INFO")
	//mqtt.subscribeTopic(atomicState.haIn+'/switch')
	mqtt.subscribeTopic(Settings?.zwave2mqttTopic+'/+')  
	//mqtt.subscribeTopic(settings?.zwave2mqttTopic+'/+/+/+/config')    
}

def subscribeCBusTopic() {
    mqtt = getChildDevice("MQTT: Child device driver")
    atomicState.timeStamp=now()
    atomicState.timeStamp=now()
    log ("=====================  Starting CB Discovery =====================","BLUE")
    mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$discovery',"C-Bus",1,true)
    atomicState.progress = now()
	log ("Adding C-Bus incoming subscription topics for " + settings?.CBusTopic, "INFO")
	//mqtt.subscribeTopic(settings?.CBusTopic+'/+/state')
    mqtt.subscribeTopic(settings?.CBusTopic+'/read/254/56/+/group')   //discover from this
    //mqtt.subscribeTopic(settings?.CBusTopic+'/read/254/56/+/level')   // events from this
    //mqtt.subscribeTopic(settings?.CBusTopic+'/read/254/56/+/state')
    mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
    pacingSet("CBusEnd")
    //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"CBusEnd",1,false)
}

def subscribeVirtuals() {
    log ("Subscribing to virtuals", "INFO")
            subscribes=[]
            getChildDevices().each { dev ->                 
                origin=dev.getDataValue("origin")
                if ((origin == "user")||(origin == "Home Assistant")||(origin == "homie")||(origin=="HA Discovery")||(origin=="C-Bus")) {
                    //if (origin=="Home Assistant") log ("HomeAssistant device " + dev, "KH")
                    myData=dev.getData()
                    
                    
   registerEventHandler(dev)
                    
                    
                    if (myData != null) myData.each { dat ->
                        //log ("dat is $dat and value is $dat.value and key is $dat.key","KH")
                        if ((dat.value=='')||(dat.value==' ')||(dat.value==null)) {
                            //empty data values
                        }
                        else{
                        if (dat.key.endsWith("_Topic")) {
                            jas=dat.value.indexOf("{")
                            topic=dat.value
                            subTopic=topic
                            json=''
                            if ((jas>0) && (dat.value.endsWith(':}'))){
                                subTopic=dat.value.substring(0, jas ) 
                               
                                json=dat.value.substring(jas)
                                     log ("Subtopic is JSON " + subTopic + " " + json,"DEBUG")
                            }
                            if (topic.length()>1) {
                                log ("Adding [$dev.name]subscribe to $subTopic","DEBUG")
                                subscribes.add(subTopic)
                            }
                   /*
                            if(temp.containsKey(topic)){ 
                             list=temp[topic]       //.add(topic)
                                if (list.contains("$dev.deviceNetworkId")) {
                                }
                                else {
                                    list.add ("$dev.deviceNetworkId")
                                    temp["$topic"]=list 
                                }
                            }
                            else {
                                list=["$dev.deviceNetworkId"]
                                temp["$topic"] = list
                            }
                      */
                            updateTopicLink(dev.displayName,topic,dev.deviceNetworkId)
                      /*
                             if(topicLink.containsKey(topic)){ 
                             list=topicLink[topic]       //.add(topic)
                                if (list.contains("$dev.deviceNetworkId")) {
                                }
                                else {
                                    list.add ("$dev.deviceNetworkId")
                                    topicLink["$topic"]=list 
                                }
                            }
                            else {
                                list=["$dev.deviceNetworkId"]
                                topicLink["$topic"] = list
                            }
                       */
                        }
                     }
                   }
                } 
            }
    log ("Subscribing to $subscribes.size individual device topics","INFO")
    devSubscribes (subscribes)
}

def devSubscribes(subs) {
    mqtt = getChildDevice("MQTT: Child device driver")
    subs.each { topic ->
        mqtt.subscribeTopic(topic)
    }
}

def subscribeHomieStateTopics() {  //TODO Getting returns from these before devices and topicLink are created - delay ??
    mqtt = getChildDevice("MQTT: Child device driver")
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/onoff')
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/dim')
    mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/dim/$format')  // to recover max_Level																							 
    mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/+/$unit')   
}

def subscribeHomieNameTopics() {
    mqtt = getChildDevice("MQTT: Child device driver") 
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/$name')
    //mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/name')  //using this as it returns after all other messages have arrived so know done
}

def start_HADiscovery(evt){
    if (!settings?.HARunEvery){
        log ("Skipping HA Discovery","INFO")
        if(settings?.HAInDiscovery && settings?.HAInRunEvery) HAInDiscovery()       
        else {
            devSummary()
            return
        }
    }
    else {
        HADiscovery (evt)
        if(settings?.HAInDiscovery && settings?.HAInRunEvery) HAInDiscovery()      
        devSummary()
    }
}

def unsubscribeCBusEvents(msg=true){
    if (msg) {
        time=(int) ((now()-atomicState.timeStamp)/1000) 
        log ("========== C-Bus Discovery has completed in $time secs  ==========","BLUE")
    }
        mqtt = getChildDevice("MQTT: Child device driver")
        mqtt.unsubscribeTopic(settings?.CBusTopic+"/read/254/56/+/group")
        //mqtt.unsubscribeTopic(settings?.CBusTopic+"cbus2/read/254/56/+/level
        //mqtt.unsubscribeTopic(settings?.CBusTopic+"cbus2/read/254/56/+/group")
}

def homieDiscovery() {
    	runIn(1, "subscribeHomieTopic")
		runIn(1, "subscribeHomieStateTopics")  
        runIn(1, "subscribeHomieNameTopics")
}

def unsubscribehomieEvents(msg=true) {
    if (msg) {
        time=(int) ((now()-atomicState.timeStamp)/1000) 
        log ("========== homie Discovery has completed in $time secs  ==========","BLUE")
    }
        mqtt = getChildDevice("MQTT: Child device driver")
        mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/+/$name')
        mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/+/+/$unit')
        mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/$nodes')
	    mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/+/$properties')   
	    mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/+/$type')     
	    mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/+/dim/$format')
        mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/+/dim')  // as we subscribe individually to nodes now
        mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/+/onoff')  // as we subscribe individually to nodes now  
}
def HADiscovery (evt) {
    mqtt = getChildDevice("MQTT: Child device driver")
    if ((evt==null)||(evt.value=="HAstart")){
       /*
        if (settings?.homieDiscovery) { // can unsubscribe from these now as no longer used   TODO must unsubscribe if run once too now
        unsubscribehomieEvents()
        }
*/
        //mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/name')
        atomicState.timeStamp=now()
        log ("=====================  Starting HA Discovery =====================","BLUE")
        mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$discovery',"HA  statestream",1,true)
    	if(settings?.HAStatestream){
		    log ("HA stateStream enabled", "INFO")
            delay=0
		    runIn (delay, "subscribeHADevices")
 	    }
        else {
            log ("Skipping HA stateStream MQTT discovery", "INFO")
            //mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/version')  //using this to as it returns after all other messages have arrived so know done
        }
    }
    else if(evt.value=="complete") { 
        time=(int) ((now()-atomicState.timeStamp)/1000)

        if(settings?.HAStatestream)  log ("===========  HA Discovery has completed in $time secs ===========","BLUE")
    }
	if (atomicState.abort) { 
            abort(6)  // check
            return
    }
}

def HAInDiscovery() {
    mqtt = getChildDevice("MQTT: Child device driver")
    if (settings?.HAinTopic!=null) mqtt.setHAInTopic(settings?.HAInTopic)
    runIn(1, "subscribeHAInTopic")
                                                                // TODO  Unsubscribe from these after a few minutes ???   As some update frequently
}
def zwave2mqttDiscovery() {
    runIn(1, "subscribezwave2mqttTopic")
}

def zigbee2mqttDiscovery() {
    runIn(1, "subscribezigbee2mqttTopic")
}

def CBusDiscovery() {
    runIn(1, "subscribeCBusTopic")
}
    
    
    

def subscribeHADevices(evt=null) {  // ToDo - these might benefit from pacing
    if (atomicState.HA==null){
        log ("There is no HA statestream topic configured","WARN")
        return
    }
    mqtt = getChildDevice("MQTT: Child device driver")
    mqtt.unsubscribeTopic('homie/'+atomicState.normHubName+'/$pacing') 
	log ("Adding HA sensors and binary_sensors Device_class topics ", "INFO")
    mqtt = getChildDevice("MQTT: Child device driver")
    mqtt.subscribeTopic(atomicState.HA+'/sensor/+/device_class') // // this creates device
	mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')// this creates device
    mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
    pacingSet("HADevClassEnd")
    //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"HADevClassEnd",1,false) // this will arrive when all the friendly names have arrived 


    // incomplete as a lot of HA devices are missing device_class and so need friendly_name for discovery too

}

def subscribeHADevices_friendlyNames1(){
    mqtt = getChildDevice("MQTT: Child device driver")
    // Now add these individually as discovery is based on device_class
    mqtt.unsubscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
    mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/device_class') // // this creates device
	mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')// this creates device
	log ("Adding HA switches friendly names topics ", "INFO")
    mqtt.subscribeTopic(atomicState.HA+'/switch/+/friendly_name')
    //mqtt.subscribeTopic(atomicState.HA+'/light/+/friendly_name')
    mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing') 
    pacingSet("HAFriendly1End")
    //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"HAFriendly1End",1,false) // this will arrive when all the friendly names have arrived 

}
def subscribeHADevices_friendlyNames2(){
    mqtt = getChildDevice("MQTT: Child device driver")
    mqtt.unsubscribeTopic('homie/'+atomicState.normHubName+'/$pacing') 
    log ("Adding HA remaining friendly names topics ", "INFO")
    mqtt.unsubscribeTopic(atomicState.HA+'/switch/+/friendly_name')
    log ("Adding HA lights friendly names topics ", "INFO")
    mqtt.subscribeTopic(atomicState.HA+'/light/+/friendly_name')
	mqtt.subscribeTopic(atomicState.HA+'/group/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/person/+/friendly_name')
	mqtt.subscribeTopic(atomicState.HA+'/input_boolean/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/cover/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/device_tracker/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/climate/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/lock/+/friendly_name')
    mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
    pacingSet("HAFriendly2End")
    //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"HAFriendly2End",1,false) // this will arrive when all the friendly names have arrived 

    //mqtt.subscribeTopic(atomicState.HA+'/sensor/+/friendly_name') // // this creates device
	//mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/friendly_name')  // TODO spread /delay a bit
    //runIn(10, "subscribeHADeviceEvents") 
    //mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/client') // this will run when all the friendly names have arrived       
    // Currently not discovering these :   
    //mqtt.subscribeTopic(atomicState.HA+'/automation/+/friendly_name')
    //mqtt.subscribeTopic(atomicState.HA+'media_player/+/friendly_name')
	//mqtt.subscribeTopic(atomicState.HA+'/persistent_notification/+/friendly_name')
    //mqtt.subscribeTopic(atomicState.HA+'/sun/+/friendly_name')
	//mqtt.subscribeTopic(atomicState.HA+'/updater/+/friendly_name')

}

def subscribeHASensorFriendly() {// This runs 10 secs after above currently
    mqtt = getChildDevice("MQTT: Child device driver")
    mqtt.unsubscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
    mqtt.unsubscribeTopic(atomicState.HA+'/light/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/group/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/person/+/friendly_name')
	mqtt.unsubscribeTopic(atomicState.HA+'/input_boolean/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/cover/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/device_tracker/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/climate/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/lock/+/friendly_name')

    log ("Adding HA sensor and binary_sensor friendly names topics ", "INFO")
    //Trying to replace these with individual subscribes
    mqtt = getChildDevice("MQTT: Child device driver")
	log ("No longer adding wildcarded HA switch, sensor, and light events topics", "INFO")
/*
    mqtt.subscribeTopic(atomicState.HA+'/switch/+/state')
	mqtt.subscribeTopic(atomicState.HA+'/light/+/state')
	mqtt.subscribeTopic(atomicState.HA+'/light/+/brightness')
*/
    mqtt.subscribeTopic(atomicState.HA+'/sensor/+/friendly_name') // // this also creates device if device_class was missing
//	mqtt.subscribeTopic(atomicState.HA+'/sensor/+/state')// TODO spread /delay a bit
//	mqtt.subscribeTopic(atomicState.HA+'/sensor/+/unit_of_measurement')// TODO spread /delay a bit
    mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/friendly_name')  // TODO spread /delay a bit
    
    mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing') 
    pacingSet ("HAEnd")
    //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"HAEnd",1,false) // this will arrive when all the friendly names have arrived 
    //mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/client') // this will run when all the friendly names have arrived 
//	mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/state') // TODO spread /delay a bit
	//mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')// TODO spread /delay a bit  // moved above as this creates device
/*
    mqtt.subscribeTopic(atomicState.HA+'/group/+/state')
	mqtt.subscribeTopic(atomicState.HA+'/input_boolean/+/state')
    mqtt.subscribeTopic(atomicState.HA+'/person/+/state')
    mqtt.subscribeTopic(atomicState.HA+'/cover/+/state')
    mqtt.subscribeTopic(atomicState.HA+'/cover/+/current_position')
*/
    //mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/version')  //using this to as it returns after all other messages have arrived so know done
    // Currently not handling state updates for these :   
    //mqtt.subscribeTopic(atomicState.HA+'/automation/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'/climate/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'/device_tracker/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'/lock/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'media_player/+/state')
	//mqtt.subscribeTopic(atomicState.HA+'/persistent_notification/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'/sun/+/state')
	//mqtt.subscribeTopic(atomicState.HA+'/updater/+/state')

}

def unsubscribeHADevices(msg=true) {
    //subscribeHADeviceEvents()  //??    why subscribe here ?
    
    mqtt = getChildDevice("MQTT: Child device driver")
    // Can't wildcard these as the subs were setup individually
	if (msg) log ("Unsubscribing from HA switches, lights and sensors friendly names topics ", "INFO")
    //mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/version')  //using this to as it returns after all other messages have arrived so know done    

    mqtt.unsubscribeTopic(atomicState.HA+'/switch/+/friendly_name')
	mqtt.unsubscribeTopic(atomicState.HA+'/light/+/friendly_name')
	mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/friendly_name') 
   // mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/device_class') 
	//mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')
	mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/friendly_name')  
	mqtt.unsubscribeTopic(atomicState.HA+'/group/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/person/+/friendly_name')
	mqtt.unsubscribeTopic(atomicState.HA+'/input_boolean/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/cover/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/device_tracker/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/climate/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/lock/+/friendly_name')

    mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/unit_of_measurement')
    
    mqtt.unsubscribeTopic(atomicState.HA+'/switch/+/device_class')
	mqtt.unsubscribeTopic(atomicState.HA+'/light/+/device_class')
	mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/device_class') 
    // mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/device_class')
	//mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')
	mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')
	mqtt.unsubscribeTopic(atomicState.HA+'/group/+/device_class')
    mqtt.unsubscribeTopic(atomicState.HA+'/person/+/device_class')
	mqtt.unsubscribeTopic(atomicState.HA+'/input_boolean/+/device_class')
    mqtt.unsubscribeTopic(atomicState.HA+'/cover/+/device_class')
    mqtt.unsubscribeTopic(atomicState.HA+'/device_tracker/+/device_class')
    mqtt.unsubscribeTopic(atomicState.HA+'/climate/+/device_class')
    mqtt.unsubscribeTopic(atomicState.HA+'/lock/+/device_class')
     // Currently not discovering these devices :   
    //mqtt.unsubscribeTopic(atomicState.HA+'/automation/+/friendly_name')
    //mqtt.unsubscribeTopic(atomicState.HA+'media_player/+/friendly_name')
	//mqtt.unsubscribeTopic(atomicState.HA+'/persistent_notification/+/friendly_name')
    //mqtt.unsubscribeTopic(atomicState.HA+'/sun/+/friendly_name')
	//mqtt.unsubscribeTopic(atomicState.HA+'/updater/+/friendly_name')
}



def unsubscribeHADeviceEvents(msg=true) {
    //if (atomicState.HA==null) return  // HA discovery not enabled
    //log ("Unsubscribing HA events","INFO")
    if (msg) {
    time=(int) ((now()-atomicState.timeStamp)/1000)
    log ("===========  HA Discovery has completed in $time secs ===========","BLUE")
    }
    mqtt = getChildDevice("MQTT: Child device driver")
    mqtt.unsubscribeTopic(atomicState.HA+'/switch/+/state')
	mqtt.unsubscribeTopic(atomicState.HA+'/light/+/state')
	mqtt.unsubscribeTopic(atomicState.HA+'/light/+/brightness')
    //mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/friendly_name') // // this also creates device if device_class was missing
	mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/state')// TODO spread /delay a bit
	//mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/unit_of_measurement')// TODO spread /delay a bit
	//mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/friendly_name')  // TODO spread /delay a bit
	mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/state') // TODO spread /delay a bit
	//mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')// TODO spread /delay a bit  // moved above as this creates device
	mqtt.unsubscribeTopic(atomicState.HA+'/group/+/state')
	mqtt.unsubscribeTopic(atomicState.HA+'/input_boolean/+/state')
    mqtt.unsubscribeTopic(atomicState.HA+'/person/+/state')
    mqtt.unsubscribeTopic(atomicState.HA+'/cover/+/state')
    mqtt.unsubscribeTopic(atomicState.HA+'/cover/+/current_position')   
}
def discoveryComplete () {
    if (atomicState.startupDiscovery=="running") log ("All startup discoveries have completed", "INFO")
    mqtt = getChildDevice("MQTT: Child device driver")
    mqtt.setHAInDiscovery(false)
    atomicState.startupDiscovery=='complete'
    pacingSet("idle")
    //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"idle",1,true)
    mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$discovery',"complete",1,true)
    log ("All startup discoveries have completed", "INFO")
    log ("ReSubscribing to virtual topics", "INFO")
    subscribeVirtuals()
    if  (atomicState.abortable==false) devSummary(null)
}

def clearWildcardedDiscoveries(){
    unsubscribeHADeviceEvents(false)
    unsubscribeHADevices(false)
    unsubscribehomieEvents(false)
    unsubscribeCBusEvents(false)
    unsubscribeHAInDiscoveryEvents(false)
    unsubscribeHAInExtendedEvents(false)   
}

def pacingSet(pace) {
    mqtt = getChildDevice("MQTT: Child device driver")
    mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"$pace",1,false)
    mqtt.setStateWaiting (pace)
    // 90 seconds is the default timeout value for deciding pacing has failed - maybe make it a config parameter
    runIn(90, "pacingLost", [data: pace])
}

def pacingLost (data) {

    if (("$data"=="cancel")||("$data"=="idle"))return
    log.error ("MQTT broker lost pacing response for [$data]")
}

def pacing(payload) {
    runIn(0, "pacingLost", [data: 'cancel'])
    if (payload!="idle") log("Pacing: $payload","LOG")
    mqtt = getChildDevice("MQTT: Child device driver")
    
    if (payload=="HAInEnd") {
        pacingSet("idle")
        //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"idle",1,true)
        unsubscribeHAInDiscoveryEvents()  // use runIn ?
    }
        else if (payload=="HADevClassEnd") {
        subscribeHADevices_friendlyNames1 ()
    }
        else if (payload=="HAFriendly1End") {
        //log ("New homie finished unsubscribes would run now","KH")
        subscribeHADevices_friendlyNames2()  // use runIn ?
    }
        else if (payload=="HAFriendly2End") {
        //log ("New homie finished unsubscribes would run now","KH")
        subscribeHASensorFriendly()  // use runIn ?
    }
    else if (payload=="HAEnd") {
        pacingSet("idle")
        //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"idle",1,true)
        unsubscribeHADeviceEvents()
        unsubscribeHADevices()
        if (atomicState.startupDiscovery=='running')  {
            if(settings?.HAInDiscovery && settings?.HAInRunEvery)  HAInDiscovery()
            else discoveryComplete()
        }
        else discoveryComplete ()
    }
        else if (payload=="HAInExtEnd") {
            pacingSet("idle")
            //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"idle",1,true)
            //log ("New homie finished unsubscribes would run now","KH")
            //unsubscribeHAInExtendedEvents()  // use runIn ?
    }

        else if (payload=="HAInExt1End") {
        //log ("New homie finished unsubscribes would run now","KH")
        checkHAInExtendedDiscovery2()  // use runIn ?
    }

        else if (payload=="HAInExt2End") {
        //log ("New homie finished unsubscribes would run now","KH")
        checkHAInExtendedDiscovery3()  // use runIn ?
    }
        else if (payload=="HAInExt3End") {
        //log ("New homie finished unsubscribes would run now","KH")
        checkHAInExtendedDiscovery4()  // use runIn ?
    }
        else if (payload=="HAInExt4End") {                               
        //log ("New homie finished unsubscribes would run now","KH")
        checkHAInExtendedDiscovery5()  // use runIn ?
    }
        else if (payload=="HAInExt5End") {                               
        //log ("New homie finished unsubscribes would run now","KH")
        checkHAInExtendedDiscovery6()  // use runIn ?
    }
            else if (payload=="HAInExt6End") {                               
        //log ("New homie finished unsubscribes would run now","KH")
        checkHAInExtendedDiscovery7()  // use runIn ?
    }
            else if (payload=="HAInExt7End") {                               
        //log ("New homie finished unsubscribes would run now","KH")
        checkHAInExtendedDiscovery8()  // use runIn ?
    }
            else if (payload=="HAInExt8End") {                               
        //log ("New homie finished unsubscribes would run now","KH")
        checkHAInExtendedDiscovery9()  // use runIn ?
    }
           else if (payload=="HAInExt9End") {                               
        //log ("New homie finished unsubscribes would run now","KH")
        checkHAInExtendedDiscovery10()  // use runIn ?
    }
           else if (payload=="HAInExt10End") {                               
        //log ("New homie finished unsubscribes would run now","KH")
        checkHAInExtendedDiscovery11()  // use runIn ?
    }
    else if (payload=="HAInExt11End") {
        //log ("New homie finished unsubscribes would run now","KH")
        unsubscribeHAInExtendedEvents()  // use runIn ?
        discoveryComplete ()
    }
        
    else if (payload=="homieEnd") {
        //log ("New homie finished unsubscribes would run now","KH")
        unsubscribehomieEvents()  // use runIn ?
        pacingSet("idle")
        //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"idle",1,true)
        if (atomicState.startupDiscovery=='running') {
            if(settings?.HAStatestream && settings?.HARunEvery) start_HADiscovery(null)
            else if(settings?.HAInDiscovery && settings?.HAInRunEvery)  HAInDiscovery()
            else discoveryComplete ()
        }
        else discoveryComplete ()
    }
    
    else if (payload=="CBusEnd") {
        unsubscribeCBusEvents()  // use runIn ?
        discoveryComplete ()
    }
}

def unsubscribeHAInDiscoveryEvents(msg=true) {
    mqtt = getChildDevice("MQTT: Child device driver")
    if (msg) {
        time=(int) ((now()-atomicState.timeStamp)/1000)    
        log ("=======  HA Incoming Discovery has completed in $time secs =======","BLUE")
    }
	mqtt.unsubscribeTopic(settings?.HAInTopic+'/+/+/config')  
	mqtt.unsubscribeTopic(settings?.HAInTopic+'/+/+/+/config') 
    //mqtt.subscribeTopic(settings?.HAInTopic+'/+/+/+/+/config')
    mqtt.unsubscribeTopic('homie/'+atomicState.normHubName+'/pacing')
    if (settings?.incNonConfig) {
        checkHAInExtendedDiscovery()
    }
    else discoveryComplete ()
}


// Have to pace these into 12 sections as losing messages otherwise (MQTT config issue)
// disabled the friendly_names subscribes atm as not using them  TODO ?
def checkHAInExtendedDiscovery () {  //for sensors only  (UOM)
   log ("================  Starting HA In Extended Discovery  ================", "BLUE")
    mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$discovery',"HA In Extended",1,true)
   atomicState.timeStamp=now()
   mqtt = getChildDevice("MQTT: Child device driver")
   mqtt.subscribeTopic (settings?.HAInTopic+'/sensor/+/unit_of_measurement')
   mqtt.subscribeTopic (settings?.HAInTopic+'/sensor/+/unit_of_meas')
   mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   pacingSet("HAInExt1End")
    //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"HAInExt1End",1,false) // this will arrive when all the friendly names have arrived
}  
def checkHAInExtendedDiscovery2 () {  //for binary sensors only  (state)
   mqtt = getChildDevice("MQTT: Child device driver")
   mqtt.unsubscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   mqtt.unsubscribeTopic (settings?.HAInTopic+'/sensor/+/unit_of_measurement')
   mqtt.unsubscribeTopic (settings?.HAInTopic+'/sensor/+/unit_of_meas')
   mqtt.subscribeTopic (settings?.HAInTopic+'/binary_sensor/+/state') 
   mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   pacingSet("HAInExt2End")
    //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"HAInExt2End",1,false) // this will arrive when all the friendly names have arrived
}
def checkHAInExtendedDiscovery3 () {  //for sensors only  (state)
   mqtt = getChildDevice("MQTT: Child device driver")
   mqtt.unsubscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   mqtt.unsubscribeTopic (settings?.HAInTopic+'/binary_sensor/+/state')
   mqtt.subscribeTopic (settings?.HAInTopic+'/sensor/+/state') 
   mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   pacingSet("HAInExt3End")
    //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"HAInExt3End",1,false) // this will arrive when all the friendly names have arrived
}
def checkHAInExtendedDiscovery4 () {  //for binary sensors only  (friendly)
   mqtt = getChildDevice("MQTT: Child device driver")
   mqtt.unsubscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   mqtt.unsubscribeTopic (settings?.HAInTopic+'/sensor/+/state') 
 //mqtt.subscribeTopic (settings?.HAInTopic+'/binary_sensor/+/friendly_name')  // Handle this differently to update any devices created.  Not sure we can update the dropdown lists    
   mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   pacingSet("HAInExt4End")
    //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"HAInExt4End",1,false) // this will arrive when all the friendly names have arrived
}
def checkHAInExtendedDiscovery5 () {  //for sensors only  (friendly_name)
   mqtt = getChildDevice("MQTT: Child device driver")
   mqtt.unsubscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   mqtt.unsubscribeTopic (settings?.HAInTopic+'/binary_sensor/+/friendly_name')
 //mqtt.subscribeTopic (settings?.HAInTopic+'/sensor/+/friendly_name')  // Handle this differently to update any devices created.  Not sure we can update the dropdown lists
   mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   pacingSet("HAInExt5End")
    //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"HAInExt5End",1,false) // this will arrive when all the friendly names have arrived
}
def checkHAInExtendedDiscovery6 () {  //locks
   mqtt = getChildDevice("MQTT: Child device driver")
   mqtt.unsubscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   mqtt.unsubscribeTopic (settings?.HAInTopic+'/sensor/+/friendly_name')
   mqtt.subscribeTopic (settings?.HAInTopic+'/lock/+/state')
 //mqtt.subscribeTopic (settings?.HAInTopic+'/lock/+/friendly_name')   
   mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   pacingSet("HAInExt6End")
    //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"HAInExt6End",1,false) 
}
def checkHAInExtendedDiscovery7 () {   //climate
   mqtt = getChildDevice("MQTT: Child device driver")
   mqtt.unsubscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   mqtt.unsubscribeTopic (settings?.HAInTopic+'/lock/+/state')
   mqtt.unsubscribeTopic (settings?.HAInTopic+'/lock/+/friendly_name')    //mqtt.subscribeTopic (settings?.HAInTopic+'/binary_sensor/+/friendly_name')  // Handle this differently to update any devices created.  Not sure we can update the dropdown lists    
   mqtt.subscribeTopic (settings?.HAInTopic+'/climate/+/state')
 //mqtt.subscribeTopic (settings?.HAInTopic+'/climate/+/friendly_name')
   mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   pacingSet("HAInExt7End")
    //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"HAInExt7End",1,false) 
}
def checkHAInExtendedDiscovery8 () { // automation
   mqtt = getChildDevice("MQTT: Child device driver")
   mqtt.unsubscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   mqtt.unsubscribeTopic (settings?.HAInTopic+'/climate/+/state') 
   mqtt.unsubscribeTopic (settings?.HAInTopic+'/climate/+/friendly_name')
   mqtt.subscribeTopic (settings?.HAInTopic+'/automation/+/state')  
 //mqtt.subscribeTopic (settings?.HAInTopic+'/automation/+/friendly_name')  
   mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   pacingSet("HAInExt8End")
    //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"HAInExt8End",1,false) 
}
def checkHAInExtendedDiscovery9 () {  //cover
   mqtt = getChildDevice("MQTT: Child device driver")
   mqtt.unsubscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   mqtt.unsubscribeTopic (settings?.HAInTopic+'/automation/+/state')  
   mqtt.unsubscribeTopic (settings?.HAInTopic+'/automation/+/friendly_name')
   mqtt.subscribeTopic (settings?.HAInTopic+'/cover/+/state')  
 //mqtt.subscribeTopic (settings?.HAInTopic+'/cover/+/friendly_name')  
   mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   pacingSet("HAInExt9End")
   //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"HAInExt9End",1,false) 
}
def checkHAInExtendedDiscovery10 () {  //cover
   mqtt = getChildDevice("MQTT: Child device driver")
   mqtt.unsubscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   mqtt.unsubscribeTopic (settings?.HAInTopic+'/cover/+/state')  
   mqtt.unsubscribeTopic (settings?.HAInTopic+'/cover/+/friendly_name')
   mqtt.subscribeTopic (settings?.HAInTopic+'/person/+/state')  
 //mqtt.subscribeTopic (settings?.HAInTopic+'/person/+/friendly_name')  
   mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   pacingSet("HAInExt10End")
    //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"HAInExt10End",1,false) 
}
def checkHAInExtendedDiscovery11 () {  //cover
   mqtt = getChildDevice("MQTT: Child device driver")
   mqtt.unsubscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   mqtt.unsubscribeTopic (settings?.HAInTopic+'/person/+/state')  
   mqtt.unsubscribeTopic (settings?.HAInTopic+'/person/+/friendly_name')
   mqtt.subscribeTopic (settings?.HAInTopic+'/group/+/state')  
 //mqtt.subscribeTopic (settings?.HAInTopic+'/group/+/friendly_name')  
   mqtt.subscribeTopic('homie/'+atomicState.normHubName+'/$pacing')
   pacingSet("HAInExt11End")
    //mqtt.publishMsg ('homie/'+atomicState.normHubName+'/$pacing',"HAInExt11End",1,false) 
}

def unsubscribeHAInExtendedEvents(msg=true) {  
    mqtt = getChildDevice("MQTT: Child device driver")
    if (msg) {
        time=(int) ((now()-atomicState.timeStamp)/1000)
        log ("=======  HA In Extended Discovery has completed in $time secs =======","BLUE")
    }
    mqtt.setHAInDiscovery(false)
    mqtt.unsubscribeTopic (settings?.HAInTopic+'/group/+/state')  
    mqtt.unsubscribeTopic (settings?.HAInTopic+'/group/+/friendly_name') 

    // double check all unsubscribed
    mqtt.unsubscribeTopic (settings?.HAInTopic+'/sensor/+/friendly_name')  // Handle this differently to update any devices created.  Not sure we can update the dropdown lists
    mqtt.unsubscribeTopic (settings?.HAInTopic+'/binary_sensor/+/friendly_name')  // Handle this differently to update any devices created.  Not sure we can update the dropdown lists
    mqtt.unsubscribeTopic (settings?.HAInTopic+'/sensor/+/unit_of_measurement')
    mqtt.unsubscribeTopic (settings?.HAInTopic+'/sensor/+/unit_of_meas')
    mqtt.unsubscribeTopic (settings?.HAInTopic+'/sensor/+/state')
    mqtt.unsubscribeTopic (settings?.HAInTopic+'/binary_sensor/+/state')
    mqtt.unsubscribeTopic('homie/'+atomicState.normHubName+'/pacing')
}

def subscribeOneOffTopics(topic) {
    mqtt = getChildDevice("MQTT: Child device driver")
	mqtt.subscribeTopic(topic)
}

def stringToList(maps,what='cmd') {
    //maps=device.getDataValue("switch_MAP")
    if (maps != null) {
        if (what=='cmd') {  // want the cmd map
            cmdStart=maps.indexOf('][') // has command mappings
            if (cmdStart>1){
                cmdMaps=maps.substring(cmdStart+1, maps.length())
                maps=cmdMaps
            }
        }
        maps=maps.substring(1, maps.length()-1)
        mapList = maps.split(',')
        return (mapList)
    }
}


def jsonSplit (source,value=null){  
/*
                       source is the json string and value is the value you want including in returned payload
                       this allowed composite json values with only one 'variable' and the other preset e.g. an ID
 source example        topic1/topic2/topic3{key:}{"key2: "one", "key2": "two"}
                       _____________________ json ____________________________
                       ______  topic  ______============== payload  ==========
                                            ^jasStart                        ^
                                      jasAppend  ,____________________________  or ','
                                               ^jasSub 
                                                 ^jasExtra
                       
*/
        if(source!=null) {
            jasStart=source.indexOf("{") 
            if ((jasStart>1) && (source.endsWith('}'))) {  //valid JSON
                jasExtra=source.indexOf("}{")
                if (jasExtra > 1) jasAppend=','+source.substring(jasExtra+2) else jasAppend='}'
                jasSub=source.indexOf(":}") 
                if (jasSub>1) {
                    source=source.substring(0, jasSub+2)               
                    if (source.endsWith(':}')){  //strip json
                        if (value!=null) payload='{"' + source.substring(jasStart+1,source.length()-2) + '":"' + value +'"'+ jasAppend
                        else payload=''
                        topic=source.substring(0, jasStart)
                        //json=source.substring(1,source.length()-2 ) // ...NB this will be json not {json}
                        //return [topic,json,embed]
                        return [topic,payload]
                    }
                }
            }
       }
    else  log ('jsonSplit:  No source','WARN')
    log ("jsonSplit:  $source  $value","TRACE")
    return [source,value]
}

//#######################################################################################################################################
//##############################   This section takes internal events/state changes and updates the devices  ############################
//##############################   It also publishes discovery topics using the  HA MQTT discovery protocol  ############################
//#######################################################################################################################################
//def switched(evt, name=null, type=null, state=null,id=0) {
def switched(evt, name=null, type=null, state=null, device=null) {
    mqtt = getChildDevice("MQTT: Child device driver")
	if (evt!=null)
	{
		device=evt.getDevice()
        log ("eSwitched [$state] from $device  lastDev is $lastDev  lastDevOnOff is $lastDevOnOff","DEBUG")
        if (block==device.displayName){
            log ("Blocking Event (switched): $device.displayName","KGREEN")
            return
        }
        name=normalize(evt.displayName)
		state=evt.value
        if ((state=='off')||(bState=='OFF')) bState='OFF'
        else if ((state=='on')||(bState=='ON')) bState='ON'
        else bState='none'
		xName=evt.name
        // need to determine if MQTT caused this or HE
        //log ("eSwitched lastDev is $lastDevOnOff compare $name [$bState]  lastDevOnOff is $lastDevOnOff" ,"KH") 
        if (lastDevOnOff== "$name [$bState]") {
            lastDevOnOff=''
            log ("Blocking _cmd (onoff/set) back to MQTT","TRACE")
            //log ("Blocking _cmd (onoff/set) back to MQTT","LOG")
        }
        else {
            dType = device.getTypeName()
            if ((dType!=null) && dType.startsWith("Virtual")) // only allow commands to MQTT from virtuals
            {

                //cMQTT=device.getDataValue("mqtt")
                cOrigin=device.getDataValue("origin")
                //if (cMQTT=="enabled") {
                //if (cOrigin=="user") {
                if ((cOrigin=="user") || (cOrigin=="Home Assistant") || (cOrigin=="homie") || (cOrigin=="HA Discovery") || (cOrigin=="C-Bus")) { 
                    cTopic=device.getDataValue("switch_Cmd")
                    if(cTopic!=null) { 
                        //log ("$device.displayName has switch_Cmd of $cTopic","DEBUG")
                        maps=device.getDataValue("switch_MAP")
                        mapList = stringToList(maps)
                        
                        //log ("States are " + mapList[0] + " and " + mapList[1],"LOG")
                        if (state=='on') {
                            if (mapList[0] != null) state = mapList[0]
                        }
                        if (state=='off') {
                            if (mapList[1] != null) state = mapList[1]
                        } 
                        (cTopic,state)=jsonSplit(cTopic,state)  // maybe dont call this if no json
                        log ("(eSwitched) Sending SET $state command to MQTT $cTopic  #$name [$state]# != #lastDevOnOff $lastDevOnOff#","DEBUG")
                        log ("(eSwitched) Sending SET $state command to MQTT $cTopic  $name [$state] !=  $lastDevOnOff","LOG")
                        mqtt.publishMsg (cTopic,state,1,false)
                    }
                  }
                else log ("Didn't send SET command to $name because cOrigin was $cOrigin", "WARN")
                }
            }
	    } 
	else 
	{
		xName=name
	}
    discovered==true
    if (settings?.homiePublish) {
        if (!discovered){ //dont republish discovered
			normName = normalize(name) 
			if (state=="on") nState = "true" else nState = "false"    //TODO make flexible
            sTopic="homie/${atomicState.normHubName}/${normName}"+'/onoff'
			mqtt.publishMsg (sTopic,nState,1,settings?.homieStatesPersist)
            if (!atomicState.suppress) {
			    sTopic=	"homie/${atomicState.normHubName}/${normName}"		
			    //================  Limited homie spec implemenation ================
                //addProperty(sTopic,"onoff",device)
			    //mqtt.publishMsg (sTopic+'/$properties',"onoff",1,true)  // limited homie implementation
			    mqtt.publishMsg (sTopic+'/$name',name,1,true)   
			    mqtt.publishMsg (sTopic+'/$type',"socket",1,true,atomicState.suppress) 
                if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/onoff/$settable',"true",1,true,atomicState.suppress) 
			    mqtt.publishMsg (sTopic+'/onoff/$name',name,1,true,atomicState.suppress) 
			    mqtt.publishMsg (sTopic+'/onoff/$datatype',"boolean",1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/onoff/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
            }
 
		    //log ("Updated ${sTopic} to ${nState}", "ERROR")   // only for log visibility
			//==================================================================
        checkNodes(1,name)
		if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devicesF"2"
            
			HADiscoveryAdvertise(name,"switch","none",device.id)	
		}
		else if (settings?.HADiscovery) log ("HADiscovery switched discarded for ${name}","DEBUG")
     }
  }
}

def mqttPublishMsg(topic,payload,num,retain) {
    mqtt = getChildDevice("MQTT: Child device driver")
    mqtt.publishMsg (topic,payload.toString(),num,retain)
}


def switchedDim(evt, name=null, type=null, state=null, device=null) {  // why do we pass devType in here ??
	mqtt = getChildDevice("MQTT: Child device driver")
    if (evt!=null)
	{
		device=evt.getDevice()
        log ("eSwitchedDimmed [$state] from $device  lastDev is $lastDev  lastDevDim is $lastDevDim ","DEBUG")
        log ("Comparison: $block  $device.displayName","TRACE")
        if (block==device.displayName){
            log ("Blocking Event (switchedDim): $device.displayName","KGREEN")
            return
        }
        name=normalize(evt.displayName)
		state=evt.value
		xName=evt.name
		log("Event: Device is SwitchedDim ${state}  ${name} ${xName}", "TRACE")
        //if (lastDev== "$name [$state]") lastDev=''
        if (lastDevDim== "$name [$state]") {
            lastDevDim=''
            log ("Blocking _cmd (switchedDim /set) back to MQTT","TRACE")
            //log ("Blocking _cmd (switchedDim /set) back to MQTT","LOG")
        }
        
        else {
            log ("switchedDim LastDev: $lastDevDim  This:  $name [$state]","TRACE")
            dType = device.getTypeName()
            if (dType.startsWith("Virtual")) // only allow commands to MQTT from virtuals
            {
                //cMQTT=device.getDataValue("mqtt")
                cOrigin=device.getDataValue("origin")
                //if (cMQTT=="enabled") {
                if ((cOrigin=="user") || (cOrigin=="Home Assistant") || (cOrigin=="homie") || (cOrigin=="HA Discovery") || (cOrigin=="C-Bus")) {  
                   cTopic=device.getDataValue("switch_Cmd") 
                   if(cTopic!=null) {
                       log ("$device.displayName has switch_Cmd of $cTopic","DEBUG")
                       maps=device.getDataValue("switch_MAP")
                       log ("Map: " + maps,"DEBUG")
                        mapList = stringToList(maps)
                        log ("MapList: " + mapList,"DEBUG")
                    
                       log ("States 0 and 1 are " + mapList[0] + " and " + mapList[1] ,"TRACE")
                       //log ("State2 is " + mapList[2] ,"LOG")
                       //log ("State3 is " + mapList[3] ,"LOG")
                        if (state=='on') {
                            if (mapList[0] != null) state = mapList[0]
                        }
                        if (state=='off') {
                            if (mapList[1] != null) state = mapList[1]
                        }                        
                        (cTopic,state)=jsonSplit(cTopic,state)
                        log ("(switchedDim) Sending SET $state command to MQTT $cTopic   $name [$state] !=  $lastDevOnOff","DEBUG")
                        mqtt.publishMsg (cTopic,state,1,false)
                    }
                }
                else log ("Didn't send SET command to $name because cOrigin was $cOrigin", "WARN")
              }
            }
	    

	} 
	else 
	{
        xName=name
		log("Device (synch) switchedDim ${state}  ${name} ${xName}", "DEBUG")
	}

        discovered=true
		if (settings?.homiePublish) {
          if (!discovered){ //dont republish discovered
			normName = normalize(name)
            sTopic=	"homie/${atomicState.normHubName}/${normName}"
			if (state=="on") nState = "true" else nState = "false"  // TODO customisable
            mqtt.publishMsg (sTopic+'/onoff',nState.toString(),1,settings?.homieStatesPersist)
            if (!atomicState.suppress){
			    //addProperty(sTopic,"onoff",device)
                    //addProperty(sTopic,"dim",device)		
			    //================ homie spec implementation ================           
			    //mqtt.publishMsg (sTopic+'/$properties',"onoff,dim",1,true)   // limited homie implementation
			    mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			    mqtt.publishMsg (sTopic+'/$type',"light",1,true,atomicState.suppress)
                if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/onoff/$settable',"true",1,true,atomicState.suppress)   
			    mqtt.publishMsg (sTopic+'/onoff/$name',name.toString(),1,true,atomicState.suppress)  
			    mqtt.publishMsg (sTopic+'/onoff/$datatype',"boolean",1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/onoff/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
            }
			//log ("Updated homie/${atomicState.normHubName}/${normName}/onoff to ${nState.toString()}", "ERROR")   // only for log visibility
			//==========================================================
        if (name==null) log ("Bad device name call in [10] $xName $xType","DEBUG")
        checkNodes(2, name) 
	    if (settings?.HADiscovery){
		    if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		    HADiscoveryAdvertise(name,"switch","block",device.id)
		    }
        }
		else if (settings?.HADiscovery) log ("HADiscovery switchedDim discarded for ${name}","DEBUG")
	  }
    }
}

def dimmed(evt, name=null, type=null, state=null,device=null) {
    openHAB=false  // setting true forces reported dim value to 0-1.0
    mqtt = getChildDevice("MQTT: Child device driver")
	if (evt!=null)
	{
	    device=evt.getDevice()
            log ("eDimmed [$state] from $device  lastDevDim is $lastDevDim","DEBUG")
        if (block==device.displayName){
            log ("Blocking Event (switchedDim): $device.displayName","KGREEN")   
            return
        }
        name=normalize(evt.displayName)
		state=evt.value
		xName=evt.name        
        //Hubitat evt reports 0-100 whereas devices can report to maxLevel so typically wont match
        if (lastDevDim== "$name [$state]") {
            lastDevDim=''
            log ("Blocking _cmd (dim/set) back to MQTT","TRACE")
            //log ("Blocking _cmd (dim/set) back to MQTT","LOG")
        }

        else {
            dType = device.getTypeName()
            if (dType.startsWith("Virtual")) // only allow commands to MQTT from virtuals
            {
                log ("Dim LastDevDim: $lastDevDim  This:  $name [$state]","TRACE")
                //cMQTT=device.getDataValue("mqtt")
                cOrigin=device.getDataValue("origin")
                //if (cMQTT=="enabled") {
                //if (cOrigin=="user") {
                if ((cOrigin=="user") || (cOrigin=="Home Assistant") || (cOrigin=="homie") || (cOrigin=="HA Discovery") || (cOrigin=="C-Bus"))  { 
                    cTopic=device.getDataValue("level_Cmd")
                    cScale=device.getDataValue("max_Level").toInteger()
                    if (cScale>0){
                        cScale=(cScale * state.toInteger()/100).toInteger()
                        state=cScale.toString()
                    }
                    (cTopic,state)=jsonSplit(cTopic,state)
                    if((cTopic!=null) && (cTopic.length()!=0)) {
                        log ("(dimmed) Sending SET command to MQTT $cTopic  $name [$state] !=  $lastDevDim","LOG")
                        mqtt.publishMsg (cTopic,state,1,false)
                    }
                }
                else log ("Didn't send SET command To $name because cOrigin was $cOrigin", "WARN")
            }
	    }

	} 
	else {
		xName=name
		log ("Device (synch) dimmed ${state}  ${name}", "DEBUG")
	}
    discovered=true
	if (settings?.homiePublish) {
        if (!discovered) { //dont republish discovered
    	normName = normalize(name) 
		//================  Limited homie spec implemenation ================
		sDimTopic="homie/${atomicState.normHubName}/${normName}"+'/dim'
		mqtt = getChildDevice("MQTT: Child device driver")
        
// Kludge for OH
        if (openHAB) {
                float smallDim = state.toInteger()/100
                mqtt.publishMsg (sTopic+'/dim',smallDim.toString())
        }
        
        else {
            val="$state"
            mqtt.publishMsg (sDimTopic,val,1,true)
        }

//END Kludge OH
        if (!atomicState.suppress) {
            sTopic="homie/${atomicState.normHubName}/${normName}"
                    //addProperty(sTopic,'onoff',device)
            //addProperty(sTopic,'dim',device)
            //sTopic=sTopic+'/onoff'
		    //mqtt.publishMsg (sTopic+'/$properties',"onoff,dim",1,true)  // limited homie implementation
		    mqtt.publishMsg (sTopic+'/$name',"${name}",1,true)  
		    mqtt.publishMsg (sTopic+'/$type',"light",1,true,atomicState.suppress)
            if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
		    mqtt.publishMsg (sTopic+'/dim/$settable',"true",1,true,atomicState.suppress)
		    mqtt.publishMsg (sTopic+'/dim/$name',"${name}",1,true,atomicState.suppress) 
		    mqtt.publishMsg (sTopic+'/dim/$datatype',"integer",1,true,atomicState.suppress)
		    mqtt.publishMsg (sTopic+'/dim/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
		    if (openHAB) mqtt.publishMsg (sTopic+'/dim/$format',"0:1",1,true,atomicState.suppress)
            else mqtt.publishMsg (sTopic+'/dim/$format',"0:100",1,true,atomicState.suppress)
		    //===================================================================
        }
        checkNodes(3,name) 
	    if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		    HADiscoveryAdvertise(name,"light","none",device.id)
	    }
	    else if (settings?.HADiscovery) log ("HADiscovery dimmed discarded for ${name}","DEBUG")
    }
  } 
}


//Casey <
def locked(evt, name=null, type=null, state=null, device=null) {
	if (evt!=null)
	{
		name=evt.displayName
		state=evt.value
		xName=evt.name
        device=evt.getDevice()
        origin=device.getDataValue("origin")
        //if (origin!=null & origin=="user") log ("This is a virtual MQTT device  $lastDev","KH")
		//log(" Device is a lock - now ${state}  ${name} ${xName}", "LOG")
        //log ("Digital: ${evt.isDigital()}  Physical: ${evt.isPhysical()} Change: ${evt.isStateChange} Source: ${evt.source}", "LOG")
        thisDev= name + " ["+ state +"]"
        if (lastDev == thisDev)  {
            log ("Ignore: This is from MQTT","KH")
            }
        else {
            log ("Action: Need to send $state cmd to MQTT","KH")
            attrList=device.getSupportedAttributes()
            index=-1
            for (i=0; i<attrList.size(); i++) {
                //log ("Attribute List ${attrList[i].name}", "KH")
                if (attrList[i].name=='lock') index = i
            }
            //log ("Index found at $index","KH")
            atts = "${attrList[index].getPossibleValues()}" 
            //log ("Possible Values are $atts","KH")
            valList=stringToList(atts)
            index2=-1
            for (i=0; i < valList.size(); i++) {
                if (valList[i]== "${state}") index2 = i
                else if (valList[i]== " ${state}") index2 = i
            }            
            cTopic=device.getDataValue(xName+"_MAP")
            if (cTopic!=null) {
                log ("$device.displayName has $xName _MAP of $cTopic","LOG")
                log ("Map values are $cTopic","KH")
                mapped=stringToList(cTopic)
                log ("IndexMap is " + mapped[index2],"KH")
            }
        }  
	}
	else
	{
		xName=name
		log(" Device (synch) is locked ${state}  ${name} ${xName}", "LOG")
	}

// need to check specific lock is MQTT publish enabled    
	if (settings?.homiePublish) {
		normName = normalize(name)
        sTopic="homie/${atomicState.normHubName}/${normName}"
        if (state=="locked") nState = "true" else nState = "false"    //TODO make flexible
        mqtt = getChildDevice("MQTT: Child device driver")
        mqtt.publishMsg (sTopic+'/lock',nState,1,settings?.homieStatesPersist)
        if (!atomicState.suppress) {
            //addProperty(sTopic,'lock')			
			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',"lock",1,true)  // limited homie implementation
			mqtt.publishMsg (sTopic+'/$name',name,1,true)
			mqtt.publishMsg (sTopic+'/$type',"lock",1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/lock/$settable',"true",1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/lock/$name',name,1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/lock/$datatype',"boolean",1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/lock/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
        }
			
		    //log ("Updated ${sTopic} to ${nState}", "ERROR")   // only for log visibility
			//===================================================================
	}
    checkNodes(4, name) 
    if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
			HADiscoveryAdvertise(name,"lock","none",device.id)
    } else {
        log ("Locked event is NOT null for ${name}","TRACE")
    }
}
//Casey >


def buttons(evt, name=null, type=null, state=null, device=null) {
    
	if (evt!=null)
	{
		name=evt.displayName
        device=evt.getDevice()
		state=evt.value
        btnNum = (int) evt.value.toInteger()
		xName=evt.name.toLowerCase()
	}
	else
	{
		xName=name
        log(" Device (synch) is ${state}  ${name} ${xName} ${type}", "DEBUG") 

	}

	if (settings?.homiePublish) {

		normName = normalize(name)
        sTopic="homie/${atomicState.normHubName}/${normName}"
        //addProperty(sTopic,'button')
        mqtt = getChildDevice("MQTT: Child device driver")
        // mqtt.publishMsg (sTopic+'/button/'+"${xName}","${state}",1,true)
        if (type!=null) mqtt.publishMsg (sTopic+'/button/'+"${normalize(type)}","${state}",1,true)
        else {  // this only happens when button has a physical event
            type=evt.name
           
            mqtt.publishMsg (sTopic+'/button/'+"${normalize(type)}","${state}",1,true) 
            if ((btnNum>=0) && (btnNum < 999)) {
                if (type=='held')mqtt.publishMsg (sTopic+"/button/button-$btnNum","held",1,true)										  
                else {
                    if (type=='pushed' ) mqtt.publishMsg (sTopic+"/button/button-$btnNum","pushed",1,true)
                    else if (type=='doubleTapped') mqtt.publishMsg (sTopic+"/button/button-$btnNum","doubletapped",1,true)
								
                    else if (type=='released') mqtt.publishMsg (sTopic+"/button/button-$btnNum","released",1,true)
                    pauseExecution(1000)
                    mqtt.publishMsg (sTopic+"/button/button-$btnNum","idle",1,true)
                }
            }		 
            else log ("Bad button state $state $btnNum","WARN")
        }           
		mqtt.publishMsg (sTopic+'/button',"${state}",1,settings?.homieStatesPersist)
        if (!atomicState.suppress){
            mqtt.publishMsg (sTopic+'/$name',name,1,true)												
		    mqtt.publishMsg (sTopic+'/$type',"button",1,true,atomicState.suppress)
		    if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)  //  is device always in scope ?						  	
		    mqtt.publishMsg (sTopic+'/button/$settable',"false",1,true,atomicState.suppress)
		    mqtt.publishMsg (sTopic+'/button/$name',name,1,true,atomicState.suppress)
		    mqtt.publishMsg (sTopic+'/button/$datatype',"integer",1,true,atomicState.suppress)
            mqtt.publishMsg (sTopic+'/button/$format',"0:100",1,true,atomicState.suppress)
		    mqtt.publishMsg (sTopic+'/button/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
        }

																					
    }																																						
    checkNodes(5,name)	 
    if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
			HADiscoveryAdvertise(name,"button","none",device.id)
    } else {
        log ("Button event is NOT null for ${name}","TRACE")
    }
}

def buttonRel () {
    normName = normalize(name)
    sTopic="homie/${atomicState.normHubName}/${normName}"
    mqtt = getChildDevice("MQTT: Child device driver")
    mqtt.publishMsg (sTopic+"/button/button-$btnNum","idle",1,true)
}
/*
def thermostat() {  // TODO Remove from sensors below and place here
    
}
*/
def thermostatDevices(evt, name=null, type=null, state=null, device=null, multiple=false) { 
	if (evt!=null)
	{
		name=evt.displayName
        device=evt.getDevice()
		state=evt.value
		xType=evt.name  // this is the attribute name
		log ("[t] This got called by event ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${xType} ${evt.getDisplayName()}", "DEBUG")
	} 
	else {
		xType=type
		if (multiple) nameSuffix='_'+type else nameSuffix=''
		xName=name+nameSuffix
		log ("thermostatDevices (synch) called with name:${name}    xName: ${xName}    type: ${type} / ${xType}   state: ${state}    multiple: ${multiple}","DEBUG")
	}
	    normName = normalize(name)
		normxName = normalize(xName)
        settable="false"
        // log ("thermostatDevices called with ${name}/${xType}  ${state.toString()}", "ERROR")
		HAtype='unknown'
		UOM=''
        mqtt = getChildDevice("MQTT: Child device driver")
        log ("NB: $device.displayName attribute_MAP's not yet supported","DEBUG")
    	if (settings?.homiePublish) {  //TODO use case rather than if else if
		   sTopic="homie/${atomicState.normHubName}/${normName}"
//        if (!atomicState.suppress){
            if (xType=='temperature'){
				category='measure-temperature'
                HAtype="climate"
                if (device.typeName=="Virtual Thermostat") settable = "true"
              if (!atomicState.suppress){
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','-460:9999',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
              }
			}
            
            else if (xType=='humidity'){
				category='measure-humidity'
                HAtype="climate"
              if (!atomicState.suppress){
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
                UOM="%"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
              }
			}
            
            else if (xType=='battery'){
				category='measure-battery'
                HAtype="climate"
              if (!atomicState.suppress){
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
                UOM="%"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
              }
			}
            
			else if (xType=="thermostatSetpoint"){  //TODO combine above
				category='thermostat-setpoint'
                HAtype="climate"
                settable="true"
              if (!atomicState.suppress){
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:200',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$settable',"true",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
              }
			}
  
			else if (xType=="heatingSetpoint"){  //TODO combine above
				category='heating-setpoint'
                HAtype="climate"
                settable="true"
              if (!atomicState.suppress){
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:200',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$settable',"true",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
              }
			}
            else if (xType=="coolingSetpoint"){  //TODO combine above
				category='cooling-setpoint'
                HAtype="climate"
                settable="true"
              if (!atomicState.suppress){
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:200',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$settable',"true",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
              }
			}
            else if (xType=="thermostatMode"){  //TODO combine above
				category='mode'
                HAtype="climate"  
                settable="true"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
                //mqtt.publishMsg (sTopic+'/'+category+'/$mode',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format','0:200',1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)  
			}
            else if ((xType=="thermostatModes")||(xType=="supportedThermostatModes")){  //TODO combine above
				category='mode'
                HAtype="climate"
                settable="true"
              if (!atomicState.suppress){
				//mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true)
                // regex to strip leading [ and trailing ] and ,_ change to ,  
                //choices=choices.replaceAll(", ", ',')
  //NB: State has spaces in the values after each ,
                mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true,atomicState.suppress)
                //log ("State for modes is ${sTopic} ** ${category} ** ${state} ${state.toString()}  ", "DEBUG")
                s= state.toString()
                s=s.substring(0, s.length() - 1)+", idle]"
                mqtt.publishMsg (sTopic+'/'+"state"+'/$format',s,1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
              }
                state=null
			}
            else if (xType=="thermostatOperatingState"){  //TODO combine above
				category='state'
                HAtype="climate"
                settable="false"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
                //mqtt.publishMsg (sTopic+'/'+category+'/state',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)

            }        
            else if (xType=="thermostatFanMode"){  //TODO combine above
				category='fanmode'
                HAtype="climate"
                settable="true"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
                //mqtt.publishMsg (sTopic+'/'+category+'/$mode',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format','0:200',1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)

			}
            else if ((xType=="thermostatFanModes")||(xType=="supportedThermostatFanModes")){
                category='fanmode'
                HAtype="climate" 
                settable="true"
				//mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true)                
                // regex to strip leading [ and trailing ] and ,_ change to ,
                //string=string.replaceAll("^\[|, |]$", ',')
                //choices=choices.replaceAll(", ", ',')
                mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true,atomicState.suppress)
                //log ("State for modes is ${sTopic} ** ${category} ** ${state} ${state.toString()}  ", "DEBUG")
                //mqtt.publishMsg (sTopic+'/'+"state"+'/$format',"${state.toString()},idle",1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
                state=null
            } 
            
            else if (xType=="hysteresis"){  // not currently handled
                log ("Unhandled attribute in [$name] >> hysteresis", "WARN")
                return
            }
            else if (xType=="schedule"){   // not currently handled
                log ("Unhandled attribute in [$name] >> schedule", "WARN")
            }
            
			
            else {
				category = 'unknown'
				log ("[t] Unknown category for attribute #${xType}# reported by device ${name}","INFO")
                category = 'unknown_'+normalize(xType)
			}
			
			sTopic="homie/${atomicState.normHubName}/${normName}"     //+category
			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',category,1,true)   // limited homie implementation //  TODO BUG multiple properties
	        //atomicState.Category=category  // Huge risk here that this gets overwritten before update happens BUG TODO maybe have to check against sTopic
	        //pauseExecution(2000)// TODO need to adjust based on experience getTopic takes ~1800
	        //mqtt.getTopic (sTopic+'/$properties')   // need to append categories to existing ones
              //addProperty(sTopic,category)
              if (!atomicState.suppress){
			    mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			    mqtt.publishMsg (sTopic+'/$type',"thermostat",1,true,atomicState.suppress)
                if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable',settable,1,true,atomicState.suppress)   
			    mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,atomicState.suppress)  
			    //mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true)
			    mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)              }
        }
                if (state!=null) {
                    if(tempUnits=="Celsius x.x°C" && category=="measure-temperature") state = state.toFloat().round(1)
                    else if(tempUnits=="Fahreheit x.x°C" && category=="measure-temperature") state = state.toFloat().round(1)
                    mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist)  // <<<<<   This publishes the actual event value
                }	
	// payON and payOFF vary a lot for sensors so need extra params
    checkNodes(6,name)	
    payON=''
    payOFF=''
	if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices

		if (multiple) {
			HADiscoveryAdvertise(name,HAtype,category,device.id,payON,payOFF,nameSuffix,UOM)  // these are created as sub topics
		}
		else  HADiscoveryAdvertise(name,HAtype,category,device.id,payON,payOFF,'',UOM)  // will only be called once
	}
	else if (settings?.HADiscovery) log ("HADiscovery thermostat discarded for ${name}","DEBUG")
//        }
}

def keypadDevices(evt, name=null, type=null, state=null, device=null, multiple=false) { // subs must be used in HA discovery as device must be separated into multiple entities
 	if (evt!=null)
	{
		name=evt.displayName
        device=evt.getDevice()
		state=evt.value
		xType=evt.name  // attribute name
		log ("keypadDevices got called by event ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${xType} ${evt.getDisplayName()}", "DEBUG")
	} 
	else {
		xType=type
		if (multiple) nameSuffix='_'+type else nameSuffix=''
		xName=name+nameSuffix
		log ("keypadDevices (synch) called with name:${name}    xName: ${xName}    type: ${type} / ${xType}   state: ${state}    multiple: ${multiple}","DEBUG")
	}
        mqtt = getChildDevice("MQTT: Child device driver")
	    normName = normalize(name)
		normxName = normalize(xName)
        settable="false"
		HAtype='alarm_control_panel'
		UOM=''
		if (settings?.homiePublish) {  //TODO use case rather than if else if
			sTopic="homie/${atomicState.normHubName}/${normName}"

            if (xType=='lastCodeName'){  
				category='lastuser'        
            }
            else if (xType=='securityKeypad'){  //TODO
				category='securitymode'
                settable="true"
            }           
		    else if (xType=='motion'){  //TODO
				category='motion'       
            }
            else if (xType=='alarm'){  //TODO
				category='alarm'
            }
            else if (xType=='temperature'){  //TODO
				category='measure-temperature'
              if (!atomicState.suppress){
				    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"real",1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$unit','°C',1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$format','-273:999',1,true,atomicState.suppress)
				    UOM="degrees"
				    HAtype="sensor"
              }
			}
        }        
			else {
				category = 'unknown'
				log ("[k] Unknown Category for type ${xType} reported by device ${name}","INFO")
			}
			
			sTopic="homie/${atomicState.normHubName}/${normName}"     //+category
			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',category,1,true)   // limited homie implementation //  TODO BUG multiple properties
	        //atomicState.Category=category  // Huge risk here that this gets overwritten before update happens BUG TODO maybe have to check against sTopic
	        //pauseExecution(2000)// TODO need to adjust based on experience getTopic takes ~1800
	        //mqtt.getTopic (sTopic+'/$properties')   // need to append categories to existing ones
    if (!atomicState.suppress) {
        //addProperty(sTopic,category)
    
            if (xType=='securityKeypad'){
                settable='true'
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype','enum',1,true,atomicState.suppress)
               // mqtt.publishMsg (sTopic+'/'+category+'/$format','[<code>,disarmed,armed home,armed away,armed night]',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[<code>,disarmed,armed_home,armed_away,armed_night]',1,true,atomicState.suppress)

            }
			    mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			    mqtt.publishMsg (sTopic+'/$type',"keypad",1,true,atomicState.suppress)
                if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable',settable,1,true,atomicState.suppress)   
			    mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,atomicState.suppress)  
			    //mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true)
			    mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
			    //mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
        }
                stateValue = ''
                if (state!=null) {
//                  mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist)  // <<<<<   This publishes the actual event value
                    // HA Discovery needs 'armed_home' -vs- 'armed home'
                    if (settings?.HADiscovery) {
                        stateValue = state.toString().replaceAll("\\s","_")
                    }
                    else {
                        stateValue = state.toString()
                    }
                    mqtt.publishMsg (sTopic+'/'+category,stateValue,1,settings?.homieStatesPersist)  // <<<<<   This publishes the actual event value
                }
    checkNodes(7,name)	 
	if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices       
    if (multiple) {
	    HADiscoveryAdvertise(name,HAtype,category,device.id,payON,payOFF,'_alarm',UOM)  // these are created as sub topics
	}
	else  HADiscoveryAdvertise(name,HAtype,category,device.id,payON,payOFF,'_alarm',UOM)  // will only be called once
	}
	else if (settings?.HADiscovery) log ("HADiscovery sensor discarded for ${name}","DEBUG")    
}

/*
def garageDevices(evt, name=null, type=null, state=null, device=null, multiple=false) {  // subs must be used in HA discovery as device must be separated into multiple entities 
    id=99998888
    otherdevices(evt, name, type, state, device, multiple)
}
*/

def audioDevices(evt, name=null, type=null, state=null, device=null, multiple=false) {
    if (evt!=null)
	{
		name=evt.displayName
        device=evt.getDevice()
		state=evt.value
		xType=evt.name  // attribute name
		log ("audio Devices got called by event ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${xType} ${evt.getDisplayName()}", "TRACE")
	} 
	else {
		xType=type
		if (multiple) nameSuffix='_'+type else nameSuffix=''
		xName=name+nameSuffix
		log ("audio Devices (synch) called with name:${name}    xName: ${xName}    type: ${type} / ${xType}   state: ${state}    multiple: ${multiple}","TRACE")
	}
    normName = normalize(name)
    settable="false"
    sTopic="homie/${atomicState.normHubName}/${normName}"
    category=normalize(xType)
    //addProperty(sTopic,category)                          // TODO This is getting called too fast for atomicState to update
	//HAtype='music'
	//UOM=''
    dataType='text'
    settable='false'
    TTS=false
    atomicState.suppress=true
    mqtt = getChildDevice("MQTT: Child device driver")
    if (category=="trackdescription") {
        len=evt.value.length()
        if (len>20){
            checkTTS = evt.value.substring (len-8,len)
            if (checkTTS=="from TTS") {
                log ("Just announced " + evt.value.substring(0, evt.value.length() - 20),"TRACE")
                category="speech"
                settable='true'
                TTS=true
                mqtt.publishMsg (sTopic+'/'+category,evt.value.substring(0, evt.value.length() - 20),1,true)
            }
        }
        if (!TTS) {
             mqtt.publishMsg (sTopic+'/'+category,evt.value,1,true)  
        }
       TTS=false
    }
    else if (category=="trackdata") {

            dataType='json'
            mqtt.publishMsg (sTopic+'/'+category+'/$settable','false',1,true,atomicState.suppress)
            mqtt.publishMsg (sTopic+'/'+category,evt.value,1,true)
            def data = parseJson(evt.value)
            xcat='trackdescription'
            mqtt.publishMsg (sTopic+'/'+xcat+'/track',data.name,1,true)
            mqtt.publishMsg (sTopic+'/'+xcat+'/artist',data.artist,1,true)
            mqtt.publishMsg (sTopic+'/'+xcat+'/album',data.album,1,true)
            mqtt.publishMsg (sTopic+'/'+xcat+'/tracknumber',data.trackNumber,1,true)
          
    }
    else if (category=="status") {
            //addProperty(sTopic,'status')
            dataType='enum'
            mqtt.publishMsg (sTopic+'/'+category,evt.value,1,true)
            mqtt.publishMsg (sTopic+'/'+category+'/$format','[playing,stopped,paused,transitioning]',1,true)
    }
    else if (category=="level"||category=='volume') {
            dataType='integer'
            mqtt.publishMsg (sTopic+'/'+category,evt.value,1,true)
            mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true)
            //addProperty(sTopic,category)
    }
    else if (category=="mute") {
            dataType='enum'  // ToDO present as boolean ??
            mqtt.publishMsg (sTopic+'/'+category+'/$format','[muted,unmuted]',1,true)
            mqtt.publishMsg (sTopic+'/'+category,evt.value,1,true)
            //addProperty(sTopic,category)
    }
    else {
        log ("Music: " + xType,"LOG")
        mqtt.publishMsg (sTopic+'/'+category,evt.value,1,true)
    }            
    atomicState.suppress=false
    if (!atomicState.suppress){
        //mqtt.publishMsg (sTopic+'/$properties',category,1,true,atomicState.suppress)
        mqtt.publishMsg (sTopic+'/'+category+'/$datatype',dataType,1,true,atomicState.suppress)
        mqtt.publishMsg (sTopic+'/'+category+'/$settable',settable,1,true,atomicState.suppress)
        mqtt.publishMsg (sTopic+'/'+category+'/$retained','true',1,true,atomicState.suppress)
        mqtt.publishMsg (sTopic+'/'+category+'/$name',evt.displayName,1,true,atomicState.suppress)
    }
}

def locationEvent(evt,name=null,type=null,state=null,device=null,multiple=false) {
    mqtt = getChildDevice("MQTT: Child device driver")
    log.info "Location Alert: $evt.name $evt.value"
    if(evt.name == "mode"){
	    if (settings?.homiePublish) {
			    sTopic=	"homie/${atomicState.normHubName}/hub/mode"
			    mqtt.publishMsg (sTopic,evt.value,1,true)
            return
        } 
    }
    else if (evt.name=="systemStart") {
        //log.info "Location Alert: $evt.value" + (evt.value == "systemStart" ? ",  $evt.descriptionText” : "")
        log  ("===================== Reboot =====================", "INFO")
        unschedule()
        unsubscribe()
        atomicState.appCount=0
	    initialize()
        return
    }

    else if (evt.name=="hsmStatus") {
        sTopic=	"homie/${atomicState.normHubName}/hub/hsmStatus"
	    mqtt.publishMsg (sTopic,evt.value,1,true)
        return
    }
    else if (evt.name=="hsmSetArm") {
        sTopic=	"homie/${atomicState.normHubName}/hub/hsmArm"
	    if ("armAway, armHome, armNight, disarm, armRules, disarmRules, disarmAll, armAll, cancelAlerts".contains(evt.value)) mqtt.publishMsg (sTopic,evt.value,1,true)
        else mqtt.publishMsg (sTopic,'unknown',1,true)
        return
    }
    else if (evt.name=="hsmAlert") {
        sTopic=	"homie/${atomicState.normHubName}/hub/hsmAlert"
	    mqtt.publishMsg (sTopic,evt.value,1,true)
        return
    }
    
    log ("Got an unhandled location event message $evt.name $evt.value","KH")
    sTopic=	"homie/${atomicState.normHubName}/hub/hsm/$evt.name"
	mqtt.publishMsg (sTopic,evt.value,1,true)
}

// otherDevices handles this currently
def mqttText (evt,name=null,type=null,state=null,device=null,multiple=false) {
    
    log ("MQTT Text called","KH")
    mqtt = getChildDevice("MQTT: Child device driver")
    if (evt!=null)
	{
		name=evt.displayName
        device=evt.getDevice()
		state=evt.value
		xType=evt.name  // attribute name
        log ("MQTT Texts got called by event [$xType] ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${evt.getDisplayName()} [$lastDev]", "KH")
		xName=evt.name
		//log ("Device other ${state}  ${name}", "DEBUG")
        //log ("lastDev is $lastDev        $name [$state]","TRACE")
        //if (state=='close') state='closed'  // treat them the same
    }
    
}

       
def otherDevices(evt, name=null, type=null, state=null, device=null, multiple=false) {  // subs must be used in HA discovery as device must be separated into multiple entities 
    mqtt = getChildDevice("MQTT: Child device driver")
    if (evt!=null)
	{
		name=evt.displayName
        device=evt.getDevice()
		state=evt.value
		xType=evt.name  // attribute name
        log ("otherDevices got called by event [$xType] ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${evt.getDisplayName()} [$lastDev]", "DEBUG")
		xName=evt.name
		log ("Device other ${state}  ${name}", "DEBUG")
        log ("lastDev is $lastDev        $name [$state]","DEBUG")
        //if (state=='close') state='closed'  // treat them the same
        if (lastDev== "$name [$state]") {
            lastDev=''
            log (" Block this cmd update","DEBUG")
        }
        else {
            dType = device.getTypeName()
            log ("dType is $dType","TRACE")
            if (dType.startsWith("Virtual")|(dType=="MQTT Text")) // only allow commands to MQTT from virtuals or MQTT text - maybe MQTT Text should be virtual...
            {
                cMQTT=device.getDataValue("mqtt")
                if (cMQTT=="enabled") {
                   if (xType=='text') {
                        cTopic=device.getDataValue("text_Cmd")
                        if (cTopic=='' || cTopic==' ' || cTopic==null) return
/*
                        maps=device.getDataValue("text_MAP")
                        mapList = stringToList(maps)
                        (cTopic,state)=jsonSplit(cTopic,evt.value)
                        if(cTopic!=null) {
                            if (state=='closing') state= mapList[0] else state = mapList[1]
                            log ("(cdc) Sending other [door=$state] command to MQTT $cTopic","LOG")
                            mqtt.publishMsg (cTopic,state,1,false)
*/
                        log("Sending text /cmd to mqtt [$cTopic]","TRACE")
                        mqtt.publishMsg (cTopic,state,1,false)
                   }
                    

                    else if (xType=='contact') {
                        cTopic=device.getDataValue("contact_Cmd")
                        if (cTopic=='' || cTopic==' ' || cTopic==null) return
                        maps=device.getDataValue("contact_MAP")
                        mapList = stringToList(maps)
                        (cTopic,state)=jsonSplit(cTopic,evt.value)
                        if(cTopic!=null) {
                            if (state=='closed') state= mapList[0] else state = mapList[1]
                            log ("(contact) Sending other [contact=$state] command to MQTT $cTopic","TRACE")
                            mqtt.publishMsg (cTopic,state,1,false)
                        }
                    }
                    else if (xType=='door') {
                        cTopic=device.getDataValue("door_Cmd")
                        if (cTopic=='' || cTopic==' ' || cTopic==null) return
                        maps=device.getDataValue("door_MAP")
                        mapList = stringToList(maps)
                        (cTopic,state)=jsonSplit(cTopic,evt.value)
                        if(cTopic!=null) {
                            if (state=='closing') state= mapList[0] else state = mapList[1]
                            log ("(door) Sending other [door=$state] command to MQTT $cTopic","TRACE")
                            mqtt.publishMsg (cTopic,state,1,false)
                        }  
                      }       
                    }
                }
	        }                
   } 
	else {
		xType=type
		if (multiple) nameSuffix='_'+type else nameSuffix=''
		xName=name+nameSuffix
		log ("otherDevices (synch) called with name:${name}    xName: ${xName}    type: ${type} / ${xType}   state: ${state}    multiple: ${multiple}","DEBUG")
	}
    // quick kludge .. block this for mqtt 'user' devices ?   - however this stops manually enabling the devices too ....
    origin=device.getDataValue("origin")  // may need to check is not null space or empty
    if ((origin=='user')||(origin=='HA Discovery')) {
        log ("Blocking this state update to homie/.. $device","DEBUG")
        return
    }    
	    dType="sensor"
        normName = normalize(name)
		normxName = normalize(xName)
        settable="false"
		HAtype='unknown'
        category=xType
		UOM=''
		if (settings?.homiePublish) {  //TODO use case rather than if else if
			sTopic="homie/${atomicState.normHubName}/${normName}"            
			if (xType=='motion'){  //TODO
				category='motion'
                HAtype="binary_sensor"
            }
           else if (xType=='alarm'){  //TODO
				category='alarm'
                dType='alarm'
                category='alarm'        
            }
           else if (xType=='contact'){  //TODO
				category='contact'
                settable="false"
                dType='contact'
                HAtype="binary_sensor"
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[open,close,closed]',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
            }
            else if (xType=='cover'){  //TODO
				category='cover'
                settable="true"
                dType='cover'
                HAtype="cover"
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[open,close,closed]',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
            }
           else if (xType=='door'){  //TODO
				category='door'
                settable="true"
                dType='door'
                HAtype="cover"  // TODO has 4 values inc closing opening
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[open,close,closed,opening,closing]',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
            }
            else if ((xType=='position')||(xType=='level')){  //TODO  some windowshades dont have a position attribute
				category='position'
                addProperty(sTopic,'position',device)
                settable="true"
                dType='shade'
                HAtype="cover"
                mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
            }
           else if (xType=='windowShade'){  //TODO
				category='state'
                settable="false"
                dType='shade'
                HAtype="shade"  // TODO has 4 values inc closing opening
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[open,opening,partially open,closed,closing]',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
            }
            else if (xType=='speed'){  //TODO
				category='speed'
                settable="true"
                dType='fan'
                HAtype="fan"
                origin=device.getDataValue("origin")
                log ("origin: $origin","WARN")
                if (origin=='user') { // this is an adhoc virtual device
                    // was this a command I need to send - status comes from the mqtt device ?
                    log ("this is an adhoc device","WARN")
                    cmdTopic=device.getDataValue("speed_Cmd")
                    mqtt.publishMsg (cmdTopic,state,1,settings?.homieStatesPersist)
                }
                else {  //publish on homie
                    mqtt.publishMsg (sTopic+'/'+category+'/$format','[low,medium-low,medium,medium-high,high,on,off,auto]',1,true,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
                    addProperty(sTopic,'onoff',device)
                    mqtt.publishMsg (sTopic+'/'+'onoff'+'/$datatype',"enum",1,true,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+'onoff'+'/$format','[off,on]',1,true,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+'onoff'+'/$name',name,1,true,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+'onoff'+'/$retained',"true",1,true,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+'onoff'+'/$settable',"true",1,true,atomicState.suppress)
                }
            }
            else if (xType=='switch'){  //TODO
				category='onoff'
                settable="true"
                dType='shade'
                HAtype="cover"  // TODO has 4 values inc closing opening
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)
            }
            else if (xType=='valve'){  
				category='valve'
                dType="valve"
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[open,closed]',1,true,atomicState.suppress)
                settable="true"
            }
            else if (xType=='variable'){  
				category='variable'
                dType="variable"
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"string",1,true,atomicState.suppress)
                //mqtt.publishMsg ("homie/${atomicState.normHubName}/variables/${normName}",state.toString(),1,settings?.homieStatesPersist)
                settable="true"
            }
            else if (xType=='text'){  
				category='text'
                dType="variable"
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"string",1,true,atomicState.suppress)
                //mqtt.publishMsg ("homie/${atomicState.normHubName}/variables/${normName}",state.toString(),1,settings?.homieStatesPersist)
                settable="true"
            }
            else if (xType=='suffix'){  
				category='suffix'
                dType="variable"
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"string",1,true,atomicState.suppress)
                //mqtt.publishMsg ("homie/${atomicState.normHubName}/variables/${normName}",state.toString(),1,settings?.homieStatesPersist)
                settable="true"
            }
            else if (xType=='prefix'){  
				category='prefix'
                dType="variable"
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"string",1,true,atomicState.suppress)
                //mqtt.publishMsg ("homie/${atomicState.normHubName}/variables/${normName}",state.toString(),1,settings?.homieStatesPersist)
                settable="true"
            }
            else if (xType=='voltage'){  //TODO            
				category='measure-voltage'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','volts',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','-999999:999999',1,true,atomicState.suppress)
				UOM="volts"
				HAtype="sensor"
			}
            else if (xType=='power'){  // TODO is it this or 'energy' above ?
				category='measure-power'
                if (!atomicState.suppress){
				    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$unit','watts',1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$format','0:999999',1,true,atomicState.suppress)
                }
				UOM="watts"
				HAtype="sensor"
			}
            else if (xType=='energy'){  // TODO is it this or 'energy' above ?
				category='measure-energy'
                if (!atomicState.suppress){
				    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$unit','watts',1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$format','0:999999',1,true,atomicState.suppress)
                }
				UOM="watts"
				HAtype="sensor"
			}     
			else {
				category = 'unknown'
				log ("[o] Unknown Category for type ${xType} reported by device ${name}","INFO")
			}			
			sTopic="homie/${atomicState.normHubName}/${normName}"     //+category
			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',category,1,true)   // limited homie implementation //  TODO BUG multiple properties
	        //atomicState.Category=category  // Huge risk here that this gets overwritten before update happens BUG TODO maybe have to check against sTopic
	        //pauseExecution(2000)// TODO need to adjust based on experience getTopic takes ~1800
	        //mqtt.getTopic (sTopic+'/$properties')   // need to append categories to existing ones
            if (!atomicState.suppress){
                //addProperty(sTopic,category)          
			    mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			    mqtt.publishMsg (sTopic+'/$type',dType,1,true,atomicState.suppress)
                if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
                if (category != 'unknown') {
			        mqtt.publishMsg (sTopic+'/'+category+'/$settable',settable,1,true,atomicState.suppress)   
			        mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,atomicState.suppress)  
			        //mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
			        mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
			        //mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
                }
                else mqtt.publishMsg (sTopic+'/unhandled/' + xType,"$state",1,true,atomicState.suppress)   
            }
                if (state!=null) {
                    if(tempUnits=="Celsius x.x°C" && category=="measure-temperature") state = state.toFloat().round(1)
                    else if(tempUnits=="Fahrenheit x.x°C" && category=="measure-temperature") state = state.toFloat().round(1)
                    if (category != 'unknown') mqtt.publishMsg (sTopic+"/$category",state.toString(),1,settings?.homieStatesPersist)  //<<<<<   This publishes the actual event value
                    if (category=='speed') {
                      if (state=='off') mqtt.publishMsg (sTopic+'/onoff','off',1,settings?.homieStatesPersist)
                        else mqtt.publishMsg (sTopic+'/onoff','on',1,settings?.homieStatesPersist)
                    }
                }
    checkNodes(8,name)	
	if (evt==null && id != 99998888) {  // this will limit HADiscovery to startup or 'upon request' for devices
		if (multiple) {
			HADiscoveryAdvertise(name,HAtype,category,device.id,payON,payOFF,nameSuffix,UOM)  // these are created as sub topics
		}
		else  HADiscoveryAdvertise(name,HAtype,category,device.id,payON,payOFF,'',UOM)  // will only be called once  // TODO kludged ID
	}
	else if (settings?.HADiscovery) log ("HADiscovery sensor discarded for ${name}","DEBUG")
    } 
}
   
def sensorDevices(evt, name=null, type=null, state=null, device=null, multiple=false) {  // subs must be used in HA discovery as device must be separated into multiple entities
	if (evt!=null)
	{
		name=evt.displayName
        device=evt.getDevice()
		state=evt.value
		xType=evt.name  // attribute name
		log ("[s] This got called by event ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${xType} ${evt.getDisplayName()}", "DEBUG")
	} 
	else {
		xType=type
		if (multiple) nameSuffix='_'+type else nameSuffix=''
		xName=name+nameSuffix
		log ("sensorDevices (synch) called with name:${name}    xName: ${xName}    type: ${type} / ${xType}   state: ${state}    multiple: ${multiple}","DEBUG")
	}    
	    normName = normalize(name)
		normxName = normalize(xName)
        settable="false"
		HAtype='unknown'
		UOM=''
        mqtt = getChildDevice("MQTT: Child device driver")
		if (settings?.homiePublish) {  //TODO use case rather than if else if
			sTopic="homie/${atomicState.normHubName}/${normName}"            
//			if (xType=='motion' || xType=='acceleration'){
        if (xType=='switch'){  
			category='onoff'
			HAtype="switch"
			if (!atomicState.suppress) {
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype','boolean',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)	
			}
		}
		else if (xType=='motion' || xType=='acceleration'){
				category=xType
				if (!atomicState.suppress) mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)
				HAtype="binary_sensor"
				payON="active"
				payOFF="inactive"
				if (state==payON) {
					//mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist)
					state='true'  // Need to choose between boolean and enum
				}
				else if (state==payOFF){
					//mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist)
					state='false'  // Need to choose between boolean and enum
				}
			}            
           else if (xType=='push'){  // don't think this can this ever run 
               log ("Button push event running in sensors", "ERROR")
			   category='button'
               if (!atomicState.suppress){
				    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,atomicState.suppress)
               }
				HAtype="button"
			}           
			else if (xType=='contact'){
				category='contact'
				if (!atomicState.suppress) mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)  // Need to choose between boolean and enum
				HAtype="binary_sensor"
				payON="open"
				payOFF="closed"
				if (state==payON) {
					//mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
					//mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist)
					state='false'  // Need to choose between boolean and enum
				}
			}
			else if (xType=='temperature'){
				category='measure-temperature'
                if(tempUnits=="Celsius x.x°C" && category=="measure-temperature") state = state.toFloat().round(1)
                else if(tempUnits=="Fahrenheit x.x°C" && category=="measure-temperature") state = state.toFloat().round(1)
                if (!atomicState.suppress){
				    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
				    //mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				    if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				    mqtt.publishMsg (sTopic+'/'+category+'/$format','-460:9999',1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
                }
				HAtype="sensor"
			}          
 			else if (xType=='humidity'){
				category='measure-humidity'
                if (!atomicState.suppress){
				    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$unit','%',1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,atomicState.suppress)				
                }
                UOM="%"
				HAtype="sensor"
			}
            else if (xType=='pressure'){   // TODO Needs attention - hard coded units 
                category='measure-pressure'
                if (!atomicState.suppress){
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$unit','mBar',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$format','750:1500',1,true,atomicState.suppress)        
                }
                UOM="mBar"
                HAtype="sensor"
            }
			else if (xType=='battery'){
				category='measure-battery'
                if (!atomicState.suppress){
				    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$unit','%',1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,atomicState.suppress)
                }
				UOM="%"
				HAtype="sensor"
			}
			else if (xType=='energy'){
				category='measure-energy'   // value and unit enum KWh
				UOM="watts"
			}
			else if (xType=='illuminance'){
				category='measure-illuminance'   // value and unit enum lux
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','Lux',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:999999',1,true,atomicState.suppress)
                UOM="Lux"
                HAtype='sensor'
			}
           else if (xType=='variable'){
				category='variable'   // value and unit enum lux
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"string",1,true,atomicState.suppress)
                settable='true'
                HAtype='sensor'   //needs updating
			}
			else if (xType=='smoke'){
				category='smoke-alarm'  //enum clear|detected|tested
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)
				HAtype="binary_sensor"
				payON="detected"
				payOFF="clear"
				if (state==payON) {
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist)
					state='false'  // Need to choose between boolean and enum
				}
				// TODO this is an enum value and has a 'tested' variant
			}
            else if (xType=='presence'){
				category='presence-sensor'  //enum home|away
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)
				HAtype="binary_sensor"
				payON="present"
				payOFF="not present"
				if (state==payON) {
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist)
					state='false'  // Need to choose between boolean and enum
				}
				// TODO this is an enum value and has a 'tested' variant
			}
			else if (xType=='carbonMonoxide'){
				category=xType+'-alarm'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)
				HAtype="binary_sensor"
				payON="detected"
				payOFF="clear"
				if (state==payON) {
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist)
					state='false'  // Need to choose between boolean and enum
				}
				// TODO this is an enum value and has a 'tested' variant
			}
           else if (xType=='carbonDioxide'){
				category='measure-carbonDioxide'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				HAtype="sensor"
				// TODO this is an enum value and has a 'tested' variant
			}
			else if (xType=='sound'){
				category='sound-level'   // detected|not detected
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:999999',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','dB',1,true,atomicState.suppress)
				UOM="dB"
				HAtype="sensor"
			}
			else if (xType=='voltage'){
				category='measure-voltage'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','volts',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','-999999:999999',1,true,atomicState.suppress)
				UOM="volts"
				HAtype="sensor"
			}
			else if (xType=='power'){  // TODO is it this or 'energy' above ?
				category='measure-power'
                if (!atomicState.suppress){
				    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$unit','watts',1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$format','0:999999',1,true,atomicState.suppress)
                }
				UOM="watts"
				HAtype="sensor"
			}
            else if (xType=='energy'){  // TODO is it this or 'energy' above ?
				category='measure-energy'
                if (!atomicState.suppress){
				    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$unit','watts',1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$format','0:999999',1,true,atomicState.suppress)
                }
				UOM="watts"
				HAtype="sensor"
			}
			else if (xType=='water'){
				category='water'
				HAtype="binary_sensor"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)
				payON="wet"
				payOFF="dry"
				if (state==payON) {
					mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
					mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist)
					state='false'  // Need to choose between boolean and enum
				}
			}
            else if (xType=="securityKeypad"){
                log ("securityKeypad ${name} reported ${state} in sensors","WARN")
                 }
			else {
				category = 'unknown'
				log ("[s] Unknown Category for type ${xType} reported by device ${name}","DEBUG")  // DEBUG because Unknowns are now converted to custom
			}
			
			sTopic="homie/${atomicState.normHubName}/${normName}"     //+category
			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',category,1,true)   // limited homie implementation //  TODO BUG multiple properties
	        //atomicState.Category=category  // Huge risk here that this gets overwritten before update happens BUG TODO maybe have to check against sTopic
	        //pauseExecution(2000)// TODO need to adjust based on experience getTopic takes ~1800
	        //mqtt.getTopic (sTopic+'/$properties')   // need to append categories to existing ones
        if (!atomicState.suppress) {
            //addProperty(sTopic,category)          
			mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			mqtt.publishMsg (sTopic+'/$type',"sensor",1,true,atomicState.suppress)
            if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
            if (category=='unknown') {
                if (device.displayName!=lastDev) {
                    counter=1
                    addProperty(sTopic,'custom',device)
                } else {
                    if (counter==null) counter=0
                    counter = counter +1
                }
                lastDev=device.displayName
                mqtt.publishMsg (sTopic+'/custom',counter.toString(),1,true)
                mqtt.publishMsg (sTopic+'/custom/$datatype','integer',1,true)
                mqtt.publishMsg (sTopic+'/custom/$name',device.displayName,1,true)
                mqtt.publishMsg (sTopic+'/custom/$retained','true',1,true)
                mqtt.publishMsg (sTopic+'/custom/$settable','false',1,true)
                mqtt.publishMsg (sTopic+'/custom/'+xType,state.toString(),1,true) 
            }
            else{
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable',settable,1,true,atomicState.suppress)   
			    mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,atomicState.suppress)  
			    //mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
			    //mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
            }
        }
        if (category!='unknown') {
            //mqtt.publishMsg (sTopic+'/'+category+'/'+xType,state.toString(),1,true)   // DO WE NEED THIS ?
            if (state!=null) {
                mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist)  // <<<<<   This publishes the actual event value
                checkNodes(9, name)
	            if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		            if (multiple) {
			            HADiscoveryAdvertise(name,HAtype,category,device.id,payON,payOFF,nameSuffix,UOM)  // these are created as sub topics
		            }
		            else  HADiscoveryAdvertise(name,HAtype,category,device.id,payON,payOFF,'',UOM)  // will only be called once
	            }
	            else if (settings?.HADiscovery) log ("HADiscovery sensor discarded for ${name}","DEBUG")
            }
        }
    }
}

def colourDevices(evt, name=null,type=null, state=null, device=null) {
    openHAB=false // setting true forces reported dim value to 0-1.0
    mqtt = getChildDevice("MQTT: Child device driver")

	if (evt!=null)
	{
        device=evt.getDevice()
        name=evt.displayName
		state=evt.value
		xName=evt.name
		xType=evt.name  // this is the attribute name
		log ("Got a colour event " + evt.name + " " + evt.value, "INFO")
        if (lastDev== "$name [$state]") lastDev=''
        else {
            dType = device.getTypeName()
            if (dType.startsWith("Virtual")) // only allow commands to MQTT from virtuals
            {
                cMQTT=device.getDataValue("mqtt")
                if (cMQTT=="enabled") {
                    cTopic=device.getDataValue("color_Cmd") 
                    if(cTopic!=null) {
                        log ("(colourDevices) Sending command to MQTT $cTopic","TRACE")
                        mqtt.publishMsg (cTopic,state,1,false)
                    }
                }
            }
	    }
    }
	else {
        
		xName=name
		xType=type
		log ("Got a colour synch " + xName + " " + type + " " + state, "DEBUG") 
        if (state==null) log ("State had a null value for $xName $xType","WARN")
	}
    //log ("Received a new colour event ${xType} [$state] from ${name}","LOG")
    
    if (xType=='switch') prop='onoff'
    if (xType=='level') prop='dim'
    if (xType=='colorTemperature') prop='color-temperature'
    if (xType=='hue') prop='color'
    if (xType=='saturation') prop='color'
    if (xType=='hsv') prop='color'
    if (xType=='color') prop='color'
    if (xType=='colorMode') prop='color-mode'
    if (xType=='cMode') prop='color-mode'
    if (xType=='colorName') prop='color-name'
    if (xType=="RGB"||xType=="RGBT") prop='color'
    if (prop=='color') addProperty(sTopic,'color',device)   
    
	normName = normalize(name)
	normxName = normalize(xName)
	sTopic="homie/${atomicState.normHubName}/${normName}"
   // addProperty(sTopic,prop,device)
    
    if (!dAttIsEnabled(device,prop)) {
            log ("$device [$xType] > [$prop] publish topics BLOCKED","DEBUG")
            return
        }
    else log ("$device [$xType] > [$prop] publish topics PASSED","TRACE")

	if (settings?.homiePublish) {  //TODO case rather than if

        if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true)
		category='unknown'
        if (xType=='switch'){   // hope this doesnt conflict with switchedDim - ot is called
				category='onoff'
            	//HAtype="RGB"
                log("switch in RGB","KH")
            if (!atomicState.suppress) {
                
                if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype','boolean',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)	
				//UOM="%"
            }
		}
        else if (xType=='dim'){  // DONT think this happens
				category='DIM'
                //HAtype="RGB"
                log("dim in RGB","KH")
            if (!atomicState.suppress) {
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit','?',1,true)
                if (openHAB) mqtt.publishMsg (sTopic+'/'+category+'/$format','0:1',1,true,atomicState.suppress)
				else mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)	
				//UOM="%"
            }				
		}
		else if (xType=='colorTemperature'){
				category='color-temperature'
            	//HAtype="RGB"
            if (!atomicState.suppress) {
                mqtt.publishMsg (sTopic+'/$type',"CT light",1,true,atomicState.suppress)
                if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','Kelvin',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','1500:8000',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)
            }
                //int mireds=(int)1000000/state.toInteger()
                int mireds=state.toInteger() //@jwilliams
                if (mireds>1000) mireds=(int)1000000/mireds // was Kelvin
                mqtt.publishMsg (sTopic+'/'+category+'/mireds',"${mireds}",1,true)
                mqtt.publishMsg (sTopic+'/'+category+'/temp',"${mireds}",1,true)
				//UOM="%"

		}
		else if (xType=='hue'){
			    category='color'
            	//HAtype="RGB"
            if (!atomicState.suppress) {
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"color",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/h',state.toString(),1,settings?.homieStatesPersist,atomicState.suppress)  //unnecessary ?
				//int temp=state.toInteger()
				//temp=(temp*36)/10  //TODO Taken out to keep 0-100 'low' but wary if I should have done so
            }
                //theDevice=evt.getDevice()
                //hueNum=state.toInteger()
                hueNum=device.currentValue("hue")
                Integer LHueNum = (hueNum*3.6).toInteger()
                //hueNum=hueNum*3.6
                satNum=device.currentValue("saturation")
                valNum=device.currentValue("level")                    
                        log ("H: ${hueNum} ${satNum} ${valNum}","DEBUG")
                        //oldRGB=hsvToRGB (hueNum*3.6,satNum, valNum,"high")
                        RGB=hubitat.helper.ColorUtils.hsvToRGB([hueNum,satNum, valNum])
                        mqtt.publishMsg (sTopic+'/'+category,"${LHueNum},${satNum},${valNum}",1,true)     // TODO CHECKRGB  
                        mqtt.publishMsg (sTopic+'/color/rgb',hubitat.helper.ColorUtils.rgbToHEX(RGB),1,settings?.homieStatesPersist)
		}
		else if (xType=='level'){  //hope this doesn't conflict with dimmed  (this is dim)
				category='color'
            	//HAtype="RGB"
            if (!atomicState.suppress) {
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)
            }
				mqtt.publishMsg (sTopic+'/'+category+'/v',state.toString(),1,settings?.homieStatesPersist)  // TODO Check is this right  // unnecessary ?
                //theDevice=evt.getDevice()
                hueNum=device.currentValue("hue")
                if (hueNum == null) hueNum = 0
                LHueNum = (hueNum*3.6).toInteger()
                satNum=device.currentValue("saturation")
                if (satNum == null) satNum = 0
                valNum=device.currentValue("level")
     
// Kludge for OH
            if (openHAB) {
                float smallDim = valNum/100
                mqtt.publishMsg (sTopic+'/dim',smallDim.toString())
            }
            else  mqtt.publishMsg (sTopic+'/dim',valNum.toString())
//END Kludge OH
                        //log ("V: (${LHueNum}) ${hueNum} ${satNum} ${valNum}","INFO")
                        RGB=hubitat.helper.ColorUtils.hsvToRGB([hueNum,satNum, valNum])
                        mqtt.publishMsg (sTopic+'/'+category+'/rgb',hubitat.helper.ColorUtils.rgbToHEX(RGB),1,true)                   
                        mqtt.publishMsg (sTopic+'/'+category,"${LHueNum},${satNum},${valNum}",1,true)             

		}
		else if (xType=='saturation'){   
				category='color'
            	//HAtype="RGB"
            if (!atomicState.suppress) {

				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"color",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)
            }
				mqtt.publishMsg (sTopic+'/'+category+'/s',state.toString(),1,settings?.homieStatesPersist)  // unnecessary ??
                //theDevice=evt.getDevice()
                hueNum=device.currentValue("hue")
                LHueNum = (hueNum*3.6).toInteger()                            
                satNum=device.currentValue("saturation")
                valNum=device.currentValue("level")                
                        //log ("S: ${hueNum} ${satNum} ${valNum}","INFO")
                        //oldRGB=hsvToRGB (hueNum*3.6,satNum, valNum,"high")
                        RGB=hubitat.helper.ColorUtils.hsvToRGB([hueNum,satNum, valNum])
                        mqtt.publishMsg (sTopic+'/'+category+'/rgb',hubitat.helper.ColorUtils.rgbToHEX(RGB),1,true)
                        mqtt.publishMsg (sTopic+'/'+category,"${LHueNum},${satNum},${valNum}",1,true)             
				//UOM="%"


		}
		else if (xType=="hsv") {
		    category='color'
            //HAtype="RGB"
            if (!atomicState.suppress) {			
				mqtt.publishMsg (sTopic+'/$type',"RGBT light",1,true,atomicState.suppress)
                if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"color",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/h',state[0].toString(),1,settings?.homieStatesPersist)
				//mqtt.publishMsg (sTopic+'/'+category+'/s',state[1].toString(),1,settings?.homieStatesPersist)
				//mqtt.publishMsg (sTopic+'/'+category+'/v',state[2].toString(),1,settings?.homieStatesPersist)  // TODO Check is this right
				//mqtt.publishMsg (sTopic+'/color',"${state[0]},${state[1]},${state[2]}",1,settings?.homieStatesPersist)
	   			mqtt.publishMsg (sTopic+'/color/$format','hsv',1,true,atomicState.suppress)
            }
    //jwilliams for Ikea Tradfri tolerance  // I may have messed this up again now                    
            if (state[0] != null) hue = state[0].intValue()
            else {
                hue = device.currentValue("hue")
                //state[0]=hue
            }
            LHueNum = (hue*3.6).toInteger()
            if (state[1] != null) sat = state[1].intValue()
            else {
                   sat=device.currentValue("saturation")
                   //state[1]=sat
            }
            if (state[2] != null) val = state[2].intValue()
            else {
                   val=device.currentValue("level")
                   //state[2]=level
            }    
     // end jwilliams
            
        
            mqtt.publishMsg (sTopic+'/color',"${LHueNum},${sat},${val}",1,settings?.homieStatesPersist)
		        //mqtt.publishMsg (sTopic+'/color','{"h":'+state[0].toString()+',"s":'+state[1].toString()+',"v":'+state[2].toString()+'}',1,settings?.homieStatesPersist)
                //if (state[2] == null) int val=99 else int val=state[2].intValue()     
                //oldRGB=hsvToRGB (hue*3.6,sat, val,"high")
                RGB=hubitat.helper.ColorUtils.hsvToRGB([hue,sat, val])          
                mqtt.publishMsg (sTopic+'/color/rgb',hubitat.helper.ColorUtils.rgbToHEX(RGB),1,settings?.homieStatesPersist)            
                // mqtt.publishMsg (sTopic+'/'+category,"[${hueNum},${satNum},${valNum}]",1,true)   // TODO check - should this be enabled             
         
		}
	    else if (xType=='onoff'){   // Dont think this happens  - this topic created by the 'switched' event
			category='ONOFF'
            //HAtype="RGB"
            log("onoff in RGB","KH")
            if (!atomicState.suppress) {
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype','boolean',1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit','?',1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)	
				//UOM="%"
            }
				
		}

        else if (xType=='colorName'){   // hope this doesnt conflict with switchedDim - ot is called
			category='color-name'
            //HAtype="RGB"
            if (!atomicState.suppress) {
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype','text',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','false',1,true,atomicState.suppress)
            }        
		}
        else if (xType=="cMode") {
            category='color-mode' // this is a temporary kludge TODO better
			//HAtype="RGB"
            if (!atomicState.suppress) {
                //mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype','enum',1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable','false',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[CT,RGB]',1,true,atomicState.suppress)
            }
        }
         else if (xType=="colorMode") {
            category='color-mode' // this is a temporary kludge TODO better
			//HAtype="RGB"
            if (!atomicState.suppress) {
                //mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype','enum',1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable','false',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[CT,RGB]',1,true,atomicState.suppress)
            }
        }
        else if (xType=="RGB"||xType=="RGBT") {
            category='color' // this is a temporary kludge TODO better
			log ("Ignoring ${xTYPE} for  ${name.toString()} value ${state.toString()}","WARN")
			return  // This is overwriting color attribute with #FFFFFF as currentColor() returns that so dont action
		}
        else if (xType=='rgbInit'){
                //mqtt.publishMsg (sTopic+'/'+category+'/hsv','right place',1,true,atomicState.suppress)
            }
       // else HAType="nowt"
        else if (xType=='color'){
            log ("color attribute in [$dev] colourDevices [$state]","LOG")
            category="colour"
            return
            }
 
        
        if (category=="unknown") {
            log ("Need to handle ${xType}  - for ${name.toString()} in RGB colour", "WARN")
            //log ("Just published unknown [$xType] for ${name.toString()} payload ${state.toString()}","LOG")
            category="unknown_${xType.toLowerCase()}"
        }
            
        if (!atomicState.suppress){
//            addProperty(sTopic,category,device)
			mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true) 
//			mqtt.publishMsg (sTopic+'/$type',"RGBT light",1,true,atomicState.suppress)
		 	mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,atomicState.suppress)
            //  mqtt.publishMsg (sTopic+'/'+category+'/xType',xType.toString(),1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
        }
        if (state=="on") state = "true" 
		else if (state=='off') state = "false"  // TODO customisable
        // if (category == 'unknown' ) mqtt.publishMsg (sTopic+'/'+category + '/' + xType,state.toString(),1,settings?.homieStatesPersist)
        if (!dAttIsEnabled(device,category)) {
            log ("$device $category publish state BLOCKED","DEBUG")
            return
        }
        if ("${category}" != 'color') {  // hue was overwriting color map - need to check why I even do next publish TODO BUG ? 
            //log ("HSV value update blocked","DEBUG")
            //log ("Published $state to $sTopic/$category","KH")
            if (state!=null) mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist)
            else log ("State was null so didn't update MQTT for $sTopic","WARN")
        }
    
	//	mqtt.publishMsg (sTopic+'/color/r',255,1,settings?.homieStatesPersist)  /? TODO What is this for ? HA ? Red ? but no g or b ??	
	//  {"h":216,"s":100,"v":67}
	//  TODO BUG refine this by checking name matches (if use this)
	//	mqtt.publishMsg (sTopic+'/color',"${extractInt(atomicState.hue)},${extractInt(atomicState.sat)},${extractInt(atomicState.lev)}",1,settings?.homieStatesPersist)
    //  mqtt.publishMsg (sTopic+'/color/$format','hsv',1,true,atomicState.suppress)
	//	mqtt.publishMsg (sTopic+'/color/hsv','{"h":'+extractInt(atomicState.hue)+',"s":'+extractInt(atomicState.sat)+',"v":'+extractInt(atomicState.lev)+'}',1,settings?.homieStatesPersist)
	}
    checkNodes(10, name) 
	if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		HADiscoveryAdvertise(name,"light","colour", device.id)
	}
	else if (settings?.HADiscovery) log ("HADiscovery RGB discarded for ${name}","DEBUG")	
}
def checkNodes(p,name) {
        normName=normalize(name)
    if (name==null) {
            log ("[$p] null node name ", "WARN")
    }
        else if (nodes.contains("$normName")){}
        else {
             nodes+=','+normName
            if (settings?.homiePublish) {
                mqtt = getChildDevice("MQTT: Child device driver")
                mqtt.publishMsg ("homie/${atomicState.normHubName}/"+'$nodes',nodes,1,true)
        }
        }
}


//#######################################################################################################################################
//#########################   This section adds the names to the dropdown selectors and creates the devices   ###########################
//#######################################################################################################################################

def homieOnOffDev(name,type) {
	temp = atomicState.onoffDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in dropdown list:OnOff $name", "WARN")
	}
	else { 
		log ("Adding to homie dropdown list:OnOff $name", "WARN")
		temp.add(name)
		atomicState.onoffDevices=temp
	}
	if ((settings?.Homie_onoff != null) && (settings?.Homie_onoff.contains (name))) createChildDevice (name, "onoff", "homie", name)
}

def homieDimDev(name,type) {  //TODO merge with above
	temp = atomicState.dimDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in list:Dimmer $name", "TRACE")
	}
    
	else {
		log ("Adding to homie dropdown list:Dimmer $name", "TRACE")
		temp.add(name)
		atomicState.dimDevices = temp
	}
    if ((settings?.Homie_dim != null) && (settings?.Homie_dim.contains (name))) createChildDevice (name, "dim", "homie", name)
}

def homieButtonDev(name,type) {
	temp = atomicState.buttonDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in dropdown list: $name", "TRACE")
	}
	else { 
		log ("Adding to homie dropdown list: $name", "TRACE")
		temp.add(name)
		atomicState.buttonDevices=temp
	}
		if ((settings?.Homie_button != null) && (settings?.Homie_button.contains (name)))  createChildDevice (name, "button", "homie", name)
}

def homieVariableDev(name,type) {
    temp = atomicState.varDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in dropdown list: $name", "TRACE")
	}
	else { 
		log ("Adding to homie dropdown list: $name", "TRACE")
		temp.add(name)
		atomicState.varDevices=temp
	}
		if ((settings?.Homie_variable != null) && (settings?.Homie_variable.contains (name))) createChildDevice (name, "variable", "homie", name)
}

def homieSensorDev(name,type) {  //TODO merge with above
	temp = atomicState.sensorDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
	log ("Already in list: $name", "TRACE")
	}
	else {
		log ("Adding sensor to homie list: $name", "TRACE")
		temp.add(name)
		atomicState.sensorDevices = temp
	}
	if ((settings?.Homie_sensor != null) && (settings?.Homie_sensor.contains (name))) createChildDevice (name, "sensor", "homie", name)
}

def homieUnknownDev(name,type) { //TODO merge
    atomicState.homieUnknownDevices=[]
	temp = atomicState.homieUnknownDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
	    log ("Already in homie unknown list: $name", "TRACE")
	}
	else {
		log ("Adding to homie unknown list: $name", "TRACE")
		temp.add(name)
		atomicState.homieUnknownDevices = temp
	}
    log ("homie currently unsupported device $name $type", "WARN")
	//if ((settings?.Homie_unknowns != null) && (settings?.Homie_unknowns.contains (name))) createChildDevice (name, "unknown", "Shelly", name)
}

//Casey <
def homieLockCapability(name,type) { 
	temp = atomicState.lockDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in dropdown list: $name", "TRACE")
	}
	else {
		log ("Adding to homie lock dropdown list: $name", "TRACE")
		temp.add(name)
		atomicState.lockDevices=temp
	}
	if ((settings?.Homie_lock != null) && (settings?.Homie_lock.contains (name)))createChildDevice (name, "lock", "homie", name) 
}
//Casey >
def ShellyDev(name,state) {
    log ("Found Shelly Device $name but not yet supported","INFO")
    if (payload[0] == "true") log  ("(Shelly device $name is online)", "LOG")
    else if (payload[0] == "false") log  ("(Shelly device $name is online)", "LOG")

/*
    shellyType=name.substring(0,name.indexOf('-'))
    if (shellyType=='shellyswitch25')
    {
       onoffCapabilityShelly(name + ' relay 0')
       onoffCapabilityShelly(name + ' relay 1') 
    }
    else log ("currently unsupported type #${shellyType}#","WARN")
*/
}
def dimCapabilityShelly(evt) { //TODO merge
    log  ("Shelly Dim  support not implemented yet !", "WARN")
}

def onoffCapabilityShelly(evt) { //TODO
	temp = atomicState.ShellyDevices
    def data = parseJson(evt.data)
	if (temp==null) temp=[]
	if (temp.contains(name)) {
	log ("Already in list: $name", "TRACE")
	}
	else {
		log ("Shelly adding relay to list: $name", "TRACE")
		temp.add(name)
		atomicState.ShellyDevices = temp
	}
	if ((settings?.ShellyDevices != null) && (settings?.ShellyDevices.contains (name)))createChildDevice (name, "onoff", "Shelly", name)  
}



def HASwitchFriendlyP(name,label,type) {
    temp = atomicState.HASwitchDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		//log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HA Adding switch to list: $name label ", "TRACE")
		temp.add(name)
		atomicState.HASwitchDevices = temp
	}
    if ((settings?.HA_Switches != null) && (settings?.HA_Switches.contains (name)))  createChildDevice (name, type, "HA", label)
    
}


def HALightFriendlyP (name,label,type){
    temp = atomicState.HALightDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		//log("Already in list: ${name}", "TRACE")
	}
	else {
		log ("HA Adding light to list: ${name}  label ", "TRACE")
		temp.add(name)
		atomicState.HALightDevices = temp
	}
	if ((settings?.HA_Lights != null) && (settings?.HA_Lights.contains (name))) createChildDevice (name, type, "HA", label)  
}

def HASensorTypeP (topic2,payload,topic1) {    //   (topic[2],deQuote(payload[0]),topic[1])
    HASensorType(topic2,payload,topic1)
}


def HASensorType(topic2,payload,topic1) { //device_type
    sType=payload
    log ("HA Sensor $topic2 device_type $sType","TRACE")
	temp = atomicState.HASensorDevices
	if (temp==null) temp=[]
    label=topic2
    //if (data.label==null) label=name
	if (temp.contains(topic2)) {
		log ("Already in list: $topic2", "TRACE")
	}
	else {
		log ("HA Adding sensor to list: $topic2  $label ", "TRACE")
		temp.add(topic2)
		atomicState.HASensorDevices = temp
	}
	createChildDevice (topic2, topic1, "HA", label, sType)  //this creates a sensor device of type device_class
}

def HASensorFriendlyP (name,label,type) {
	temp = atomicState.HASensorDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in list: ${name}", "TRACE")
	}
	else {
		log ("HA Adding sensor to list: $name  $type ", "TRACE")
		temp.add(name)
		atomicState.HASensorDevices = temp
	}
        if ((settings?.HA_Sensors != null) && (settings?.HA_Sensors.contains (name)))  createChildDevice (name, type, "HA", label)
} 

def HABinarySensorDevP (name,label,type) {
  	temp = atomicState.HABinarySensorDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
        //log ("Already in list: $name $type", "TRACE")
	}
	else {
		log ("HA Adding binary sensor to list: $name  $type", "TRACE")
		temp.add(name)
		atomicState.HABinarySensorDevices = temp
	}
    if ((settings?.HA_BinarySensors != null) && (settings?.HA_BinarySensors.contains (name)))  createChildDevice (name, type, "HA", name, type)     
}

def HAGroupFriendlyP(name, label , type) {  // TODO merge with above
	temp = atomicState.HAGroupDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		//log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HA Adding group to list: $name  $type ", "TRACE")
		temp.add(name)
		atomicState.HAGroupDevices = temp
	}
	if ((settings?.HA_Groups != null) && (settings?.HA_Groups.contains (name))) createChildDevice (name, type, "HA", label)
}

def HACoverFriendlyP(name, label, type) {  // TODO merge with above
	temp = atomicState.HACoverDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		//log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HA Adding cover to list: $name  $type ", "TRACE")
		temp.add(name)
		atomicState.HACoverDevices = temp
	}
    if ((settings?.HA_Covers != null) && (settings?.HA_Covers.contains (name)))  createChildDevice (name, type, "HA", label)
}
    
def HALockFriendlyP(name,label,type) {  // TODO merge with above
	temp = atomicState.HALockDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		//log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HA Adding lock to list: $name  $type ", "TRACE")
		temp.add(name)
		atomicState.HALockDevices = temp
	}
	if ((settings?.HA_Locks != null) && (settings?.HA_Locks.contains (name))) createChildDevice (name, type, "HA", label)
}
    
def HAClimateFriendlyP(name,label,type) {  // TODO merge with above
    //log ("Incoming HA friendlyname for $type $name [$label]","LOG")
	temp = atomicState.HAClimateDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HA Adding climate to list: $name  label ", "TRACE")
		temp.add(name)
		atomicState.HAClimateDevices = temp
	}
	if ((settings?.HA_Climates != null) && (settings?.HA_Climates.contains (name)))  createChildDevice (name, type, "HA", label)

}

    
def HADeviceTrackerFriendlyP(name,label,type) {  // TODO merge with above
	temp = atomicState.HADeviceTrackerDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		//log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HA Adding device tracker to list: $name  label ", "TRACE")
		temp.add(name)
		atomicState.HADeviceTrackerDevices = temp
	}
    if ((settings?.HA_DeviceTrackers != null) && (settings?.HA_DeviceTrackers.contains (name))) createChildDevice (name, type, "HA", label)
}
def HAInputBooleanFriendlyP(name,label,type) {  // TODO merge with above
	temp = atomicState.HAInputBooleanDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		//log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HA Adding group to list: $name $type ", "TRACE")
		temp.add(name)
		atomicState.HAInputBooleanDevices = temp
	}
    if ((settings?.HA_InputBooleans != null) && (settings?.HA_InputBooleans.contains (name)))  createChildDevice (name, type, "HA", label)
}

def HAPresenceFriendlyP(name,label,type) {  // TODO merge with above
	temp = atomicState.HAPresenceDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		//log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HA Adding group to list: $name $type ", "TRACE")
		temp.add(name)
		atomicState.HAPresenceDevices = temp
	}
    if ((settings?.HA_Presence != null) && (settings?.HA_Presence.contains (name)))  createChildDevice (name, type, "HA", label)
}

def HAUnknown(name,payload) { //TODO merge with above
	temp = atomicState.HAUnknownDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log("Already in HA unknown list: $name", "TRACE")
	}
	else {
		log ("HA Adding unknown to list: $name  label ", "TRACE")
		temp.add(name)
		atomicState.HAUnknownDevices = temp
	}
    log ("HA unsupported [$type] device $name  $payload", "LOG")
	//createChildDevice (name, type, "HA", name)
}

def HAInSwitch(name,label,type,config=null) {
    log ("Called Switch HAIn","KH")
    if (config==null) log("$name called switch with no config","KH")
    temp = atomicState.HAInSwitchDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in list: $name", "KH")
	}
	else {
		log ("HAIn Adding switch to list: $name label ", "TRACE")
		temp.add(name)
		atomicState.HAInSwitchDevices = temp
	}
    if ((settings?.HAIn_switch != null) && (settings?.HAIn_switch.contains (name)))  {
        log ("Creating from HA Discovery [$type] device $name", "LOG")
        createChildDevice (name, type, "HADisc",label, null, null, config)
    }
}
def HAInSensor(name,label,type,config=null) {
   if (config==null) log("$name called sensor with no config","KH")
    temp = atomicState.HAInSensorDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HAIn Adding sensor to list: $name label ", "TRACE")
		temp.add(name)
		atomicState.HAInSensorDevices = temp
	}
    if ((settings?.HAIn_sensor != null) && (settings?.HAIn_sensor.contains (name))){
        log ("Creating Discovery [$type] device $name", "DEBUG")
        createChildDevice (name, type, "HADisc", label, null, null, config)
    }
}
def HAInLight(name,label,type,config=null) {
    if (config==null) log("$name called light with no config","KH")
    temp = atomicState.HAInLightDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HAIn Adding light to list: $name label ", "TRACE")
		temp.add(name)
		atomicState.HAInLightDevices = temp
	}
    if ((settings?.HAIn_light != null) && (settings?.HAIn_light.contains (name))) {
        log ("Creating [$type] Discovery device $name", "DEBUG")
        createChildDevice (name, type, "HADisc", label, null, null, config)
    }
}
def HAInBinarySensor(name,label,type,config=null) {
    if (config==null) log("$name called binary_sensor with no config","KH")
    temp = atomicState.HAInBinarySensorDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HAIn Adding binary sensor to list: $name label ", "TRACE")
		temp.add(name)
		atomicState.HAInBinarySensorDevices = temp
	}
    if ((settings?.HAIn_binary != null) && (settings?.HAIn_binary.contains (name))) createChildDevice (name, type, "HADisc", label, null, null, config)
}
def HAInClimate(name,label,type,config=null) {
    temp = atomicState.HAInClimateDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HAIn Adding climate to list: $name label ", "TRACE")
		temp.add(name)
		atomicState.HAInClimateDevices = temp
	}
    if ((settings?.HAIn_climate != null) && (settings?.HAIn_climate.contains (name))) createChildDevice (name, type, "HADisc", label, null, null, config)
}
def HAInCover(name,label,type,config=null) {
    temp = atomicState.HAInCoverDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HAIn Adding cover to list: $name label ", "TRACE")
		temp.add(name)
		atomicState.HAInCoverDevices = temp
	}
    if ((settings?.HAIn_climate != null) && (settings?.HAIn_climate.contains (name))) createChildDevice (name, type, "HADisc", label, null, null, config)
}
def HAInLock(name,label,type,config=null) {
    temp = atomicState.HAInLockDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HAIn Adding lock to list: $name label ", "TRACE")
		temp.add(name)
		atomicState.HAInLockDevices = temp
	}
    if ((settings?.HAIn_climate != null) && (settings?.HAIn_climate.contains (name))) createChildDevice (name, type, "HADisc", label, null, null, config)
}
def HAInAutomation(name,label,type,config=null) {
    temp = atomicState.HAInAutomations
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HAIn Adding automation to list: $name label ", "TRACE")
		temp.add(name)
		atomicState.HAInAutomations = temp
	}
    if ((settings?.HAIn_automation != null) && (settings?.HAIn_automation.contains (name))) createChildDevice (name, type, "HADisc", label, null, null, config)
}
def HAInGroup(name,label,type,config=null) {
    temp = atomicState.HAInGroups
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HAIn Adding group to list: $name label ", "TRACE")
		temp.add(name)
		atomicState.HAInGroups = temp
	}
    if ((settings?.HAIn_group != null) && (settings?.HAIn_group.contains (name))) createChildDevice (name, type, "HADisc", label, null, null, config)
}
def HAInPerson(name,label,type,config=null) {
    temp = atomicState.HAInPersonDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HAIn Adding person to list: $name label ", "TRACE")
		temp.add(name)
		atomicState.HAInPersonDevices = temp
	}
    if ((settings?.HAIn_person != null) && (settings?.HAIn_person.contains (name))) createChildDevice (name, type, "HADisc", label, null, null, config)
}

def zigbee2mqttLight(name,label,type) {
    temp = atomicState.zigbee2mqttLightDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in list: $name", "KH")
	}
	else {
		log ("HAIn Adding light to list: $name label ", "KH")
		temp.add(name)
		atomicState.zigbee2mqttLightDevices = temp
	}
    if ((settings?.zigbee2mqtt_light != null) && (settings?.zigbee2mqtt_light.contains (name))) createChildDevice (name, type, "HADisc", label)
}

def CBusCreate(name,type,CBgroup,topic) {
    if (type=='light') {
        temp = atomicState.CBusLightDevices
	    if (temp==null) temp=[]
	    if (temp.contains(name)) {
		    log ("Already in list: $name", "KH")
	    }
	    else {
		    log ("C-Bus In -  Adding light to list: $name label ", "KH")
		    temp.add(name)
		    atomicState.CBusLightDevices = temp
	    }
        // def createChildDevice(name, type, system, friendlyName=null, dType='default',seq=0, config=null)
        if ((settings?.CBus_light != null) && (settings?.CBus_light.contains (name))) createChildDevice (name, 'light', "C-Bus",name, CBgroup) //, level)
    }
    else if (type=='temperature') { 
        temp = atomicState.CBusTextDevices
	    if (temp==null) temp=[]
	    if (temp.contains(name)) {
		    //log ("Already in list: $name", "KH")
	    }
	    else {
		    //log ("C-Bus In Adding text to list: $name label ", "KH")
		    temp.add(name)
		    atomicState.CBusTextDevices = temp
	    }
        if ((settings?.CBus_text != null) && (settings?.CBus_text.contains (name))) createChildDevice (name, 'sensor', "C-Bus",name, CBgroup, type)
    }
}

def wildcardTopics(topics) {  // TODO merge with above
	temp = atomicState.devTopics
	if (temp==null) temp=[]
	if (temp.contains(topics)) {
		log ("Already in list: $topics", "WARN")
	}
	else {
		log ("Adding wildcarded topic to list: $topic", "WARN")
		temp.add(topic)
		atomicState.devTopics = temp
	}
}

//########################################################################################################################################
//###########################  This section finds the device from incoming MQTT 'set' message to allow control   #########################
//########################################################################################################################################

def checkTopicLink(devID) { 
        list2=[]
        // log ("Looking for $devID in " + topicLink,"DEBUG")
        if(topicLink.containsKey(devID)){
        list2=topicLink[devID] 
        if (list2.size==1) log ("[$devID] Got $list2.size device topicLink matches [$list2]", "DEBUG")   
        else log ("[$devID] Got $list2.size device topicLink matches [$list2]", "DEBUG")
    }
    else log ("topicLink lookup for $devID failed","LOG")
    return list2
}

def lookupP (param,message,topic,json) {
    log (" [lookupP] I got called $param $message $topic $json" ,"TRACE")  //trace
    LookupManual(param,message,topic,json)
    return
}


def LookupManual (param,message,topic,json) {
    def found=false
	def dimDevice=false
	def onoffDevice=false
	def textDevice=false
    def varDevice=false
    def contactDevice=false
    def temperatureDevice=false	
    value=param
    deviceID=topic
    if (json=="true") json=true else json=false   
    found=false
    nested=false
    if (json){
        list=[]
        log ("Message is $message and json is $json","KH")
        jsonVal=parseJson(message)   // There is no evt BUG ??
        for (e in jsonVal) {
            // TODO handle single level nested JSON but currently no more
            // format is topic1/topic2/topic3{json1:{json2:}}  or {json1:{json2:}} ???
            jValue="${e.value}"
            jKey="${e.key}"
      log ("json: ${e.key} :      ${e.value}","LOG")
            nested=false
            if (jValue.startsWith('[') && jValue.endsWith(']')) {
       log ("This has a nested json payload ${jValue}","LOG")
                nested=true
                jNested1=jValue.toString()                                           
                jNested1='{' + jNested1.substring(1, jNested1.length() - 1) + '}';  // e.g.  {state:idle}  and parseJson expects {"state":"idle"} //hmm
                jNested1=jNested1.replace(":", "\":\"")  // re-form json payload
                log ("JNested1 is $jNested1","KH")
            }
            jsonTopic=deviceID+"{${e.key}:}"
            list=checkTopicLink (jsonTopic)
            if (list.size>0) {
               found=true               
       log ("FOUND JSON [$list.size]  $list $jsonTopic","LOG")
                 if (jsonTopic.endsWith ('}}')) log ("This is a nested JSON topic " + jsonTopic , "KH")  //FYI 
               list.each { DNI -> 
                   // TODO if nested need to call with nested json keys  // wont happen here as wont have ever matched list.size>0
                   //if (jValue.startsWith('[') && jValue.endsWith(']')) log("TODO: Nested JSON $value","KH")
                   LookupAction(DNI,jKey,jValue,json,deviceID)
               }
            }
            if (nested==true) {
          // nested example at zigbee2mqttBlue/Sengled Kitchen Table  MQTT: Json Message is {"brightness":185,"color_temp":370,"linkquality":154,"state":"OFF","update":{"state":"idle"},"update_available":false}       
         log ("Checking 2nd level json $jNested1", "LOG")
                jsonVal2=parseJson(jNested1)  
                for (f in jsonVal2) {
                    // TODO handle single level nested JSON but currently no more
                    // format is topic1/topic2/topic3{json1:{json2:}}  or {json1:{json2:}} ???
                    jValue="${f.value}"
                jKey="${f.key}"
       log ("json2: ${f.key} :      ${f.value}","LOG")
                }

      // log ("jValue is " + jValue[1] , "LOG")
      // log ("jValue is " + jValue.Temperature , "LOG")

                jsonTopic=deviceID+"{${e.key}:{Temperature:}}"    // TODO old  NOT checking correctly now
                list=checkTopicLink (jsonTopic)
                if (list.size>0) {
       log ("Found $jsonTopic", "LOG")
                }
       else log ("Couldnt find $jsonTopic", "LOG")
            }
       else log ("JSON topic not found $jsonTopic","LOG")
        }
    }

    else {  // Not json > only one value
        list = checkTopicLink (deviceID)
        //if (list.size>0) log ("FOUND list [$list.size]  $list","LOG")    
    
        if (list.size>0) {
            //log ("TopicLink: $topicLink", "KH")
           found=true
           list.each { DNI -> 
               LookupAction(DNI,'',value,json,deviceID)
           }
        }
    }


   // if (!found) log ("# OK but lookup failed for [$deviceID] in topicLink #","KH")   ##############################################  check

}

def LookupAction(LookupID,jKey,jValue,json,deviceID) {
        if (LookupID != null) {	
        device=getChildDevice(LookupID.toString())
        if (device) {
            data4=device.getData()  // device not valid ??
            //if (data4['mqtt']=="true") {  // need to include 'auto' ?
                data4.each { key, val ->
                  if ((val != null) && (val != "") && (val != " ")) {
                    if (key.endsWith ("_Topic")||(key.endsWith ("_Cmd"))) {  // Do we want to map command topics ??  //TODO I think I need a value comparison to data.topic
                      attr = key - "_Topic"
                      attr = attr - "_Cmd" 
                      log ("Key is $key and value is $val","TRACE")
                      if (json==true) {
                          if (val.contains(':==')) log ("We have a test $attr","LOG")
                              if (val.contains(deviceID+'{'+jKey+':}')){ 
                              log ("Matched $attr [$val] value $jKey [$jValue]","DEBUG")
                              updateDeviceAttribute(device,attr,jValue) 
                          }
                      }
                      else dev2match=deviceID
                          if (val == dev2match) { 
                              if (key.endsWith ("_Topic")) {
                              updateDeviceAttribute(device,attr,jValue)
                              }
                      }
                   }
               }
           }
       }
       else log ("Lookup no device for $deviceID","WARN")
   }
       else log ("No LookupID for $deviceID","WARN")
}

 

def updateDeviceAttribute(device,attr,value) {
                devType=device.getTypeName()
                //log("Virtual device $device [$devType] found in topicLink $attr update [$value]","KH") 
                found=true 
                //lastDev="$device [$value]"   // This updates to the last value on MQTT ie the _MAP value
                if (devType.contains("Sensor")||devType=="Virtual Presence"){  // Why do I want to know if it's a sensor ??
                    lastDev="$device [$value]"   // This updates to the last value on MQTT ie the MAP value or in this case a sensor value
                    sensorAction (device, devType,value,attr)
                    return
                }
                else deviceAction (device, devType,value,attr)  
}

def unblockUnblock(){   // This is just a safeguard should a device be left blocked (which should never happen)
    if ((block!='FREE')&(block!='')) {
        log ("unblockUnblock ran for $block","LOG")
        runInMillis(100,"unblockEvents")
    }
    runIn (20,"unblockUnblock")  //reschedule every 20 secs
}

def unblockEvents(){
    //log ("Unblocked","KGREEN")
    block="FREE"
}
    

    
def deviceAction (child,devType,value,attr=null)  {
    lastDev="$child [$value]" // default if not changed below
    //isEnum=false   / can reinstate if choices get larger and has a speed advantage
    maps=child.getDataValue("$attr" + "_MAP")
    if ((maps != null)&&(maps!=' ')&&(maps!='')) {
        //isEnum=true
        //log ("Child $child $value [$attr] has mapping of $maps" ,"KH")
        endPos=maps.indexOf(']')
        //maps=maps.substring(1, maps.length() - 1)
        maps=maps.substring(1, endPos)
        mapList = maps.split(',')
        if (mapList==null) {
            log ("MapList was null for $child  $attr","TRACE")
            return
        }
    }    
    log ("mapList  $mapList","TRACE")

    
    if (attr!=null && mapList!=null && attr=='switch') { // && child.hasCommand('off')) {  //assume it will have 'on' too
        if (mapList[0] == value) {
            if (child.currentSwitch != 'on'){ 
                lastDev="$child [on]"   // This normally updates to the last value on MQTT ie the MAP value
                lastDevOnOff= "$child [on]" 
//ToDo: Refinement - check if these can overlap (block!='FREE) and if so wait a few mS (only) for it to become free      <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ToDO            
//ToDo: Make 100mS a settings value if needed
                block=child.displayName
                //log ("Block (switch): $child.displayName", "KGREEN")
                child.on() 
                runInMillis (100, "unblockEvents")  // Blocks events from this device for 100mS
            }
            else log ("Switch $child already on","TRACE")
        }
        else if (mapList[1] == value){
            if (child.currentSwitch != 'off'){
                lastDev="$child [off]"   // This normally updates to the last value on MQTT ie the MAP value
                lastDevOnOff= "$child [off]"
                block=child.displayName
                //log ("Block (switch): $child.displayName", "KGREEN")
                child.off()
                runInMillis (100, "unblockEvents")  // Blocks events from this device for 100mS
            }
            else log ("Switch $child already off","TRACE")
        }
       
        }

   else if (attr=='level'&& child.hasCommand('setLevel')) {
            log ("Actioning a level device $child $value","TRACE")
            try {  // see if its numeric  // LookupLevel should be valid
					float convertedNumber = Float.parseFloat(value)  // TODO messy and repeatedly used
                     LookupLevel=child.getDataValue("max_Level")
					 log ("MaxLevel is $LookupLevel and name is $child","TRACE")
                     if (LookupLevel == "null" || LookupLevel==null)
					 {
						 val=convertedNumber.toInteger()
                         if (child.currentLevel != val) { 
                             //if (devType=="system")child.setLevel (val,0)
                             block=child.displayName
                             //log ("Block (level): $child.displayName", "KGREEN")
                             child.setLevel (val,0)
                             lastDev="$child [$val]"   // This updates to the last value on MQTT ie the MAP vlaue
                             lastDevDim="$child [$val]" 
                             runInMillis (100, "unblockEvents")  // Blocks events from this device for 100mS
						     log ("There's no corresponding MaxValue for " + data.topic, "DEBUG")
                         }
					 }
					else {
                        //val = convertLevel (value.toInteger(), LookupLevel.toInteger())
                        val = convertLevel (convertedNumber.toInteger(), LookupLevel.toInteger())
						    if (child.currentLevel != val) {
                                log ( " The numeric payload for " + child.displayName + " was converted from " + value + " to " + val, "TRACE")
						        //if (vDev) child.setLevel(intLevel,1)
                                block=child.displayName
                                //log ("Block (level): $child.displayName", "KGREEN")
                                child.setLevel(val,1)
                                lastDev="$child [$val]"   // This normally updates to the last value on MQTT ie the MAP vlaue
                                lastDevDim="$child [$val]" 
                                runInMillis (100, "unblockEvents")  // Blocks events from this device for 100mS
                            }
					}
			}
			catch (Exception e1) {
                   log ("This payload wasnt numeric  " + value + "    " + e1, "WARN")
				}
        }
        else if (attr=='variable' && child.hasCommand('setVariable')) child.setVariable(value)
        else if (attr=="text"){
            if (child.hasCommand('setText')) child.setText (value)  // my MQTT Text driver
        }
        else if (attr=="lock"){
           log ("Lock is " + value + "===" + mapList[0]+"===" +mapList[2], "INFO")
           if (mapList[0] == value) {
            lastDev="$child [locked]"   // This normally updates to the last value on MQTT ie the MAP value
            child.lock()            
            }
          else if (mapList[1] == value){
            //lastDev="$child [test]"   // This normally updates to the last value on MQTT ie the MAP value
            //child.test()
          }
          else if (mapList[2] == value){
            lastDev="$child [unlocked]"   // This normally updates to the last value on MQTT ie the MAP value
            child.unlock()
          } 
        }
        else if (attr=="smoke"||attr=="carbonMonoxide"){  // not a sensor as has 'test' command
           if (mapList[0] == value) {
            lastDev="$child [detected]"   // This normally updates to the last value on MQTT ie the MAP value
            child.clear()            
            }
          else if (mapList[1] == value){
            lastDev="$child [test]"   // This normally updates to the last value on MQTT ie the MAP value
            child.test()
          }
          else if (mapList[2] == value){
            lastDev="$child [clear]"   // This normally updates to the last value on MQTT ie the MAP value
            child.detected()
          }   
        }
    else if (attr=="door"){
    }
    else if (attr=='battery'){
        child.setBattery(value)
    }
    else if (attr=='colorTemperature'){
        col=value.toInteger()
        if (col<1000) { // is in mireds
                col = (int) 1000000 / col
        }
        child.setColorTemperature(col)
    }
    else if (attr=='speed'){
        child.setSpeed(value)
    }
    else if (attr=="contact"){
        child.sendEvent(name:"door", value:value)
        if ((mapList[0] == value )||(mapList[0]=='close' && value=='closed')) {
            lastDev="$child [close]"   // This normally updates to the last value on MQTT ie the MAP value
            //child.close() // This only ever reports status
            child.sendEvent(name:"contact", value:"closed")
            //child.sendEvent(name:"door", value:value)           
        }
        else if (mapList[1] == value){
            lastDev="$child [open]"   // This normally updates to the last value on MQTT ie the MAP value
            child.open()
            child.sendEvent(name:"contact", value:"open")
            //child.sendEvent(name:"door", value:value)
        }
    }
    else log ("No attribute [$attr] for $child - maybe _MAP value missing ?", "WARN")
  //  }   
}    

//#######################################################################################################################################
//############################   This section handles MQTT 'set' events/state changes and updates the devices   #########################
//#######################################################################################################################################

int convertLevel (int level,int scale){
    convertedNumber = level * ((float)(100)/(float)(scale))  //think this will work for 1.0 too
	intLevel = convertedNumber.round()					
    return (intLevel)
}


def onoffEventP (name,status,type) {
    
    //def data = parseJson(evt.data)
    //log ("event data: ${data}", "INFO")
	log ("Received a homie OnOff event from $name turned $status", "TRACE")
    lastDev= "$name [$status]"
    lastDevOnOff="$name [$status]" 
	child=getChildDevice("MQTT:homie_"+name)  // for homie devices   
    if (child==null) child=getChildDevice("MQTT:HA_[" + type +"]_" + name)  //TODO check this method is only for HA devices ..  
	if (child != null) log  ("Got " + child + " [" + + child.getSupportedAttributes().size() + "] " + child.getSupportedAttributes(), "DEBUG")
    else {
        log ("Couldn't find child $name","KH")
        return
    }
    
    myON = child.getDataValue("switch_ON")
    myOFF = child.getDataValue("switch_OFF")
    myMap = child.getDataValue("switch_MAP")
    try{
atomicState.setOrigin="MQTT"
        if (myMap != null) {
            mapList=stringToList(myMap) // [on,off]
            if (mapList[0] == status) child.on()
            else if (mapList[1] == status) child.off()
        }
        else if (status==myOFF) child.off()
        else if (status==myON)  child.on()
    }
    catch (e) {
atomicState.setOrigin="NA"
        log ("Failed to control onoff device $name" + e,"WARN")
    }
    
}


def formatP (name,format) { 
    //def data = parseJson(evt.data)
    child=getChildDevice("MQTT:homie_"+name)
    if (child != null){
     // index=data.format.lastIndexOf(":") + 1  
        index=format.lastIndexOf(":") + 1
        if (index >0) child.updateDataValue("max_Level",format.substring(index))
    }
     
} 								  
def dimEventP (name,level,type,max) {
    log ("Received a homie dim event from $name level $level is $type", "TRACE")
    lastDev= "$name [$level]"
    lastDevDim="$name [$level]" 
	child=getChildDevice("MQTT:homie_"+name)
    if (child==null) child=getChildDevice("MQTT:HA_[" + type+"]_"+name)
    if (child==null) {
        log ("Couldn't find dim child called $name" , "WARN")
        return
    }
    //log  ("Got " + child + " [" + + child.getSupportedAttributes().size() + "] " + child.getSupportedAttributes(), "KH")
    myMax = child.getDataValue("max_Level")   //TODO need to scale here
	log ("Setting Child dim level to $level", "TRACE")
    atomicState.setOrigin="MQTT"
    lastDevDim="$child [$level]" 
    child.setLevel(level.toInteger(),1)

}

def HASensorEventP(name,payload,type,bool) {
    log ( "Passing on sensor Event values:  $name $payload $type $bool", "TRACE")
    sensorEvent(name,payload,type,bool)
    // TODO CHECK BUG ??
}

def sensorEvent(name,b,type,bool) {   
    //log ("Received a sensor event from ${evt.value} level ${data.status}", "KH")
    log ("Received a sensor event from $name level $b", "TRACE")
    child=getChildDevice("MQTT:homie_"+name)
	if (child==null) {
        child=getChildDevice("MQTT:HA_[" +type+"]_"+name)
		if (child==null) {
            log ("getChild failed for " + name, "WARN")
			return
		}	
	}   
    //sensorAction(child, evt.value,data.status)
    //sensorAction(child,type,payload,type)   //TODO Attribute pass ??
    sensorAction(child,type,b,type)   //TODO Attribute pass ??
}

def HAClimateEventP(name,payload,type) { 
    //log ("Received a climate event from $name payload $payload is $type", "LOG")
	child=getChildDevice("MQTT:homie_"+name)
    if (child==null) child=getChildDevice("MQTT:HA_[climate]_"+name)
    if (child==null) {
        log ("Couldn't find climate child called $name" , "WARN")
        return
    }
    if (child.typeName.startsWith("Remote ")){
        sendCmd=false // else sendCmd=true
        if (type=='current_temperature') child.setTemperature(payload,false)
        else if (type=='state') child.setThermostatMode(payload,sendCmd)
        else if (type=='hvac_action') child.setThermostatOperatingState(payload,sendCmd)
        else if (type=='temperature') child.setThermostatSetpoint(payload,sendCmd)
        else log ("Climate Topic: [$type] with payload [$payload] not implemented yet","WARN")
        }
    else {
        if (type=='current_temperature') child.setTemperature(payload)
        else if (type=='state') child.setThermostatMode(payload)
        else if (type=='hvac_action') child.setThermostatOperatingState(payload)
        else if (type=='temperature') child.setThermostatSetpoint(payload)
        else log ("Climate Topic: [$type] with payload [$payload] not implemented yet","WARN")
            }   
}
    
def sensorAction(child,devType,val,attr=null) {
    log ("SensorAction check attribute received was intended $attr [$val]", "DEBUG")
    maps=child.getDataValue("$attr" + "_MAP")
    if (maps != null) {
        //log ("Child $child $val [$attr] has mapping of $maps" ,"KH")
        endPos=maps.indexOf(']')
        //maps=maps.substring(1, maps.length() - 1)
        maps=maps.substring(1, endPos)
        mapList = maps.split(',')
        //assert mapList instanceof List
    }
    if (attr=="humidity"){        
    //TODO Overly cautious sending the wrong command doesn't throw an error
        if (child.hasCommand ("setHumidity")) child.setHumidity(Float.parseFloat(val))
        else if (child.hasCommand ("setRelativeHumidity")) child.setRelativeHumidity(Float.parseFloat(val))
    }
    else if (attr=="temperature") child.setTemperature(Float.parseFloat(val))        
    else if (attr=="carbonDioxide") child.setCarbonDioxide(Float.parseFloat(val))
    else if (attr=="carbonMonoxide"){
        if (mapList[0] == val) child.CODetected()  //child.setCarbonMonoxide(val)
        else if (mapList[1] == val) child.COTested()   // doesnt exist ?? 
        else if (mapList[2] == val) child.COClear()  
    }
    else if (attr=="illuminance"){
        if (child.hasCommand ("setLux"))child.setLux(Float.parseFloat(val))
        else child.setIlluminance(Float.parseFloat(val))

    }
    else if (attr=="water"){
        if (mapList[0] == val) child.wet()
        else if (mapList[1] == val) child.dry()
    }        
    else if (attr=="presence"){
        if (mapList[0] == val) child.arrived()
        else if (mapList[1] == val)  child.departed() 
    }
    else if (attr=="smoke"){
        if (mapList[0] == val) child.smokeDetected()
        else if (mapList[1] == val) child.smokeClear() 
    }
    else if (attr=="motion"){
        if (mapList[0] == val){
            if (child.hasCommand ("inactive")) child.inactive()
            else if (child.hasCommand ("motionInactive")) child.motionInactive()
        }
        else if (mapList[1] == val) {
            if (child.hasCommand ("active")) child.active()
            else if (child.hasCommand ("motionActive")) child.motionActive()
        }
    }
    else if (attr=="contact"){
        if (mapList[0] == val) child.close()
        else if (mapList[1] == val) child.open()
    }
    else if (attr=="battery") { 
        if (child.typeName=="MQTT Text") child.setBattery(Float.parseFloat(val))  // only my MQTT Text device supports this
        else if (child.typeName=="RM Connector Variable"){
             log ("$child appears to be a battery device - using a global variable to store the battery level [$val]","LOG")
            child.setVariable (val)
        }
    }
   else if (attr=="power") { 
       
       if (child.hasCommand ("setPower")) child.setPower(Float.parseFloat(val))
       else if (child.typeName=="MQTT Text") child.setText(val)  // only my MQTT Text device supports this
       else if (child.typeName=="RM Connector Variable")
           {
           log ("$child appears to be a power device - using a global variable to store the power [$val]","LOG")
           child.setVariable (val)
       }
    }
       else if (attr=="energy") { 

        if (child.hasCommand ("setEnergy")) child.setEnergy(Float.parseFloat(val))
        else if (child.typeName=="MQTT Text") child.setText(val)  // only my MQTT Text device supports this
        else if (child.typeName=="RM Connector Variable") {
           log ("$child appears to be an energy device - using a global variable to store the energy [$val]","LOG")
           child.setVariable (val)
        }
    }
    else if (attr=="pressure") { 

        if (child.hasCommand ("setPressure")) child.setPressure(Float.parseFloat(val))
        else if (child.typeName=="MQTT Text") child.setText(val)  // only my MQTT Text device supports this
        else if (child.typeName=="RM Connector Variable"){
            log ("$child appears to be a pressure device - using a global variable to store the pressure [$val]","LOG")
            child.setVariable (val)
        }
    }
   else if (attr=="acceleration"){
        if (mapList[0] == val){
            if (child.hasCommand ("inactive")) child.inactive()
            else if (child.hasCommand ("accelerationInactive")) child.accelerationInactive()
        }
        else if (mapList[1] == val) {
            if (child.hasCommand ("active")) child.active()
            else if (child.hasCommand ("accelerationActive")) child.accelerationActive()
        }
    }
    else if (attr=="omni") { 
        log ("$child appears to be an Omni catchall device [$val]  $child.typeName - using variable","LOG")
        child.setVariable(val)
    }
    // COClear CODetected        
    // pressure will go into variable
    else {
        
        if (child.hasCommand ("setVariable")) child.setVariable(val)  //try a varaiable
        else log ("Sensor not handled specifically yet with name $child and value $devType attribute $attr   $val","INFO")
    }

}


def PresenceEventP(name,status,type) {
	log ("Received a person presence event from $name turned $status", "DEBUG")
	child=getChildDevice("MQTT:homie_"+name)  //TODO check this method is only for homie devices
	if (child==null) {
        child=getChildDevice("MQTT:HA_[" + type+"]_"+name)
    }
    if (child==null) {
				log ("Presence device not found: "+ name,"TRACE")
				return
	}
		
    onVal=child.getDataValue("presence_ON")
    offVal=child.getDataValue("presence_OFF")
    if (offVal!=null) {
        if ((offVal==status)||(status=='not_home')||(status=='not present')) child.departed()
    }
    if (onVal!=null){
        if ((onVal==status)||(status=='home')||(status=='present')) child.arrived()
    }
    //if (data.status=="home") child.arrived()  else child.departed()  // away status might be a zone name
}

def inputBooleanEventP(name,payload,type,topic) {
    log  ("Received an input boolean type event of $type from $name","TRACE")
    name=normalize2(name)
    //log ("inputBoolean: event data: ${data}", "INFO")
	child=getChildDevice("MQTT:homie_"+name)  //TODO check this method is only for homie devices
    if (child==null) child=getChildDevice("MQTT:HA_["+type+"]_"+name)
    if (child==null) child=getChildDevice("MQTT:HA_[light]_"+name)
    //log ("Looking for  MQTT:HA_["+type+"]_"+name, "KH")
    //if (child==null) child=getChildDevice("MQTT:HADisc_ "+type+" _"+name)
    if (child==null) child=getChildDevice("MQTT:HADisc_"+name)
    if (child==null) child=getChildDevice("MQTT:virtual_"+name)  // can this ever match ?
    if (child==null) child=getChildDevice("MQTT:virtual_"+topic)
    if (child==null) log ("Failed to find device $name", "ERROR")
    attList=child.getSupportedAttributes()
    attName = attList[0]
    log  ("Got " + child + " [" + + attList.size() + "] " + child.getSupportedAttributes(), "DEBUG")
    typeName=child.typeName
    // need to filter here on which attributes are binary and which hold data .. handled elsewhere now too
    try{
        mappy=child.getDataValue("$attName"+"_MAP")
        }
    catch(e) {
        log("There wasn't a value on $child for the $attName _MAP data, Trying to add a default but please check on the device", "WARN")
        //if (data.status.toLowerCase()=='on') child.updateDataValue("$attName"+"_ON",data.status)           
        }
    myMAP = stringToList(mappy)
    if (myMAP == null) log ("No _MAP value on $child","ERROR")
    else {
        myOFF=myMAP[0]
        myON=myMAP[1]
    }
    //  KLUDGE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    if (payload=='"occupancy":true') payload='true'
    if (payload=='"occupancy":false') payload='false'
    
    if (myOFF!=null) {    
	if (payload==myOFF) {
                if (typeName=="Virtual Switch") child.off()
        		else if (typeName=="Virtual Motion Sensor") child.inactive()
				else if (typeName=="Virtual Contact Sensor") child.close()
				else if (typeName=="Virtual Presence") child.departed()
				else if (typeName=="Virtual Omni Sensor") child.motionInactive()
				else if (typeName=="Virtual Multi Sensor") child.inactive()
                else {
                    log ("Need to add $typeName for $child device - using default .off","WARN")
                    child.off()
                }
    }
    }
    if (myON!=null) {
	if (payload==myON){
        	    if (typeName=="Virtual Switch") child.on()
        		else if (typeName=="Virtual Motion Sensor") child.active()
				else if (typeName=="Virtual Contact Sensor") child.open()
				else if (typeName=="Virtual Presence") child.arrived()
				else if (typeName=="Virtual Omni Sensor") child.motionActive()
				else if (typeName=="Virtual Multi Sensor") child.active()
                else {
                    log ("Need to add $typeName for $child device - using default .on","WARN")
                    child.on()
                }
	}
    }
    //else log ("Couldn't match 'binary' value for $child $data.state _ON  _OFF, please edit device","WARN")
    else log ("Couldn't match 'binary' value for $child  $payload _ON  _OFF, please edit device","WARN")
}

def HABinSensorType(evt) {
	def data = parseJson(evt.data)
	log  ("Received binary_sensor type event of ${data.type} from ${evt.value}","TRACE")
}

def HASensorUnitP (a,b) {
    log ("sensor UOM $a $b","ERROR")
}


def dAttIsEnabled(device,attr)
{
    if (device==null) {
        log ("Null device - attribute is $attr")
        return
    }
    property=device.getDataValue("properties")
    if (property != null) {
            if (!property.contains(attr)) {
                log ("$device: BLOCKED","KH")
                return false
            }

        }
return true
}

// def cmdEvent (name,state,payload,cmd,topic) {  // 'set' command from homie for a Hubitat or manual device via Hubitat basic 



def extractInt( String input ) {
  return input.replaceAll("[^0-9]", "")
}


//#######################################################################################################################################
//############################   This section contains general utility nethods and the popular createChild() method     #########################
//#######################################################################################################################################

def normalize(name) {
	//TODO research how to include NFD
	//log ("Normalize: " + name + " >>> " + name.trim().toLowerCase().replaceAll(/[^\w-]/,"_").replaceAll(/[-]/,'_'),"TRACE")
	return name ? name.trim().toLowerCase().replaceAll(/[^\w-]/,"-").replaceAll(/[_]/,'-') : undefined
}

def normalize2(name) {
	//TODO research how to include NFD
	//log ("Normalize: " + name + " >>> " + name.trim().toLowerCase().replaceAll(/[^\w-]/,"_").replaceAll(/[-]/,'_'),"TRACE")
	return name ? name.trim().toLowerCase().replaceAll(/[^\w-]/,"_").replaceAll(/[-]/,'_') : undefined
}


def LabelDeviceP(dID,label) {   // rename to reNameDevice ??
		child=getChildDevice(dID)
	    if (child == null) {
		log ("reName: Child doesn't exist (no state or unsupported type ?) "+ dID + " " + label , "TRACE")
		return  
       }
	child.label= label
	log ("reNamed  $child.displayName to $label" ,"TRACE")
}

def MD5(String s){
    if (s==null) s="123"
    MessageDigest.getInstance("MD5").digest(s.bytes).encodeHex().toString()
}

def createChildDevice(name, type, system, friendlyName=null, dType='default',seq=0, config=null) {
    mqtt = getChildDevice("MQTT: Child device driver")
	// friendlyname may not be available yet so name will have been passed and it will be renamed later in reNameDev()
	log("CreateDevice called for $system " + name + " " + friendlyName + "  :  " + type,"DEBUG")
    if (friendlyName==null) friendlyName=name
	if (name==null) return
	//if (atomicState.started) return // TODO Stops creation of devices after timed startup has elapsed - but also stops ongoing incremental discovery.... decide which to use
	devEnabled=false
	def prefix = "MQTT:"
	String enabledDevices=(settings?.HA_Lights) + ',' + (settings?.HA_Switches ) + ',' + (settings?.Homie_dim) + "," + (settings?.Homie_onoff) + ','  //not used
	if (system=="HA") {
        prefix="MQTT:HA_["+type+"]_"
        if ((type=='switch')&&(settings?.HA_Switches != null)){							   
			if (settings?.HA_Switches.contains (name))
			{
				devEnabled=true
			}
		}
		else if ((type=='light')&&(settings?.HA_Lights != null)) {  
			if (settings?.HA_Lights.contains (name))
			{
				devEnabled=true
			}
		}
		else if ((type=='sensor')&&(settings?.HA_Sensors != null)) {
			if (settings?.HA_Sensors.contains (name))
			{
				devEnabled=true
			}
            //else log ("Device not enabled $name","LOG")
		}
		else if ((type=='binary_sensor')&&(settings?.HA_BinarySensors != null)) {
			if (settings?.HA_BinarySensors.contains (name))
			{
				devEnabled=true
			}
		}
        else if ((type=='input_boolean')&&(settings?.HA_InputBooleans != null)) {
			if (settings?.HA_InputBooleans.contains (name))
			{
                devEnabled=true
			}
		}
        else if ((type=='person')&&(settings?.HA_Presence != null)) {
			if (settings?.HA_Presence.contains (name))
			{
				devEnabled=true
			}
		}
		else if ((type=='group')&&(settings?.HA_Groups != null)) {
			if (settings?.HA_Groups.contains (name))
			{
				devEnabled=true
			}
		}
        else if ((type=='device_tracker')&&(settings?.HA_DeviceTrackers != null)) {
			if (settings?.HA_DeviceTrackers.contains (name))
			{
				devEnabled=true
			}
		}
        else if ((type=='cover')&&(settings?.HA_Covers != null)) {
			if (settings?.HA_Covers.contains (name))
			{
				devEnabled=true
                //devType='Virtual Shade'
			}
		}
        else if ((type=='climate')&&(settings?.HA_Climates != null)) {
			if (settings?.HA_Climates.contains (name))
			{
                devEnabled=true
			}
		}
        else if ((type=='lock')&&(settings?.HA_Locks != null)) {
			if (settings?.HA_Locks.contains (name))
			{
				devEnabled=true
			}
		}
        else {
            log ("Not enabled HA $name type $type","TRACE")
        }
	}
	else if (system=="homie")
	{
		prefix="MQTT:homie_"
        if (settings?.Homie_onoff != null)
		{									   
			if (settings?.Homie_onoff.contains (name))
			{
				devEnabled=true				
			}
		}
         if (settings?.Homie_dim != null) {
			if (settings?.Homie_dim.contains (name))
			{
				devEnabled=true
			}
		}
		if (settings?.Homie_sensor != null) {
			if (settings?.Homie_sensor.contains (name))
			{
				devEnabled=true
			}
		}
		if (settings?.Homie_binarySensor != null) {
			if (settings?.Homie_binarySensor.contains (name))
			{
				devEnabled=true
			}
		}
        if (settings?.Homie_variable != null) {
			if (settings?.Homie_variable.contains (name))
			{
				devEnabled=true
			}
		}
        if (settings?.Homie_button != null) {
			if (settings?.Homie_button.contains (name))
			{
				devEnabled=true
			}
        }
          if (!devEnabled)  log ("Not enabled homie $name type $type","KH")
	}

    else if (system=="HADisc") {
           

    /*  temporarily disable blocking here
             // nothing originating from this hub can get this far - blocked in HAIn()
             if (config.state_topic != null) {  // need to expand checks here
                if (config.state_topic.startsWith('homie/')) {
                    log ("Create Device Blocked: You can't use HA Discovery on a device publishing within the homie/.. tree - use homie discovery instead [$friendlyName]","WARN")
                    return
                }
                 else if (config.state_topic.startsWith(settings?.zwave2mqttTopic)) {
                    log ("Create Device Blocked: You can't use HA Discovery on a device publishing within the zwave/.. tree - use zwavejs2mqtt discovery instead [$friendlyName]","WARN")
                    return
                }
                else if (config.state_topic.startsWith(settings?.zigbee2mqttTopic)) {
                    log ("Create Device Blocked: You can't use HA Discovery on a device publishing within the zigbee/.. tree - use zigbee2mqtt discovery instead [$friendlyName]","WARN")
                    return
                }
            }
*/
        //prefix="MQTT:HADisc_["+type+"]_"
        //prefix="MQTT:HADisc_ "+type+" _"  
        prefix="MQTT:HADisc_"
        if ((type=='switch')&&(settings?.HAIn_switch != null)){							   
			if (settings?.HAIn_switch.contains (name))
			{
				devEnabled=true
			}
		}
		else if ((type=='light')&&(settings?.HAIn_light != null)) {  
			if (settings?.HAIn_light.contains (name))
			{
				devEnabled=true
			}
		}
		else if ((type=='sensor')&&(settings?.HAIn_sensor != null)) {
			if (settings?.HAIn_sensor.contains (name))
			{
				devEnabled=true
			}
            //else log ("Device not enabled $name","LOG")
		}
		else if ((type=='binary_sensor')&&(settings?.HAIn_binary != null)) {
			if (settings?.HAIn_binary.contains (name))
			{
				devEnabled=true
			}
		}
 /*
        else if ((type=='input_boolean')&&(settings?.HAIn_InputBooleans != null)) {
			if (settings?.HAIn_InputBooleans.contains (name))
			{
                devEnabled=true
			}
		}
        else if ((type=='person')&&(settings?.HAIn_Presence != null)) {
			if (settings?.HAIn_Presence.contains (name))
			{
				devEnabled=true
			}
		}
		else if ((type=='group')&&(settings?.HAIn_Groups != null)) {
			if (settings?.HAIn_Groups.contains (name))
			{
				devEnabled=true
			}
		}
        else if ((type=='device_tracker')&&(settings?.HAIn_DeviceTrackers != null)) {
			if (settings?.HAIn_DeviceTrackers.contains (name))
			{
				devEnabled=true
			}
		}
*/
        else if ((type=='cover')&&(settings?.HAIn_Covers != null)) {
			if (settings?.HAIn_Covers.contains (name))
			{
				devEnabled=true
                //devType='Virtual Shade'
			}
		}

        else if ((type=='climate')&&(settings?.HAIn_climate != null)) {
			if (settings?.HAIn_climate.contains (name))
			{
                devEnabled=true
			}
		}
        else if ((type=='lock')&&(settings?.HAIn_Locks != null)) {
			if (settings?.HAIn_Locks.contains (name))
			{
				devEnabled=true
			}
		}

        else {
            log ("Not enabled HADiscovery $name type $type","KH")
        }
	}
    else if (system=="C-Bus") {
       		devEnabled=true
		    prefix="MQTT:CBus_" 
    }
    else if (system=='Sonoff') {
		devEnabled=true
		prefix="MQTT:Sonoff_"
	}

    else if (system=='Shelly') {
		devEnabled=true
		prefix="MQTT:Shelly_"
	}

	else if (system=='internal') {
		devEnabled=true
		prefix="MQTT:Internal_"
	}
	if (!devEnabled)
	{
		log ("["+system+"] Create blocked (not enabled) for " + name, "TRACE")
		return
	}
    else{
        log ("["+system+"] Device enabled: $system " + name + " : " + type + " " +dType, "TRACE")
    }
	child=getChildDevice(prefix+name) 
	if (child != null) 
		{
			// dont expect this if mqttRemoveDevices was true
			// TODO decide ..this gets fired (but ignored) on every change of state update - can we eliminate that without breaking incremental discovery ?
			// no but could use ...  if(atomicState.started)
			if (!atomicState.started && (settings?.mqttRemoveDevices == true)) log ("Child already exists " + prefix+name, "WARN")
            //log ("Device already exists [$child]: Re-register event listener", "INFO") 
            //subscribe(child, "switch", switched)  // this only handles switch events  - need the rest
			return
		}
    def nameSpace="hubitat" // now all devices are Hubitat                                        
    attrData=null
    if ((type=='onoff')||(type=='switch')) {
        devType='Virtual Switch'
        attrData="switch"
    }
    else if ((type=='dim')||(type=='light')){
        devType='Virtual Dimmer'
        attrData="level"
    }                                          
	else if (type=='group') {
        devType='Virtual Switch'  // TODO check if a HA group can have a level ?
        attrData="switch"
    }
    else if (type=='input_boolean') { 
        devType="Virtual Contact Sensor"    //devType='Virtual Switch'   //This should be a contact sensor or something as not controllabe
        attrData="contact"
    }
    else if (type=='binary_sensor') { 
        devType="Virtual Contact Sensor"    //devType='Virtual Switch'   //This should be a contact sensor or something as not controllabe
        attrData="contact"
    }    
    else if ((type=='presence')||(type=='person')) devType='Virtual Presence'
    else if (type=='button') devType='Virtual Button'
    else if (type=='lock') devType='Virtual Lock'
    else if (type=='cover') devType='Virtual Shade'
    else if (type=='device_tracker') devType= "Virtual Presence"
    else if (type=='climate') {
        //devType = "Virtual Thermostat"
        devType = "Remote Thermostat"
        nameSpace='ukusa'
        //log ("HA climate device not implemented yet, no device created for $name", "WARN")
        attrData='multiple'
    }
    else if (type=='sensor' || type=='binary_sensor') {
        //log ("Got a sensor of type ${dType}", "WARN")
        // TODO would be useful to know UOM here to guess type
        // devType= "Virtual Omni Sensor" // changing this default to a variable as Omni is problematic
        //devType= "RM Connector Variable"
        //if (dType=="default") devType= "RM Connector Variable"  // changing this default to a variable as Omni is problematic
        devType= "MQTT Text"
        if (dType=="default") devType= "MQTT Text"  
        if (system=='HADisc') {
          devClass=null
          uom=null
          if (config!=null) {
            if (config.dev_cla!=null) devClass=config.dev_cla
            else if (config.device_class!=null) devClass=config.device_class
            if (devClass!=null) {
               if (devClass=="temperature") devType = "Virtual Temperature Sensor"
                if (devClass=="battery") {
                    devType = "MQTT Text"  // no virtual battery
                    dType="battery"
                }
            }

            if (config.unit_of_meas!=null) uom=config.unit_of_meas
            else if (config.unit_of_measurement!=null) uom=config.unit_of_measurement
            if (uom!=null) {
                if((uom=="°C")||(uom=="°F")) devType = "Virtual Temperature Sensor"
                // TODO derive other sensor device types here <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<    TODO    <<<
            }
            if (devType!="Virtual Temperature Sensor") {
                devType="MQTT Text"   // use my driver for the HAIn Discovered sensors for the time being
                nameSpace='ukusa'
                attrData='multiple'
            }
          }
            else log ("config was null in createDevice (extended discovery?)","WARN")
        }
        else if (dType=="None") devType= "Virtual Contact Sensor"
        else if (dType=="acceleration") devType= "Virtual Acceleration Sensor"
        else if (dType=="audioVol") devType= "Virtual audioVolume"
        else if (dType=="battery") devType= "RM Connector Variable"  // there is no battery variable device
        else if (dType=="battery") devType="MQTT Text"  //UKUSA namespace
        else if (dType=="button") devType= "Virtual Button"    
        else if (dType=="cold") devType= "Virtual Contact Sensor"
		else if (dType=="connectivity") devType= "virtual Contact Sensor"
        else if (dType=="device_tracker") devType= "Virtual Presence"
        else if (dType=="door") devType= "Virtual Contact Sensor"
        else if (dType=="garage_door") devType= "Virtual Garage Door Controller"
        else if (dType=="gas") devType= "Virtual CO Detector"
		else if (dType=="heat") devType= "Virtual Contact Sensor"
        else if (dType=="humidity") devType= "Virtual Humidity Sensor"
        else if (dType=="illuminance") devType= "Virtual Illuminance Sensor"   
		else if (dType=="light") devType= "Virtual Switch"		
        else if (dType=="lock") devType= "Virtual Lock"
        else if (dType=="moisture") devType= "Virtual Moisture Sensor"  // check as overly complex
        //else if (dType=="moisture") devType= "Generic Component Water Sensor"  
        else if (dType=="motion") devType= "Virtual Motion Sensor"
		else if (dType=="moving") devType= "Virtual Acceleration Sensor"
        else if (dType=="occupancy") devType= "Virtual Presence"
        else if (dType=="opening") devType= "Virtual Contact Sensor"
        else if (dType=="plug") devType= "Virtual Switch"
        else if (dType=="power") devType= "Virtual Omni Sensor"   //check TODO ... Generic Component Metering Switch ?
        else if ((dType=="presence")||(dtype=='person')) devType= "Virtual Presence" 
        else if (dType=="pressure") devType= "Virtual Omni Sensor"    
		else if (dType=="problem") devType= "Virtual Omni Sensor"  //TODO
		else if (dType=="safety") devType= "Virtual Contact Sensor"
        else if (dType=="smoke") devType= "Virtual Smoke Detector"
		else if (dType=="sound") devType= "Virtual audioVolume"  // check think this is not boolean
        else if (dType=="temperature") devType= "Virtual Temperature Sensor"  // check think this is not boolean           
        else if (dType=="variable") devType= "RM Connector Variable"
        //else if (dType=="vibration") devType= "Virtual Motion Sensor"
        else if (dType=="vibration") devType= "Generic Glass Break Detector"
        else if (dType=="window") devType= "Virtual Contact Sensor"
        else  log (name + " found no device type mapping for ==$dType== " + dType + '  ' +  devType,"WARN")
	}
	// ######  This is where to add additional device types and their matching driver ######			 
	else {
			log ("Skipping creating device " + name +" as no type yet for " + type, "WARN")
			return
	}			
		
        if (devType=="MQTT Text") nameSpace="ukusa" 
        log ("Creating [$devType] type " + type + " as  + ("+ dType +") " + " named MQTT:" + name + " " + friendlyName, "WARN")
		//mqtt.createChild(name)  // This was to create device as driver child
		def pfix = ""
//		try {   
				if (system=="C-Bus") childDevice = addChildDevice(nameSpace, devType, prefix+name, null,[completedSetup: true, label: pfix + name])
                else childDevice = addChildDevice(nameSpace, devType, prefix+name, null,[completedSetup: true, label: pfix + friendlyName])
				child=getChildDevice(prefix+name)  //hmm seems childDevice is not a device object 
			    if (child == null) log ("Child was never created" + prefix+name , "KH")
                else log ("Created Child device for [$system] with label "+ child.label,"GREEN")
			    atomicState.count++			
			    childrenCount = getChildDevices().size()
                child.updateSetting("txtEnable",[value:false, type:"bool"])
				if (system=='homie'){
                            child.updateDataValue("switch_Topic",'homie/'+atomicState.homie+'/'+name+'/onoff')
                            child.updateDataValue("switch_Cmd",'homie/'+atomicState.homie+'/'+name+'/onoff/set')
                            //child.updateDataValue("switch_ON","true")                                             // ##### ToDo dont do this if already has a value (shouldnt happen as new device)
                            //child.updateDataValue("switch_OFF","false")
                            child.updateDataValue("switch_MAP","[true,false]")
                            child.updateDataValue("mqtt",'enabled')
                            child.updateDataValue("origin",'homie')															   
																												
				}
            	else if (system=="HA"){
                    child.updateDataValue("mqtt","auto")
                    child.updateDataValue("origin","Home Assistant")
                    log ("Completed Request to create $name of type $type","KH")
                    control=true 
                    binary=true
                    if (type == 'sensor') {
                        log ("Created Sensor for $name","KH")
                        control=false 
                        binary=false
                        if (attrData!=null) {
                            //child.updateDataValue("${attrData}_Topic]",atomicState.HA+'/switch/'+name+'/state')
                            mqtt.subscribeTopic(atomicState.HA+'/sensor/'+name+'/state')  // This is to support individual subscribes
			                child.updateDataValue("${attrData}_Topic",atomicState.HA+'/sensor/'+name+'/state')																				  
                            //child.updateDataValue("${attrData}_Cmd", atomicState.HA+'/switch/'+name+'/state/cmd')
                            //child.updateDataValue("${attrData}_ON","on")                                             // ##### ToDo dont do this if already has a value (shouldnt happen as new device)
                            //child.updateDataValue("${attrData}_OFF","off")
                            //child.updateDataValue("${attrData}_MAP","[on,off]")
                        }
                        else {  // Going to create as a variable by default
                            log.error "########################################################################################################"
                             mqtt.subscribeTopic(atomicState.HA+'/sensor/'+name+'/state')  // This is to support individual subscribes
			                 child.updateDataValue("variable_Topic",atomicState.HA+'/sensor/'+name+'/state')
                        }
                        
                        
                    }
                    else if (type == 'switch'){
                        if (attrData!=null) {
                            //child.updateDataValue("${attrData}_Topic]",atomicState.HA+'/switch/'+name+'/state')
                            mqtt.subscribeTopic(atomicState.HA+'/switch/'+name+'/state')  // This is to support individual subscribes
							child.updateDataValue("${attrData}_Topic",atomicState.HA+'/switch/'+name+'/state')																				  
                            child.updateDataValue("${attrData}_Cmd", atomicState.HA+'/switch/'+name+'/state/cmd')
                            //child.updateDataValue("${attrData}_ON","on")                                             // ##### ToDo dont do this if already has a value (shouldnt happen as new device)
                            //child.updateDataValue("${attrData}_OFF","off")
                            child.updateDataValue("${attrData}_MAP","[on,off]")
                            
                            // SHOULD I TRY AND ADD THE EVENT SUBSCRIBE HERE FOR SWITCHED ?
                            log ("trying to register 'switched' event listener for " + child, "KH") 
                            subscribe(child, "switch", switched)
                        }
					}
                    else if (type == 'light') {
                        if (attrData!=null) {   // attrData will be 'level'
                            mqtt.subscribeTopic(atomicState.HA+'/light/'+name+'/state')  // This is to support individual subscribes
                            child.updateDataValue("switch_Topic",atomicState.HA+'/light/'+name+'/state')
                            child.updateDataValue("switch_Cmd", atomicState.HA+'/light/'+name+'/state/cmd')
                            //child.updateDataValue("level_Topic",atomicState.HA+'/light/'+name+'/brightness')
                            child.updateDataValue("${attrData}_Topic", atomicState.HA+'/light/'+name+'/brightness')
                            child.updateDataValue("${attrData}_Cmd", atomicState.HA+'/light/'+name+'/brightness/cmd')
                            //child.updateDataValue("switch_ON","on")
                            //child.updateDataValue("switch_OFF","off")
                            child.updateDataValue("switch_MAP","[on,off]")
                            child.updateDataValue("max_Level","255")
                            
                            log ("Register 'switchedDim' event listener for " + child, "KH") 
                            subscribe(child, "switch", switchedDim)
                            log ("Register 'dimmed' event listener for " + child, "KH") 
                            subscribe(child, "level", dimmed)
                        }
					}
					else if (type == 'group') {
                        if (attrData!=null) {
                            mqtt.subscribeTopic(atomicState.HA+'/group/'+name+'/state')  // This is to support individual subscribes
                            child.updateDataValue("${attrData}_Topic",atomicState.HA+'/group/'+name+'/state')
                            child.updateDataValue("${attrData}_Cmd", atomicState.HA+'/group/'+name+'/state/cmd')
                            //child.updateDataValue("${attrData}_ON","on")
                            //child.updateDataValue("${attrData}_OFF","off")
                            child.updateDataValue("${attrData}_MAP","[on,off]")
                        }
					}
                    else if (type == 'input_boolean') {
                        if (attrData!=null) {
                            mqtt.subscribeTopic(atomicState.HA+'/input_boolean/'+name+'/state')  // This is to support individual subscribes
                            child.updateDataValue("${attrData}_Topic",atomicState.HA+'/input_boolean/'+name+'/state')
                            child.updateDataValue("${attrData}_Cmd", atomicState.HA+'/input_boolean/'+name+'/state/cmd')
                            //child.updateDataValue("${attrData}_ON","on")
                            //child.updateDataValue("${attrData}_OFF","off")
                            child.updateDataValue("${attrData}_MAP","[on,off]")
                        }
					}
                    else if (type == 'binary_sensor') {
                        if (attrData!=null) {
                            control=false
                            mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/'+name+'/state')  // This is to support individual subscribes
                            child.updateDataValue("${attrData}_Topic",atomicState.HA+'/binary_sensor/'+name+'/state')
                            //child.updateDataValue("${attrData}_Cmd", atomicState.HA+'/binary_sensor/'+name+'/state/cmd')
                            //child.updateDataValue("${attrData}_ON","on")
                            //child.updateDataValue("${attrData}_OFF","off")
                            child.updateDataValue("${attrData}_MAP","[on,off]")
                        }
					}
                    else if (type == 'climate') {
                        if (attrData!=null) {   // attrData will be 'multiple'
                            mqtt.subscribeTopic(atomicState.HA+'/climate/'+name+'/#')  // This is to support individual subscribes
                            child.updateDataValue("thermostatMode_Topic",atomicState.HA+'/climate/'+name+'/state')
                            child.updateDataValue("state_Cmd", atomicState.HA+'/climate/'+name+'/state/cmd')
                            child.updateDataValue("temperature_Topic", atomicState.HA+'/climate/'+name+'/current_temperature')
                            child.updateDataValue("thermostatFanMode_Cmd", atomicState.HA+'/climate/'+name+'/fan_mode/cmd')
                            child.updateDataValue("thermostat-setpoint_Topic", atomicState.HA+'/climate/'+name+'/temperature')
                            child.updateDataValue("thermostat-setpoint_Cmd", atomicState.HA+'/climate/'+name+'/temperature/cmd')
                            child.updateDataValue("thermostatOperatingState_Topic", atomicState.HA+'/climate/'+name+'/hvac_action')
                           
                            //child.updateDataValue("switch_ON","on")didntn't send command
                            
                            //child.updateDataValue("switch_OFF","off")
                            //child.updateDataValue("switch_MAP","[on,off]")
                            //child.updateDataValue("max_Level","255")
                        }
					}
					else {
                        log ("HA type $type  - not recognised yet so creating defaults","INFO")

                        child.capabilities.each { cap ->
                          cap.attributes.each { attr ->
                            log ( "Unrecognised HA device [$child] so adding default MQTT data for [$attr]","INFO")
                            child.updateDataValue("${attr}_Topic",atomicState.HA+'/'+type+'/'+name+'/state')
                            if (control) child.updateDataValue("${attr}_Cmd", atomicState.HA+'/'+type+'/'+name+'/state/cmd')
                            if (binary) {
                                  //child.updateDataValue("${attr}_ON","on")
                                  //child.updateDataValue("${attr}_OFF","off")f
                                  child.updateDataValue("${attrData}_MAP","[on,off]")
                            }
                          }
                       }
                    }
                     attrData=null
                   }  //HA system
    
    
    else if (system=='HADisc') {  //Incoming from HA Discovery protocol
        if (config != null) {  
            mqtt = getChildDevice("MQTT: Child device driver")
            friendlyName = config.name  // TODO need to rename device now - or to use this earlier when device is created.
            log ("Adding HA Discovery [$type] $friendlyName", "GREEN")
            if (child.typeName=="MQTT Text) ") subscribe(child,"text",otherDevices) 
            //deviceClass=config.device_class   // not all devices have this
            child.updateDataValue ("mqtt",'auto')
            child.updateDataValue ("origin",'HA Discovery')
            
            if (config.state_topic != null) jState = config.state_topic else jState = config.stat_t                  
            if (config.cmd_topic != null) jCmd = config.cmd_topic else jCmd = config.cmd_t 
                    
            if ((type=='switch')||(type=='light')){
                if (jState != null) child.updateDataValue ("switch_Topic",jState) 
                if (jCmd != null) child.updateDataValue ("switch_Cmd",jCmd)
                if (config.payload_on!=null) pON=config.payload_on else pON=config.pl_on
                if (config.payload_off!=null) pOFF=config.payload_off else pOFF=config.pl_off
                child.updateDataValue ("switch_MAP","[" + pON + "," + pOFF + "]") 
                updateTopicLink(child.displayName,jState,child.deviceNetworkId)
	            mqtt.subscribeTopic(jState)
                subscribe(child, "switch", switched)

                if (type=='light'){
                    if (config.brightness_state_topic!=null) bri=config.brightness_state_topic else bri=config.bri_stat_t
                    if (bri!=null) child.updateDataValue ("level_Topic",bri)
                    if (config.brightness_command_topic!=null) bCmd=config.brightness_command_topic else bCmd=config.bri_cmd_t
                    if (bCmd!=null) child.updateDataValue ("level_Cmd",bCmd)
                    bMax=-1
                    if (config.brightness_scale!=null) bMax =config.brightness_scale.toString()else bMax = config.bri_scl.toString()
                    if ((bMax!=null) && (bMax>=0)) child.updateDataValue ("max_Level",bMax.toString())
                    else child.updateDataValue ("max_Level","255")  // a default for most things HA
                    updateTopicLink(child.displayName,bri,child.deviceNetworkId)
                    mqtt.subscribeTopic(bri)
                    subscribe(child, "switch", switchedDim)
                    subscribe(child, "level", dimmed)
 
                }
            }
            if ((child.typeName=="MQTT Text") && (type=='sensor')) {  // defaulted to the MQTT Text device for the time being
                log ("dType was $dType and devType is $devType","KH")
                if ((jState!=null)&&(dType=='battery')) child.updateDataValue ("battery_Topic",jState) else child.updateDataValue ("state_Topic",jState) 
                mqtt.subscribeTopic(jState)
               // count = registerSpecificAttribute (smokesensors,count,'smoke','sensorDevices')        // TODO do I need to provide the specific type of sensor here  ???
               // will already have a text subscription if of type MQTT Text
               updateTopicLink(child.displayName,jState,child.deviceNetworkId)
               // still need to handle battery - not sure if can use both attributes on the MQTT Text device as selected as two devices
               if (uom != null) child.setSuffix(uom) 
            }          
            else if  (child.typeName=="Virtual Temperature Sensor") {
                if (jState!=null)  {
                    child.updateDataValue ("temperature_Topic",jState)
                    mqtt.subscribeTopic(jState)
                }         
                if (uom=="°C") child.updateSetting("degreesC", true)
            }
        }
        else log ("config was null in createDevice","WARN")
    }
    else if (system=="C-Bus") {
        if (type=='light'){
                            //mqtt.subscribeTopic(settings?.CBusTopic+"/$name/state")  // This is to support individual subscribes
                            child.updateDataValue("origin","C-Bus")
                            child.updateDataValue("mqtt","enabled")
                            //child.updateDataValue("switch_Topic",settings?.CBusTopic+'/read/254/56/$name/state)  // but not using this as level is enough
                            child.updateDataValue("switch_Cmd", settings?.CBusTopic+"/write/254/56/$name/switch")
                            child.updateDataValue("level_Topic", settings?.CBusTopic+"/read/254/56/$name/level")          
                            child.updateDataValue("level_Cmd", settings?.CBusTopic+"/write/254/56/$name/level")
                            child.updateDataValue("switch_MAP","[ON,OFF]")
                            child.updateDataValue("max_Level","255")
                            child.updateDataValue("C-Bus_Group",dType)
                            log ("Register 'switchedDim' event listener for " + child, "KH") 
                            subscribe(child, "switch", switchedDim)
                            log ("Register 'dimmed' event listener for " + child, "KH") 
                            subscribe(child, "level", dimmed)
                            updateTopicLink(child.displayName,settings?.CBusTopic+"/$name/state",child.deviceNetworkId)
                            updateTopicLink(child.displayName,settings?.CBusTopic+"/$name",child.deviceNetworkId)             
        	                mqtt.subscribeTopic(settings?.CBusTopic+"/read/254/56/$name/level")
                            subscribe(child, "switch", switchedDim)
                            subscribe(child, "level", dimmed) 
        }
        else if (type=='sensor') {
            if (dType=="temperature"){
                            mqtt.subscribeTopic(settings?.CBusTopic+"/$name/value")  // This is to support individual subscribes
                            child.updateDataValue("origin","C-Bus")
                            child.updateDataValue("mqtt","enabled")
                            child.updateDataValue("temperature_Topic",settings?.CBusTopic+"/$name/value")
                            //child.updateDataValue("switch_Cmd", settings?.CBusTopic+"/$name/state/cmd")
                            //child.updateDataValue("level_Topic",atomicState.HA+'/light/'+name+'/brightness')
                            //child.updateDataValue("level_Topic", settings?.CBusTopic+"/$name")
                            //child.updateDataValue("level_Cmd", settings?.CBusTopic+"/$name/level/cmd")
                            //child.updateDataValue("switch_MAP","[on,off]")
                            //child.updateDataValue("max_Level","255")
                            //child.updateDataValue("C-Bus_Group",friendlyName)
                            child.updateDataValue("C-Bus_App","measurement 228")
                            //log ("Register 'switchedDim' event listener for " + child, "KH") 
                            //subscribe(child, "switch", switchedDim)
                            //log ("Register 'dimmed' event listener for " + child, "KH") 
                            //subscribe(child, "level", dimmed)
                            updateTopicLink(child.displayName,settings?.CBusTopic+"/$name/value",child.deviceNetworkId)
                            //updateTopicLink(child.displayName,settings?.CBusTopic+"/$name",child.deviceNetworkId)             
        	                mqtt.subscribeTopic(settings?.CBusTopic+"/$name/value")
                            //mqtt.subscribeTopic(settings?.CBusTopic+"/$name")
                            //subscribe(child, "switch", switchedDim)
                            //subscribe(child, "level", dimmed)
            }

            
            
        }
        
    }
                       
                else if (system=="Shelly"){
                    if (name[-7..-1] == "relay 0") sTopic = '/relay/0'
                    else if (name[-7..-1] == "relay 1") sTopic = '/relay/1'
                    else sTopic="/unknown/"
                        // uses on off
                   		//child.setStateTopic('shellies/'+name+sTopic)
						//child.setStateCmdTopic('shellies/'+name+sTopic+'/command') 
                }
                else if (system=="Sonoff"){ 
                    log ("Sonoff not yet implemented","ERROR")
                }
				else if (system=="internal"){  // was setting state topics but now not child devices
				}
				if (type=='dim') {
					if (system=="homie"){
                         child.updateDataValue("level_Topic",'homie/'+atomicState.homie+'/'+name+'/dim')
                         child.updateDataValue("level_Cmd",'homie/'+atomicState.homie+'/'+name+'/dim/set')
                         child.updateDataValue("max_Level",'100')  // this will get updated later from the $format value
                         child.updateDataValue("mqtt",'enabled')
                         child.updateDataValue("origin",'homie')
					}
					else if (system=="HA"){
                        child.updateDataValue("switch_Topic",atomicState.HA+'/light/'+name+'/state')
                        child.updateDataValue("switch_Cmd",atomicState.HA+'/light/'+name+'/state/cmd')
                        child.updateDataValue("level_Topic",atomicState.HA+'/light/'+name+'/brightness')
                        child.updateDataValue("level_Cmd",atomicState.HA+'/light/'+name+'/brightness'/cmd)
                        child.updateDataValue("max_Level",'100')
					}
					if (type=='sensor') {
						log  ("############ Problem child is " + child.device.typeName, "WARN")
						if (child.typeName=="MQTT Dimmer" || child.typeName=="MQTT Switch" ){  // think must be my driver here
					}
					}
			}
			//child.setType(system)  // identify as a discovered device
/*
		} catch(Exception ex) {
            log ("addChild/topics failed for " + name + " ["+  prefix+name +" ]"  +(ex.toString()), "ERROR")
		}
*/
      //log("Succesfully created new device $name","WARN")
	  if (system != "HADisc") advertiseChild() 
}

def updateTopicLink (name, topic, devID){ 
    log ("UD topicLink $name $topic $devID","DEBUG")
                             if(topicLink.containsKey(topic)){ 
                                 list=topicLink[topic]       //.add(topic)
                                if (list.contains(devID)) {
                                }
                                else {
                                    list.add (devID)
                                    topicLink[topic]=list 
                                }
                            }
                            else {
                                list=[devID]
                                topicLink[topic] = list
                            }
}


def advertiseChild(){
	return  // These will be 'discovered' devices so not onwardly advertising them or publishing states (may revisit again later)
	log ("### TODO ####   Update MQTT with states for ${name} and also advertise to HA","WARN")
	//HADiscoveryAdvertise()
}

def checkMyHub() {
    myID=MD5(app.getHubUID())
    if (myID=="d36ba7352b7fc675e7314162377a88be") {} // atomicState.myHub=true //41
    else if (myID=="8e703d9adefe69d652315cf6159671b7"){} // atomicState.myHub=true //42
    else if (myID=="e947798518d8f4b041d701d122c38b30"){} // atomicState.myHub=true //44
    else if (myID=="6aafb1d8f3d5a978d2f73181e1d2eb4a"){} // atomicState.myHub=true  //43 TODO UPDATE THIS ONE
    else if (myID=="bd68d7994a94149ac7bccb5ac9a22200"){} // atomicState.myHub=true //246
    else if (myID=="e4e0b1f78ec69af1b76f4d080ddde64c"){} // atomicState.myHub=true //14
    else {
            atomicState.myHub=false
            mqtt.setmyhub("false")
            log("Standard Logging","INFO")
        }
    log ("Extended logging","LOG")
//    atomicState.myHub=false
}

def devSummary(evt=null) {
    atomicState.startupDiscovery="complete"
	log ("|    ==================================================", "ORANGE")
    nodes1=nodes.split(',')
	if (atomicState.MQTTRGBc>0) log ("         [${atomicState.MQTTRGBc}] Hubitat RGB control devices synched to MQTT", "GREEN")
	if (atomicState.MQTTRGBt>0) log ("         [${atomicState.MQTTRGBt}] Hubitat RGB temperature devices enabled on MQTT", "GREEN")
	if (atomicState.MQTTOnOffDevices>0) log ("         [${atomicState.MQTTOnOffDevices}] Hubitat switch devices enabled on MQTT", "GREEN")
	if (atomicState.MQTTDimDevices>0) log ("         [${atomicState.MQTTDimDevices}] Hubitat dimmer devices enabled on MQTT", "GREEN")
	if (atomicState.adhocDevices>0) log ("         [${atomicState.adhocDevices}] Hubitat virtual devices synched to MQTT", "GREEN")
    if (atomicState.MQTTLockDevices>0) log ("         [${atomicState.MQTTLockDevices}] Hubitat lock devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTKEYPADt>0) log ("         [${atomicState.MQTTKEYPADt}] Hubitat Security Keypad devices enabled on MQTT", "GREEN")    
    if (atomicState.MQTTgarageDevices>0) log ("         [${atomicState.MQTTgarageDevices}] Hubitat garage door devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTwindowDevices>0) log ("         [${atomicState.MQTTwindowDevices}] Hubitat window shade devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTChimeDevices>0) log ("         [${atomicState.MQTTChimeDevices}] Hubitat chime devices enabled on MQTT", "GREEN")   
    if (atomicState.MQTTBulbDevices>0) log ("         [${atomicState.MQTTBulbDevices}] Hubitat bulb devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTOutletDevices>0) log ("         [${atomicState.MQTTOutletDevices}] Hubitat outlet devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTThermostats>0) log ("         [${atomicState.MQTTThermostats}] Hubitat thermostat devices enabled on MQTT", "GREEN")    
    if (atomicState.MQTTValveDevices>0) log ("         [${atomicState.MQTTValveDevices}] Hubitat valve devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTGlobalVarDevices>0) log ("         [${atomicState.MQTTGlobalVarDevices}] Hubitat global variables enabled on MQTT", "GREEN")
    if (atomicState.MQTTgVarDevices>0) log ("         [${atomicState.MQTTgVarDevices}] Hubitat gVars enabled on MQTT", "GREEN")    
    if (atomicState.MQTTEverythingDevices>0) log ("         [${atomicState.MQTTEverythingDevices}] Hubitat 'everything' all capability devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTAlarmDevices>0) log ("         [${atomicState.MQTTAlarmDevices}] Hubitat alarm devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTRelaySwitchDevices>0) log ("        [ ${atomicState.MQTTRelaySwitchDevices}] Hubitat relay switch devices enabled on MQTT", "GREEN")
    if (atomicState.TotalDevices>0) log ("|    [${atomicState.TotalDevices}]  Hubitat devices are enabled on MQTT", "ORANGE")
    else log ("|    [${atomicState.TotalDevices}]  Hubitat devices are enabled on MQTT", "GREEN")
    if (nodes1.size()>0) log ("|    [${nodes1.size()}]  Hubitat endpoints enabled on MQTT", "ORANGE")
    else log ("|    [${nodes1.size()}]  Hubitat endpoints enabled on MQTT", "GREEN")
    numberDevs=0
    numberDisc=0
    if (settings?.ShellyDiscovery){
        sumLog (0, "Shelly relay devices", atomicState.ShellyDevices.size())
    }
    if (settings?.SonoffDiscovery){
        sumLog (0, "Sonoff devices", atomicState.SonoffDevices.size())
    }
    if (settings?.CBusDiscovery){
        if (settings?.CBus_light != null) CBl = settings?.CBus_light.size() else CBl=0  // Elvis isnt in the house TODO
            if (settings?.CBus_text != null) CBt = settings?.CBus_text.size() else CBt=0  // Elvis isnt in the house TODO
            sumLog (CBl, "C-Bus groups", atomicState.CBusLightDevices.size())
            sumLog (CBt, "C-Bus text", atomicState.CBusTextDevices.size())
    }
	if (settings?.homieDiscovery){
            if (settings?.Homie_onoff != null) ho = settings?.Homie_onoff.size() else ho=0  // Elvis isnt in the house TODO
			if (settings?.Homie_dim != null) hd = settings?.Homie_dim.size() else hd=0
			if (settings?.Homie_sensor != null) hs = settings?.Homie_sensor.size() else hs=0
			if (settings?.Homie_button != null) hb = settings?.Homie_button.size() else hb=0
			if (settings?.Homie_variable != null) hv = settings?.Homie_variable.size() else hv=0
            if (settings?.Homie_lock != null) hl = settings?.Homie_lock.size() else hl=0
            if (settings?.Homie_unknowns != null) hu = settings?.Homie_unknowns.size() else hu=0
                sumLog (ho, "homie onoff devices", atomicState.onoffDevices.size())
                sumLog (hd, "homie dim devices", atomicState.dimDevices.size())
                sumLog (hs, "homie sensor devices", atomicState.sensorDevices.size())
                sumLog (hb, "homie button devices", atomicState.buttonDevices.size())
                sumLog (hl, "homie lock devices", atomicState.lockDevices.size())
                sumLog (hv, "homie variable devices", atomicState.varDevices.size())
                sumLog (hu, "homie unknown devices", atomicState.homieUnknownDevices.size())
    }
	if (settings?.HAStatestream) {
            if (settings?.HA_Switches != null) HAsw = settings?.HA_Switches.size() else HAsw=0  // Elvis isnt in the house TODO
			if (settings?.HA_Lights != null) HAli = settings?.HA_Lights.size() else HAli=0
			if (settings?.HA_Sensors != null) HAse = settings?.HA_Sensors.size() else HAse=0
			if (settings?.HA_BinarySensors != null) HAbs = settings?.HA_BinarySensors.size() else HAbs=0
			if (settings?.HA_Groups != null) HAgr = settings?.HA_Groups.size() else HAgr=0
            if (settings?.HA_Presence != null) HApr = settings?.HA_Presence.size() else HApr=0
			if (settings?.HA_InputBooleans != null) HAib = settings?.HA_InputBooleans.size() else HAib=0
            if (settings?.HA_Covers != null) HAco = settings?.HA_Covers.size() else HAco=0
            if (settings?.HA_Locks != null) HAlo = settings?.HA_Locks.size() else HAlo=0
            if (settings?.HA_DeviceTrackers != null) HAdt = settings?.HA_DeviceTrackers.size() else HAdt=0
            if (settings?.HA_Climates != null) HAcl = settings?.HA_Climates.size() else HAcl=0
                sumLog (HAsw, "HA statestream switches ", atomicState.HASwitchDevices.size())
                sumLog (HAli, "HA statestream lights", atomicState.HALightDevices.size())
                sumLog (HAse, "HA statestream sensors", atomicState.HASensorDevices.size())
                sumLog (HAbs, "HA statestream binary sensors", atomicState.HABinarySensorDevices.size())
                sumLog (HAib, "HA statestream input booleans", atomicState.HAInputBooleanDevices.size())
                sumLog (HAco, "HA statestream locks", atomicState.HALockDevices.size())
                sumLog (HAcl, "HA statestream climate devices", atomicState.HAClimateDevices.size())
                sumLog (HAco, "HA statestream covers", atomicState.HACoverDevices.size())
                sumLog (HApr, "HA statestream presence", atomicState.HAPresenceDevices.size())
                //sumLog (HAau, "HA statestream automations", atomicState.HAInAutomations.size())
                sumLog (HAdt, "HA statestream device trackers", atomicState.HADeviceTrackerDevices.size())
                sumLog (HAgr, "HA statestream groups", atomicState.HAGroupDevices.size()) 
	}
    if (settings?.HAInDiscovery){      
            if (settings?.HAIn_switch != null) HAInsw = settings?.HAIn_switch.size() else HAInsw=0  // Elvis isnt in the house TODO
			if (settings?.HAIn_light != null) HAInli = settings?.HAIn_light.size() else HAInli=0
			if (settings?.HAIn_sensor != null) HAInse = settings?.HAIn_sensor.size() else HAInse=0
			if (settings?.HAIn_binary != null) HAInbs = settings?.HAIn_binary.size() else HAInbs=0
            if (settings?.HAIn_cover != null) HAInco = settings?.HAIn_cover.size() else HAInco=0
            if (settings?.HAIn_lock != null) HAInlo = settings?.HAIn_lock.size() else HAInlo=0
            if (settings?.HAIn_climate != null) HAIncl = settings?.HAIn_climate.size() else HAIncl=0
            if (settings?.HAIn_automation != null) HAInau = settings?.HAIn_automation.size() else HAInau=0
            if (settings?.HAIn_person != null) HAInpe = settings?.HAIn_person.size() else HAInpe=0
            if (settings?.HAIn_group != null) HAIngr = settings?.HAIn_group.size() else HAIngr=0             
                sumLog (HAInsw, "HA Discovery switches", atomicState.HAInSwitchDevices.size())
                sumLog (HAInli, "HA Discovery lights", atomicState.HAInLightDevices.size())
                sumLog (HAInse, "HA Discovery sensors", atomicState.HAInSensorDevices.size())
                sumLog (HAInbs, "HA Discovery binary sensors", atomicState.HAInBinarySensorDevices.size())
                sumLog (HAInco, "HA Discovery locks", atomicState.HAInLockDevices.size())
                sumLog (HAIncl, "HA Discovery climate devices", atomicState.HAInClimateDevices.size())
                sumLog (HAInco, "HA Discovery covers", atomicState.HAInCoverDevices.size())
                sumLog (HAInpe, "HA Discovery persons", atomicState.HAInPersonDevices.size())
                sumLog (HAInau, "HA Discovery automations", atomicState.HAInAutomations.size())
                sumLog (HAIngr, "HA Discovery groups", atomicState.HAInGroups.size())          
    }
    log ("|    Imported total [$numberDevs] of [$numberDisc] discovered","ORANGE")
	log ("|    ================== Startup complete ==================", "ORANGE")
	//mqtt.setStateVar ("MQTTmyStatus","present") // This is now showing MQTT Broker connected rather than startup complete.
	atomicState.started=true
    atomicState.abort=false // can't abort anymore
    if (settings?.homiePublish) {
        mqtt = getChildDevice("MQTT: Child device driver")
        mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$state','ready',1,true) 
    }
    atomicState.suppress = true  // after startup complete only payload change messages are sent to MQTT i.e. state changes  (same as min homie tree setting)
}

def sumLog (devNum, devType, discNum) {
    if (discNum>0) {
        if (devNum > 0) log ("|    Imported [$devNum] $devType of [$discNum] discovered", "ORANGE")
        else log ("|    Imported [$devNum] $devType of [$discNum] discovered", "GREEN")
        numberDevs+=devNum
        numberDisc+=discNum
    }
}
    

def sendPayload(topic,payload) {
	if (payload==null) {
		log ("Null payload for topic " + topic, "WARN")
		return
	}
	if (topic==null) {
		log ("Null topic for payload " + payload, "WARN")
		return
	}
	log ("Send MQTT " + topic + " " + payload, "TRACE")
    mqtt = getChildDevice("MQTT: Child device driver")
	mqtt.publishMsg (topic,payload,1,settings?.homieStatesPersist)
}

//=========================================================================================================================== trial methods

def findDeviceByName(name) {
    matchDevice = null
    settingsDevices = [settings?.switches, settings?.dimmers, settings?.lights, settings?.colour, settings?.colourT, settings?.colourMode, settings?.contactSensors]
    //atomicState.test=settingsDevices
    settingsDevices.find{
        if (matchDevice != null) {
            return true
        }
        it.find{
            if (((it.displayName)==name)|(normalize(it.displayName)==name)){ 
                matchDevice = it
                return true
            }
        }
    }
    if (matchDevice != null) return matchDevice
    settingsDevices = [settings?.everything, settings?.alarms, settings?.batterysensors, settings?.bulbs, settings?.buttons, settings?.buttonshold, settings?.buttonsPush,
        settings?.buttonsrelease, settings?.buttonsdtap, settings?.carbonmonoxidesensors, settings?.chimes, 
        settings?.fans, settings?.garagedoors, settings?.humiditysensors, settings?.illuminancesensors, settings?.keypads, 
        settings?.locks, settings?.motionsensors, settings?.mqtttext, settings?.musicplayers, settings?.outlets, settings?.powersensors, settings?.presencesensors,
        settings?.ramp, settings?.refresh, settings?.relayswitches, settings?.sensors, settings?.shocksensors, settings?.smokesensors, settings?.speechsynthesis, 
        settings?.tempsensors, settings?.thermostats, settings?.valves, settings?.voltagesensors, settings?.watersensors, settings?.windowshades]
        settingsDevices.find{
        if (matchDevice != null) {
            return true
        }
        it.find{
            if (normalize(it.displayName)==name){    
                matchDevice = it
                return true
            }
        }
    }
    if (matchDevice != null) return matchDevice   
    settingsDevices = [settings?.globVars, settings?.gVars]  //search globals last 
    settingsDevices.find{
        if (matchDevice != null) {
            return true
        }
        it.find{
            if (it.displayName==name){    
                matchDevice = it
                return true
            }
        }
    }
    if (matchDevice==null) log  ("Failed findDevice for $name","LOG")
    return matchDevice // could be null as nothing matched
}


def commandP(name, state, payload, fullPayload, cmd, topic, json) { // 'set' command from homie for a Hubitat or manual device via Hubitat basic 
    // TODO This has value and data transposed in the two versions for discovered and adhoc .. tidy up
    //def data = parseJson(evt.data)
    log("MQTT set command received for " + name + " " + cmd + " " + state + " " + topic + " " + payload, "KH")
    if (state=='' || state==null) {
        log ("An empty or null state value was received from a ../set topic {$name $state] and was BLOCKED from writing to an attribute as it would set it to null","WARN")
        return
    }

    normName = name
    matchName = name
    found = false
    cTime = now()
    mqtt = getChildDevice("MQTT: Child device driver")
    //     DNI=atomicState.newMap[normName]
    log("$cmd received $state", "TRACE")
    if (nameMap[normName] == null) {
        log("No name map for ${normName} so assume Hubitat basic topic or homie /hub", "TRACE") // could check from topic.topic[0]
        matchName = normName
    } else {
        matchName = nameMap[normName]
        found = true
    }
    log("$cmd received $state", "TRACE")
    dMatch = false
    everyThing == (settings?.everything)
    log("Everything Lookup for  " + name + " is " + matchName + " [" + nameMap[index] + "] ", "LOG")

    if (matchName == "hub") {
        if (cmd == "mode") {
            if (location.mode != state) {
                if (location.modes?.find {it.name==state}) 
                {
                    location.setMode(state)
                } else {
                    log("Hub Mode Cmd: unknown mode $state", "ERROR")
                }
            }
        }
        if (cmd=='hsmArm') {
            sTopic=	"homie/${atomicState.normHubName}/hub/hsmArm"
            if (!settings?.allowHSMControl) {
                mqtt.publishMsg (sTopic,'blocked',1,true)
                return
            }

            if (settings?.allowHSMDisarm) {
                if ("armAway, armHome, armNight, disarm, armRules, disarmRules, disarmAll, armAll, cancelAlerts".contains(state)){
                    sendLocationEvent(name: "hsmSetArm", value: state)
                    return
                }
                else {
                    log ("Unhandled Command $cmd [$state] for hub","WARN")
                    mqtt.publishMsg (sTopic,'unknown',1,true)
                    return
                }
            }
            else { 
                    if ("armAway, armHome, armNight, armRules, armAll, cancelAlerts".contains(state)){
                    sendLocationEvent(name: "hsmSetArm", value: state)
                    return
                }
                else {
                    log ("Unhandled Command $cmd [$state] for hub","WARN")
                    mqtt.publishMsg (sTopic,'unknown',1,true)
                    return
                }
            }

                

/*            
            if (state=='disarm') {
                log ("Need to disarm HSM","WARN")
                sendLocationEvent(name: "hsmSetArm", value: "disarm")
            }
            else if (state=='armAway') {
                log ("Need to arm Away HSM","WARN")
                sendLocationEvent(name: "hsmSetArm", value: "armAway")
            }
            else if (state=='armHome') {
                sendLocationEvent(name: "hsmSetArm", value: "armHome")
                log ("Need to arm Home HSM","WARN")
            }
            else if (state=='armNight') {
                log ("Need to arm Night HSM","WARN")
                sendLocationEvent(name: "hsmSetArm", value: "armNight")
            }
            else if (state=='armRules') {
                log ("Need to arm Away HSM","WARN")
                sendLocationEvent(name: "hsmSetArm", value: "armRules")
            }
            else if (state=='disarmRules') {
                log ("Need to disarm Rules HSM","WARN")
                sendLocationEvent(name: "hsmSetArm", value: "disarmRules")
            }
            else if (state=='armAll') {
                log ("Need to arm All HSM","WARN")
                sendLocationEvent(name: "hsmSetArm", value: "armAll")
            }
            else if (state=='disarmAll') {
                log ("Need to disarm All HSM","WARN")
                sendLocationEvent(name: "hsmSetArm", value: "disarmAll")
            }
            else if (state=='cancelAlerts') {
                log ("Need to cancel Alerts HSM","WARN")
                sendLocationEvent(name: "hsmSetArm", value: "cancelAlerts")
            }
            else log ("Unknown ../set command to hsmArm","WARN")

            return
        }
*/
       
    }
    }
    matchDevice = findDeviceByName(matchName)
    if (matchDevice!=null) log ("matchDevice is $matchDevice $matchName","LOG")
    else {
        log( "No matched device for $matchName","ERROR")
        return
    }
    
    if (!checkProperty(matchDevice,cmd)) {
        log ("This command is not permitted to this device $matchDevice","WARN")
        return
    }
    //log("Device Matched - " + matchDevice?.displayName + " - for command $cmd  $json", "LOG")
    if (json=='false') {
      if (cmd == "onoff" || cmd == "switch") { // TODO convert to select / case   'switch' comes from RGB devices
		if (matchDevice != null) {
            //proceed = dAttIsEnabled(it, cmd)
			proceed = dAttIsEnabled(matchDevice, cmd)
			if (!proceed) {     
				log("$device: ../onoff/set BLOCKED", "WARN")
				return
			}
			OnValues = "on,true,yes,1"
			OffValues = "off,false,no,0"
			if (OnValues.contains(state.toLowerCase())) {
                if (matchDevice.typeName=='Virtual Fan Controller') matchDevice.setSpeed('on')
				else matchDevice.on()
			} else if (OffValues.contains(state.toLowerCase())) {
                if (matchDevice.typeName=='Virtual Fan Controller') matchDevice.setSpeed('off')
				else matchDevice.off()
			} else log("Unknown state value " + state + " - need to add to lookup", "WARN")
		}
      } else if (cmd == "dim") {
        openHAB = false
        //log("Incoming dim /set $state", "WARN")
        val = "${state}"
        if (openHAB) intLevel = (Float.parseFloat(val) * 100).toInteger()
        else intLevel = state.toInteger()
        if ((0 <= intLevel)) //  && (intLevel <= 100)) //TODO Check removing this upper bound check doesn't break anything
        {
			if (matchDevice != null) {
                    matchDevice.setLevel(intLevel, 1)
                    dMatch = true
            }
		}
    } else if (cmd == "color") {
		if (matchDevice != null) {
			if (state[0] == '#') {
				try {
					RGB = hubitat.helper.ColorUtils.hexToRGB(state)
					HSV = hubitat.helper.ColorUtils.rgbToHSV(RGB)
					HSL = [: ]
					HSL.put('hue', HSV[0].toInteger())
					HSL.put('saturation', HSV[1].toInteger())
					HSL.put('level', HSV[2].toInteger())
					matchDevice.setColor(HSL)
				} catch (e) {
					log("#RRGGBB color /set error:  " + e, "ERROR")
				}
				dmatch = true
			} else {
				colour = payload
				try {
					hue = -1
					    if (payload.size > 0 && payload[0] != null) {
						float h = Float.parseFloat(payload[0])
						h = (h / 3.6) + 0.5
						hue = (int)(h)
						if (hue > 100) hue = 100
						else if (hue < 0) hue = 0
					}
					sat = -1
                        if (payload.size > 1 && payload[1] != null) {
						float s = Float.parseFloat(payload[1]) + 0.5
						sat = (int)(s)
						if (sat > 100) sat = 100
						else if (sat < 0) sat = 0
					}
					/*
					    if (payload[2] != null) {
						float v = Float.parseFloat(payload[1]) + 0.5
						val = (int) (v)
						if (val>100) val=100
						else if (val<0) val=0
					}
		*/
					// (Untested change request)
					    if (payload.size > 2 && payload[2] != null) {
						val = payload[2].toInteger()
						if (val > 100) val = 100
						else if (val < 0) val = 0
					} else val = -1
					log("Color data is $payload   hue:$hue    sat:$sat    value:$val", "TRACE")
					if (val == -1) { // from HA - has no 'level'
						if (hue >= 0) matchDevice.setHue(hue)
						if (sat >= 0) matchDevice.setSaturation(sat)
					} else if ((hue >= 0) && (sat >= 0) && (val >= 0)) //all present
					{
						HSL = [: ]
						HSL.put('hue', hue)
						HSL.put('saturation', sat)
						HSL.put('level', val)
						log("HSL set value is $HSL", "INFO")
						matchDevice.setColor(HSL)
						dMatch = true
					}
				} catch (e) {
					log("HSV colour set error format is h,s,v :  " + e, "ERROR")
				}
			}
		}
        
    } else if (cmd == "hsv") {
		if (matchDevice != null) {
			matchDevice.setSaturation(payload[1].toInteger())
			matchDevice.setHue(payload[0].toInteger())
			matchDevice.setLevel(payload[2].toInteger())
			dMatch = true
		}

    } else if (cmd == "hue") {
		if (matchDevice != null) {
			matchDevice.setHue(payload[0].toInteger())
        }
    } else if (cmd == "level") { // currently only searching colour bulbs for this as it's a RGB event
		if (matchDevice != null) {
			matchDevice.setLevel(payload[0].toInteger())
        }
    } else if (cmd == "saturation") {
		if (matchDevice != null) {
                matchDevice.setSaturation(payload[0].toInteger())
        }
    } else if (cmd == "color-temperature") { // This is from the homie topic       //TOD these on homie are normalised names - need to match as such i.e. as in thermostats below TODO BUG ??
            if (matchDevice != null) {
            int cKelvin = state.toInteger()
            int cMired = 0
            if (cKelvin > 1000) cMired = (int) 1000000 / cKelvin // was Kelvin
            else { // wasalready  mireds
                cMired = cKelvin
                cKelvin = (int) 1000000 / cMired
            }
            matchDevice.setColorTemperature(cKelvin)
        }

    }
    //Casey <
    else if (cmd == "lock") {
		if (matchDevice != null) {
                // DUPLICATED TODO combine this as one method for all
                log("Surmising required state [" + state + "] for " + name, "DEBUG")
                LockValues = "true"
                UnlockValues = "false"
                if (LockValues.contains(state.toLowerCase())) {
                    //if (devType == "system")
                    matchDevice.lock() // think can only be a system type here
                    //else device.toON()
                } else if (UnlockValues.contains(state.toLowerCase())) {
                    if (settings?.allowMqttUnlock) {
                        matchDevice.unlock() // think can only be a system type here                    
                    } else {
                        log("To enable MQTT unlock, you must enable in MQTT app settings 'configuration'", "WARN")
                    }
                } else log("Unknown state value " + state + " - need to add to lookup", "WARN")
        }
    }
    //Casey >        
    else if (cmd == "contact") {
		if (matchDevice != null) {
                // DUPLICATED TODO combine this as one method for all
                log("Surmising required state [" + state + "] for " + name, "DEBUG")
                CloseValues = "close"
                OpenValues = "open"
                if (CloseValues.contains(state.toLowerCase())) {
                    //if (devType == "system")
                    matchDevice.close() // think can only be a system type here
                    //else device.toON()
                } else if (OpenValues.contains(state.toLowerCase())) {
                    //if (settings?.allowMqttUnlock) {
                    matchDevice.open() // think can only be a system type here                    
                    // } else {
                    //     log ("To enable MQTT unlock, you must enable in MQTT app settings 'configuration'","WARN")
                    // }
                } else log("Unknown state value " + state + " - need to add to lookup", "WARN")
        }
    } else if (cmd == "battery" || cmd == "motion" || cmd == "temperature") {
        log("Trying to 'set' a sensor value ${cmd} for $name", "WARN")
        log("   ... only 'onoff' 'dim' 'color' 'color-temperature' 'window shades' 'valve' 'garage doors'and 'locks' are settable currently", "WARN")
    } else if (cmd == "valve") {
		if (matchDevice != null) {
			// DUPLICATED TODO combine this as one method for all
			log("Surmising required state [" + state + "] for " + name, "DEBUG")
			CloseValues = "closed"
			OpenValues = "open"
			if (CloseValues.contains(state.toLowerCase())) {
				// if (devType == "system")
				matchDevice.close() // think can only be a system type here
				//else device.toON()
			} else if (OpenValues.contains(state.toLowerCase())) {
				//if (settings?.allowMqttUnlock) {
				matchDevice.open() // think can only be a system type here                    
				// } else {
				//     log ("To enable MQTT unlock, you must enable in MQTT app settings 'configuration'","WARN")
				// }
			} else log("Unknown state value " + state + " - need to add to lookup", "WARN")
		}
    } else if (cmd == "heating-setpoint" || cmd == "cooling-setpoint" || cmd=="thermostat-setpoint" || cmd == "mode" || cmd == "fanmode") { // Thermostat temporary handler shouldnt be in sensors
		if (matchDevice != null) {
			//log ("Changing $cmd of ${matchDevice.displayName} to $state","ERROR")                        
			if (cmd == "heating-setpoint") {
				Float setTemp = state.toFloat() // string seemed to error -- just rechecking
				matchDevice.setHeatingSetpoint(setTemp)
				//matchDevice.setHeatingSetpoint(state)
			} else if (cmd == "cooling-setpoint") {
				setTemp = state.toFloat()
				//thermDev.setCoolingSetpoint(state)
				matchDevice.setCoolingSetpoint(setTemp)
            } else if (cmd == "thermostat-setpoint") {
				setTemp = state.toFloat()
				//thermDev.setCoolingSetpoint(state)
                log ("TODO devType test for .setThermostatSetpoint","KH")
				//matchDevice.setThermostatSetpoint(setTemp)
                matchDevice.setThermostatSetpoint(setTemp,false)  // added this for "Remote Thermostat" only - should add devType if
			} else if (cmd == "mode") matchDevice.setThermostatMode(state)
			else if (cmd == "fanmode") matchDevice.setThermostatFanMode(state)
        }
    } else if (cmd == "securitymode") {
        if (state == '----') return
        // >> @jwilliams
		if (matchDevice != null) {
			setStatus = ""
			ArmValues = "armed night,armed home,armed away"
			if (ArmValues.contains(state.toLowerCase())) {
				if (mqttKeypadMode == "No Keycode needed") {
					setStatus = state
				} else if ((mqttKeypadMode == "Keycode to Arm only" || mqttKeypadMode == "Keycode to Arm/Disarm") && mqttKeypadCode == payload[1]) {
					setStatus = state
				}
			} else if ((state == 'disarm')||(state=='silence')||(state=='siren')) {  // siren control
				if (mqttKeypadMode == "Keycode to Arm/Disarm") {
					if (mqttKeypadCode == payload[1]) setStatus = state
				} else if (mqttKeypadMode != "No control of keypad") {
					setStatus = state
				}

			}
			log("Setting Status to ${setStatus}", "DEBUG")
			if (setStatus == 'armed night') matchDevice.armNight()
			else if (setStatus == 'armed home') matchDevice.armHome()
			else if (setStatus == 'armed away') matchDevice.armAway()
			else if (setStatus == 'disarm') matchDevice.disarm()
            else if (setStatus == 'silence') matchDevice.off()
            else if (setStatus == 'siren') matchDevice.siren()
			// << @jwilliams             
			else {
				String code = matchDevice.currentLockCodes.toString()
				mqtt.publishMsg("homie/${atomicState.normHubName}/${matchName}/securitymode/set", '----', 1, false)
				//if (code.contains(':"' + state + '"}')) matchDevice.disarm()
				if (code.contains('{"name":"MQTT","code":"' + state + '"}')) matchDevice.disarm()
			}
        }
        if (dMatch) return
    } else if (cmd == "variable") {
        if (state=='' || state==null) return
        if (matchDevice!=null){
            
            log ("Setting varaiable to $state","KH")
            matchDevice.setVariable(state)
        }
        
/*       
        gVariables = (settings?.gVars)
        gVariables.each {
            //if (normalize(matchDevice.displayName)==matchName){
            if (matchDevice.displayName == matchName) {
                matchDevice.setVariable(state)
                dMatch = true
            }
            return dMatch
        }
        if (dMatch) return
        gVariables = (settings?.globVars)
        gVariables.each {
            //if (normalize(matchDevice.displayName)==matchName){
            if (matchDevice.displayName == matchName) {
                matchDevice.setVariable(state)
                dMatch = true
            }
            return dMatch
        }
        if (dMatch) return
 */
       } else if (cmd == "speech") {
		if (matchDevice != null) {
			matchDevice.speak(state, 30)
        }
    } else if (cmd == "speed") {
        if (matchDevice != null) {
            matchDevice.setSpeed(state)
        }
    
    } else if (cmd == "music") {
		if (matchDevice != null) {
			log("Music Command not yet implemented " + matchDevice + " [" + state + "]", "WARN")
        }
    } else if (cmd == "measure-temperature") {
        if (matchDevice != null) {
            if (matchDevice.typeName == "Virtual Thermostat")  matchDevice.setTemperature (state)
    
        }
    } else if (cmd == "text") {
        if (matchDevice != null) {
            matchDevice.setText(state)
        }
    
    } else if (cmd == "position") {
        if (matchDevice != null) {
            if (matchDevice.hasCommand('setPosition')) matchDevice.setPosition(state)
            else matchDevice.setLevel(state)
        }
    
    }  else if (cmd == "prefix") {
        if (matchDevice != null) {
            matchDevice.setPrefix(state)
        }
    
    } else if (cmd == "suffix") {
        if (matchDevice != null) {
            matchDevice.setSuffix(state)
        }
    } else if (cmd == "refresh") {
        if (matchDevice != null) {
                if (matchDevice.hasCommand("refresh")){
                         matchDevice.refresh()
                         mqtt.publishMsg("homie/${atomicState.normHubName}/${normalize(matchName)}/refresh", 'true', 1, false)
                         pauseExecution (250) 
                         mqtt.publishMsg("homie/${atomicState.normHubName}/${normalize(matchName)}/refresh", 'false', 1, false)
                }  
        }    
    }  else if (cmd == "state") {
        if (matchDevice != null) {
            // DUPLICATED TODO combine this as one method for all
            log("Surmising required state [" + state + "] for " + name, "DEBUG")
            CloseValues = "close"
            OpenValues = "open"
            if (CloseValues.contains(state.toLowerCase())) {
                matchDevice.close()
            } else if (OpenValues.contains(state.toLowerCase())) {
                matchDevice.open()
            } else log("Unknown state value " + state + " - need to add to lookup", "WARN")
        }
    } else if (cmd =="door"){
        if (matchDevice != null) {
            if (state=='open') matchDevice.open()
            if (state=='close') matchDevice.close()
        }
    }
   else log("No matching devices with this command available for ${cmd} for $name $state", "WARN")
  }
  else {    // json payload
       if (cmd == 'ramp') {
           def data = parseJson(fullPayload)
           ramp = data.ramp.toInteger()
           intLevel = data.level.toInteger()  // ToDo range check
           if ((0 <= intLevel)) { //  && (intLevel <= 100)) //TODO Check removing this upper bound check doesn't break anything
		 	  if (matchDevice != null) {  
                matchDevice.setLevel(intLevel,data.ramp)
                mqtt.publishMsg("homie/${atomicState.normHubName}/${normalize(matchName)}/ramp",ramp.toString(), 1)
                dMatch = true
                matchDevice.updateDataValue("[MQTT]_ramp", ramp.toString())
            }
		}

     }   
  }
}

def checkProperty (dev,cmd) {
    props= dev.getDataValue("properties")
    if ((props!=null)&&(props!='')&&(props!=' ')) {
        if ((props.contains(cmd))) return (true) else return (false)
    }
      // TODO   need to match only xyz and not say xyzextra or extraxyx
    return (false)
   }   

def HAIn(payload,type,topic,json) {
    log ("HAIn payload is $payload  $topic","LOG")
    if (payload=='null') return

    def data = parseJson(payload)
    UID=data.unique_id
    skipAll=false
    name=data.name
        if (type==null) {
        log ("Bad config topic: No name for device topic $topic $payload","WARN")
        return
    }
    if (name==null) {
        log ("Bad config topic: No name for [$type] device $topic $payload","WARN")
        return
    }    
    
    if (UID!=null && UID.startsWith("Hubitat-")) {  // originates from a Hubitat hub
        if (skipAll == true) {
            log ("skipped $name [$type] in MQTT Discovery as originated from a Hubitat hub", "INFO")
            return
        }
        
        if (data.device.model==atomicState.normHubName) {
            log ("skipped $name [$type] in MQTT Discovery as originated from this hub", "INFO")
            return // always skip HA advertised devices originating from this hub
        }
    }
    log ("HA In Discovery for [$type] $name","KH")
    if (type=='switch') HAInSwitch(name,name,type,data)
    else if (type=='light') HAInLight(name,name,type,data)
    else if (type=='binary_sensor') HAInBinarySensor(name,name,type,data)
    else if (type=='climate') HAInClimate(name,name,type,data)
    else if (type=='sensor') HAInSensor(name,name,type,data)
    else if (type=='cover') HAInCover(name,name,type,data)
    else if (type=='lock') HAInLock(name,name,type,data)
    else if (type=="person") HAInPerson(name,name,type,data)
    else if (type=="automation") HAInAutomation(name,name,type,data)
    else if (type=="group") HAInGroup(name,name,type,data)
    // alarm_control_panel  camera  device_automation  still to handle
    else log ("This type [$type] for $name is not supported yet" , "LOG")

}

def HAInUOM (payload,type,topic,json) {
    if (payload=='null') return
    name=topic[2]
/*
    lastHyphen=name.lastIndexOf("_")     // the - has been stripped (normalised)
    if (lastHyphen!=-1){
        derivedType=name.substring(lastHyphen)
        //log  ("Derived type is $derivedType","KH")
        if (derivedType=="_temperature") log ("Likely a temperature device $payload","LOG")
        else if (derivedType=="_battery") log ("Likely a battery device $payload","LOG")
        else if (derivedType=="_illuminance") log ("Likely a illuminance device $payload","LOG")
        else if (derivedType=="_luminance") log ("Likely a luminance device $payload","LOG")
        else if (derivedType=="_moisture") log ("Likely a moisture device $payload","LOG")
        else if (derivedType=="_demand") log ("Likely a demand device $payload","LOG")
        else if (derivedType=="_power") log ("Likely a power device $payload","LOG")
        else if (derivedType=="_level") log ("Likely a level device $payload","LOG")
        else if (derivedType=="_conductivity") log ("Likely a conductivity device $payload","LOG")
        else  log ("Unhandled [$derivedType] device $payload","KH")
    }
*/
    if (type=='sensor') HAInSensor(name,name,type)
    else if (type=='binary_sensor') HAInBinarySensor(name,name,type)

}
def HAInState (payload,type,topic,json) {
    if (payload=='null')return
    name=topic[2]
/*
    lastHyphen=name.lastIndexOf("_")     // the - has been stripped (normalised)
    if (lastHyphen!=-1){
        derivedType=name.substring(lastHyphen)
        //log  ("Derived type is $derivedType","KH")
        if (derivedType=="_temperature") log ("Likely a temperature device $payload","LOG")
        else if (derivedType=="_battery") log ("Likely a battery device $payload","LOG")
        else if (derivedType=="_illuminance") log ("Likely a illuminance device $payload","LOG")
        else if (derivedType=="_luminance") log ("Likely a luminance device $payload","LOG")
        else if (derivedType=="_moisture") log ("Likely a moisture device $payload","LOG")
        else if (derivedType=="_demand") log ("Likely a demand device $payload","LOG")
        else if (derivedType=="_power") log ("Likely a power device $payload","LOG")
        else if (derivedType=="_level") log ("Likely a level device $payload","LOG")
        else if (derivedType=="_conductivity") log ("Likely a conductivity device $payload","LOG")
        else  log ("Unhandled [$derivedType] device $payload","KH")
    }
*/
    // These are missing config topics  
    if (type=='sensor') {
        //HAInSensor(name,name,type)
        //log ("skipped sensor $name","KH")
    }
    else if (type=='binary_sensor') {
        // HAInBinarySensor(name,name,type)
        //log ("skipped binary sensor $name","KH")
    } 
    else if (type=='cover') HAInCover(name,name,type)
    else if (type=='lock') HAInLock(name,name,type)
    else if (type=='climate') HAInClimate(name,name,type)
    else if (type=="person") HAInPerson(name,name,type)
    else if (type=="automation") HAInAutomation(name,name,type)
    else if (type=="group") HAInGroup(name,name,type)
    else if (type=='switch') {
        //HAInSwitch(name,name,type)
        log ("skipped switch $name","KH")
        }
    else if (type=='light') {
        //HAInLight(name,name,type)
        log ("skipped light $name","KH")
    }

}

def HAInFriendlyName (payload,type,topic,json) {
    if (payload=='null') return
    name=topic[2]
/*
    lastHyphen=name.lastIndexOf("_")     // the - has been stripped (normalised)
    if (lastHyphen!=-1){
        derivedType=name.substring(lastHyphen)
        //log  ("Derived type is $derivedType","KH")
        if (derivedType=="_temperature") log ("Likely a temperature device $payload","LOG")
        else if (derivedType=="_battery") log ("Likely a battery device $payload","LOG")
        else if (derivedType=="_illuminance") log ("Likely a illuminance device $payload","LOG")
        else if (derivedType=="_luminance") log ("Likely a luminance device $payload","LOG")
        else if (derivedType=="_moisture") log ("Likely a moisture device $payload","LOG")
        else if (derivedType=="_demand") log ("Likely a demand device $payload","LOG")
        else if (derivedType=="_power") log ("Likely a power device $payload","LOG")
        else if (derivedType=="_level") log ("Likely a level device $payload","LOG")
        else if (derivedType=="_conductivity") log ("Likely a conductivity device $payload","LOG")
        else  log ("Unhandled [$derivedType] device $payload","KH")
    }
*/

//    if (type=='sensor') HAInSensor(name,name,type)
//    else if (type=='binary_sensor') HAInBinarySensor(name,name,type)
}

def zigbee(payload,name, json) {
    if (name == 'bridge') {
        typeBegin=payload.indexOf('}],"type":')
        typeEnd=payload.indexOf('"}',typeBegin)
        type = payload.substring(typeBegin+11, typeEnd)
        friendlyBegin = payload.indexOf('"friendly_name":',typeBegin)
        friendlyEnd = payload.indexOf('","',friendlyBegin)
        name = payload.substring(friendlyBegin+17, friendlyEnd)
        log ("Zigbee $name type is $type","KH")
        if (type=='switch') zigbee2mqttLight(name,name,type)
        else if (type=='light') zigbee2mqttLight(name,name,type)
        else if (type=='binary_sensor') zigbee2mqttLight(name,name,type)
        else if (type=='climate') zigbee2mqttLight(name,name,type)
        else if (type=='sensor') zigbee2mqttLight(name,name,type)
        else log ("This type [$type] for $name is not supported yet" , "LOG")
    }
    else {
        def data = parseJson(payload)
        log ("Payload is $payload","KH")
        log ("Data is " + data, "KH")
        log ("State is " + data.state , "KH")
        log("This device $name is changing state to $state","LOG")
    }
}
def zigbeeDev(payload,name, json) {
        def data = parseJson(payload)
        //state= data.state
        log("This device $name is changing state to " + data.state,"LOG")
        log("This device $name is changing occupancy to " + data.occupancy,"LOG")
}

def CBusIn (name,type,payload,topic) {
    if (type=='group') {
        // create from group message - dont use group in topic hierarchy though
        group=payload[0]
        CBusCreate (name, "light", group, topic)
        //createChildDevice(name, type, system, friendlyName=null, dType='default',seq=0, config=null)
    }
    if (type=='state') state=payload[0] //dont have to handle on/off as CBus adjusts based on level
    if (type=='level') CBusDim (name,payload[0].toInteger())
}

def CBusDim (name,level) {
    adjLevel=(level/2.55).toInteger()   //should retrieve maxLevel  TODO
    dev=getChildDevice("MQTT:CBus_" + name)
    if (dev) dev.setLevel(adjLevel)
    nName=normalize(name)
    if (level==0) lastDevOnOff = "$nName [OFF]"
    else lastDevOnOff = "$nName [ON]"
    lastDevDim = "$nName [$adjLevel]"
}

def CBusTextIn (payload,name,json) {
    //value=payload[0]
    //CBus (name,value,"temperature")  // assuming text are all temperature value FTTB
}

def zwave(payload,type, json) {
    //log ("zwave from $type","LOG")
    return  // incomplete
    def data = parseJson(payload)
    name=data.name
    if (type=='switch') HAInSwitch(name,name,type)
    else if (type=='light') HAInLight(name,name,type)
    else if (type=='binary_sensor') HAInBinarySensor(name,name,type)
    else if (type=='climate') HAInClimate(name,name,type)
    else if (type=='sensor') HAInSensor(name,name,type)
    else log ("This type [$type] for $name is not supported yet" , "LOG")
}



/*
Need a lookup array for these :-(
'act_t':               'action_topic',
'act_tpl':             'action_template',
'atype':               'automation_type',
'aux_cmd_t':           'aux_command_topic',
'aux_stat_tpl':        'aux_state_template',
'aux_stat_t':          'aux_state_topic',
'avty'                 'availability',
'avty_mode':           'availability_mode',
'avty_t':              'availability_topic',
'away_mode_cmd_t':     'away_mode_command_topic',
'away_mode_stat_tpl':  'away_mode_state_template',
'away_mode_stat_t':    'away_mode_state_topic',
'b_tpl':               'blue_template',
'bri_cmd_t':           'brightness_command_topic',
'bri_scl':             'brightness_scale',
'bri_stat_t':          'brightness_state_topic',
'bri_tpl':             'brightness_template',
'bri_val_tpl':         'brightness_value_template',
'clr_temp_cmd_tpl':    'color_temp_command_template',
'bat_lev_t':           'battery_level_topic',
'bat_lev_tpl':         'battery_level_template',
'chrg_t':              'charging_topic',
'chrg_tpl':            'charging_template',
'clr_temp_cmd_t':      'color_temp_command_topic',
'clr_temp_stat_t':     'color_temp_state_topic',
'clr_temp_tpl':        'color_temp_template',
'clr_temp_val_tpl':    'color_temp_value_template',
'cln_t':               'cleaning_topic',
'cln_tpl':             'cleaning_template',
'cmd_off_tpl':         'command_off_template',
'cmd_on_tpl':          'command_on_template',
'cmd_t':               'command_topic',
'cmd_tpl':             'command_template',
'cod_arm_req':         'code_arm_required',
'cod_dis_req':         'code_disarm_required',
'curr_temp_t':         'current_temperature_topic',
'curr_temp_tpl':       'current_temperature_template',
'dev':                 'device',
'dev_cla':             'device_class',
'dock_t':              'docked_topic',
'dock_tpl':            'docked_template',
'err_t':               'error_topic',
'err_tpl':             'error_template',
'fanspd_t':            'fan_speed_topic',
'fanspd_tpl':          'fan_speed_template',
'fanspd_lst':          'fan_speed_list',
'flsh_tlng':           'flash_time_long',
'flsh_tsht':           'flash_time_short',
'fx_cmd_t':            'effect_command_topic',
'fx_list':             'effect_list',
'fx_stat_t':           'effect_state_topic',
'fx_tpl':              'effect_template',
'fx_val_tpl':          'effect_value_template',
'exp_aft':             'expire_after',
'fan_mode_cmd_tpl':    'fan_mode_command_template',
'fan_mode_cmd_t':      'fan_mode_command_topic',
'fan_mode_stat_tpl':   'fan_mode_state_template',
'fan_mode_stat_t':     'fan_mode_state_topic',
'frc_upd':             'force_update',
'g_tpl':               'green_template',
'hold_cmd_tpl':        'hold_command_template',
'hold_cmd_t':          'hold_command_topic',
'hold_stat_tpl':       'hold_state_template',
'hold_stat_t':         'hold_state_topic',
'hs_cmd_t':            'hs_command_topic',
'hs_stat_t':           'hs_state_topic',
'hs_val_tpl':          'hs_value_template',
'ic':                  'icon',
'init':                'initial',
'hum_cmd_t':           'target_humidity_command_topic',
'hum_cmd_tpl':         'target_humidity_command_template',
'hum_stat_t':          'target_humidity_state_topic',
'hum_stat_tpl':        'target_humidity_state_template',
'json_attr':           'json_attributes',
'json_attr_t':         'json_attributes_topic',
'json_attr_tpl':       'json_attributes_template',
'max_mirs':            'max_mireds',
'min_mirs':            'min_mireds',
'max_temp':            'max_temp',
'min_temp':            'min_temp',
'max_hum':             'max_humidity',
'min_hum':             'min_humidity',
'mode_cmd_tpl':        'mode_command_template',
'mode_cmd_t':          'mode_command_topic',
'mode_stat_tpl':       'mode_state_template',
'mode_stat_t':         'mode_state_topic',
'modes':               'modes',
'name':                'name',
'off_dly':             'off_delay',
'on_cmd_type':         'on_command_type',
'opt':                 'optimistic',
'osc_cmd_t':           'oscillation_command_topic',
'osc_cmd_tpl':         'oscillation_command_template',
'osc_stat_t':          'oscillation_state_topic',
'osc_val_tpl':         'oscillation_value_template',
'pct_cmd_t':           'percentage_command_topic',
'pct_cmd_tpl':         'percentage_command_template',
'pct_stat_t':          'percentage_state_topic',
'pct_val_tpl':         'percentage_value_template',
'pl':                  'payload',
'pl_arm_away':         'payload_arm_away',
'pl_arm_home':         'payload_arm_home',
'pl_arm_custom_b':     'payload_arm_custom_bypass',
'pl_arm_nite':         'payload_arm_night',
'pl_avail':            'payload_available',
'pl_cln_sp':           'payload_clean_spot',
'pl_cls':              'payload_close',
'pl_disarm':           'payload_disarm',
'pl_home':             'payload_home',
'pl_lock':             'payload_lock',
'pl_loc':              'payload_locate',
'pl_not_avail':        'payload_not_available',
'pl_not_home':         'payload_not_home',
'pl_off':              'payload_off',
'pl_on':               'payload_on',
'pl_open':             'payload_open',
'pl_osc_off':          'payload_oscillation_off',
'pl_osc_on':           'payload_oscillation_on',
'pl_paus':             'payload_pause',
'pl_stop':             'payload_stop',
'pl_strt':             'payload_start',
'pl_stpa':             'payload_start_pause',
'pl_ret':              'payload_return_to_base',
'pl_rst_hum':          'payload_reset_humidity',
'pl_rst_mode':         'payload_reset_mode',
'pl_rst_pct':          'payload_reset_percentage',
'pl_rst_pr_mode':      'payload_reset_preset_mode',
'pl_toff':             'payload_turn_off',
'pl_ton':              'payload_turn_on',
'pl_unlk':             'payload_unlock',
'pos_clsd':            'position_closed',
'pos_open':            'position_open',
'pow_cmd_t':           'power_command_topic',
'pow_stat_t':          'power_state_topic',
'pow_stat_tpl':        'power_state_template',
'pr_mode_cmd_t':       'preset_mode_command_topic',
'pr_mode_cmd_tpl':     'preset_mode_command_template',
'pr_mode_stat_t':      'preset_mode_state_topic',
'pr_mode_val_tpl':     'preset_mode_value_template',
'pr_modes':            'preset_modes',
'r_tpl':               'red_template',
'ret':                 'retain',
'rgb_cmd_tpl':         'rgb_command_template',
'rgb_cmd_t':           'rgb_command_topic',
'rgb_stat_t':          'rgb_state_topic',
'rgb_val_tpl':         'rgb_value_template',
'send_cmd_t':          'send_command_topic',
'send_if_off':         'send_if_off',
'set_fan_spd_t':       'set_fan_speed_topic',
'set_pos_tpl':         'set_position_template',
'set_pos_t':           'set_position_topic',
'pos_t':               'position_topic',
'pos_tpl':             'position_template',
'spd_rng_min':         'speed_range_min',
'spd_rng_max':         'speed_range_max',
'src_type':            'source_type',
'stat_clsd':           'state_closed',
'stat_closing':        'state_closing',
'stat_off':            'state_off',
'stat_on':             'state_on',
'stat_open':           'state_open',
'stat_opening':        'state_opening',
'stat_stopped':        'state_stopped',
'stat_locked':         'state_locked',
'stat_unlocked':       'state_unlocked',
'stat_t':              'state_topic',
'stat_tpl':            'state_template',
'stat_val_tpl':        'state_value_template',
'stype':               'subtype',
'sup_feat':            'supported_features',
'swing_mode_cmd_tpl':  'swing_mode_command_template',
'swing_mode_cmd_t':    'swing_mode_command_topic',
'swing_mode_stat_tpl': 'swing_mode_state_template',
'swing_mode_stat_t':   'swing_mode_state_topic',
'temp_cmd_tpl':        'temperature_command_template',
'temp_cmd_t':          'temperature_command_topic',
'temp_hi_cmd_tpl':     'temperature_high_command_template',
'temp_hi_cmd_t':       'temperature_high_command_topic',
'temp_hi_stat_tpl':    'temperature_high_state_template',
'temp_hi_stat_t':      'temperature_high_state_topic',
'temp_lo_cmd_tpl':     'temperature_low_command_template',
'temp_lo_cmd_t':       'temperature_low_command_topic',
'temp_lo_stat_tpl':    'temperature_low_state_template',
'temp_lo_stat_t':      'temperature_low_state_topic',
'temp_stat_tpl':       'temperature_state_template',
'temp_stat_t':         'temperature_state_topic',
'temp_unit':           'temperature_unit',
'tilt_clsd_val':       'tilt_closed_value',
'tilt_cmd_t':          'tilt_command_topic',
'tilt_cmd_tpl':        'tilt_command_template',
'tilt_inv_stat':       'tilt_invert_state',
'tilt_max':            'tilt_max',
'tilt_min':            'tilt_min',
'tilt_opnd_val':       'tilt_opened_value',
'tilt_opt':            'tilt_optimistic',
'tilt_status_t':       'tilt_status_topic',
'tilt_status_tpl':     'tilt_status_template',
't':                   'topic',
'uniq_id':             'unique_id',
'unit_of_meas':        'unit_of_measurement',
'val_tpl':             'value_template',
'whit_val_cmd_t':      'white_value_command_topic',
'whit_val_scl':        'white_value_scale',
'whit_val_stat_t':     'white_value_state_topic',
'whit_val_tpl':        'white_value_template',
'xy_cmd_t':            'xy_command_topic',
'xy_stat_t':           'xy_state_topic',
'xy_val_tpl':          'xy_value_template',

Supported abbreviations for device registry configuration:

'cns':                 'connections',
'ids':                 'identifiers',
'name':                'name',
'mf':                  'manufacturer',
'mdl':                 'model',
'sw':                  'sw_version',
'sa':                  'suggested_area',

*/

